diff -ruN oscam-emu-2015-12-03-11142.orig/CMakeLists.txt oscam-emu-2015-12-03-11142/CMakeLists.txt
--- oscam-emu-2015-12-03-11142.orig/CMakeLists.txt	2015-10-01 19:27:33.000000000 +0300
+++ oscam-emu-2015-12-03-11142/CMakeLists.txt	2015-12-04 00:43:30.000000000 +0300
@@ -99,6 +99,7 @@
     ${CMAKE_CURRENT_SOURCE_DIR}/csctapi
     ${CMAKE_CURRENT_SOURCE_DIR}/cscrypt
     ${CMAKE_CURRENT_SOURCE_DIR}/minilzo
+    ${CMAKE_CURRENT_SOURCE_DIR}/ffdecsa
     ${CMAKE_CURRENT_SOURCE_DIR}/extapi/cygwin
     /usr/include/w32api
     ${OPTIONAL_INCLUDE_DIR}
@@ -108,6 +109,7 @@
     ${CMAKE_CURRENT_SOURCE_DIR}/csctapi
     ${CMAKE_CURRENT_SOURCE_DIR}/cscrypt
     ${CMAKE_CURRENT_SOURCE_DIR}/minilzo
+    ${CMAKE_CURRENT_SOURCE_DIR}/ffdecsa
     ${OPTIONAL_INCLUDE_DIR}
     )
 endif (OSCamOperatingSystem MATCHES "Windows/Cygwin")
@@ -415,6 +417,13 @@
 # Manage config.h based on command line parameters
 # Manipulate config file based on given parameters and read unset parameters
 
+execute_process (COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/config.sh --enabled WITH_EMU OUTPUT_VARIABLE CONFIG_WITH_EMU OUTPUT_STRIP_TRAILING_WHITESPACE)
+if (CONFIG_WITH_EMU MATCHES "Y" AND NOT WITH_EMU EQUAL 1)
+	add_definitions ("-DWITH_EMU")
+	set (WITH_EMU "1")
+	message(STATUS "  EMU is added by config compiling with EMU")
+endif(CONFIG_WITH_EMU MATCHES "Y" AND NOT WITH_EMU EQUAL 1)
+
 execute_process (COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/config.sh --show-valid OUTPUT_VARIABLE config_vars_string OUTPUT_STRIP_TRAILING_WHITESPACE)
 string(REGEX MATCHALL "[A-Z0-9_]+" config_vars ${config_vars_string})
 
@@ -444,6 +453,7 @@
 add_subdirectory (csctapi)
 add_subdirectory (minilzo)
 add_subdirectory (cscrypt)
+add_subdirectory (ffdecsa)
 
 #----------------------- file groups ------------------------------
 execute_process (COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/config.sh --enabled MODULE_CAMD33 OUTPUT_VARIABLE CAMD33 OUTPUT_STRIP_TRAILING_WHITESPACE)
@@ -493,7 +503,7 @@
 
 set (exe_name "oscam")
 add_executable (${exe_name} ${exe_srcs} ${exe_hdrs})
-target_link_libraries (${exe_name} ${csoscam} ${csmodules} ${csreaders} csctapi cscrypt minilzo)
+target_link_libraries (${exe_name} ${csoscam} ${csmodules} ${csreaders} csctapi cscrypt minilzo ffdecsa)
 if(HAVE_LIBRT AND HAVE_LIBUSB)
    if (LIBUSBDIR)
 	set (libusb_link "imp_libusb")
@@ -726,6 +736,22 @@
 
 #--------------------------------------------------------------------------------
 
+if (NOT OSCamOperatingSystem MATCHES "Mac OS X")
+if (NOT DEFINED ENV{ANDROID_NDK})
+if (NOT DEFINED ENV{ANDROID_STANDALONE_TOOLCHAIN})
+  if(WITH_EMU)
+	if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/SoftCam.Key)
+ 		execute_process(COMMAND cp ${CMAKE_CURRENT_SOURCE_DIR}/SoftCam.Key ${CMAKE_CURRENT_BINARY_DIR}/SoftCam.Key)
+	else(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/SoftCam.Key)
+		execute_process(COMMAND touch ${CMAKE_CURRENT_BINARY_DIR}/SoftCam.Key)
+	endif(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/SoftCam.Key)
+	execute_process(COMMAND touch ${CMAKE_CURRENT_BINARY_DIR}/utils/SoftCam.Key)
+	set (CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,--format=binary -Wl,SoftCam.Key -Wl,--format=default" ) 
+ endif(WITH_EMU)
+endif (NOT DEFINED ENV{ANDROID_STANDALONE_TOOLCHAIN})
+endif (NOT DEFINED ENV{ANDROID_NDK})
+endif (NOT OSCamOperatingSystem MATCHES "Mac OS X")
+
 #----------------------- installation -----------------------------
 
 file (GLOB config_files "${CMAKE_CURRENT_SOURCE_DIR}/Distribution/oscam.*")
@@ -814,4 +840,8 @@
  endif(STATICLIBUSB AND NOT LIBUSBDIR)
 endif (HAVE_LIBUSB)
 
+if (WITH_EMU)
+	message(STATUS "  Compile with EMU support")
+endif (WITH_EMU)
+
 message (STATUS "")
diff -ruN oscam-emu-2015-12-03-11142.orig/config.h oscam-emu-2015-12-03-11142/config.h
--- oscam-emu-2015-12-03-11142.orig/config.h	2015-12-12 00:38:39.166685870 +0300
+++ oscam-emu-2015-12-03-11142/config.h	2015-12-04 00:43:30.000000000 +0300
@@ -1,6 +1,7 @@
 #ifndef CONFIG_H_
 #define CONFIG_H_
 
+#define WITH_EMU 1
 #define WEBIF 1
 #define WEBIF_LIVELOG 1
 #define WEBIF_JQUERY 1
diff -ruN oscam-emu-2015-12-03-11142.orig/config.sh oscam-emu-2015-12-03-11142/config.sh
--- oscam-emu-2015-12-03-11142.orig/config.sh	2015-10-01 00:11:35.000000000 +0300
+++ oscam-emu-2015-12-03-11142/config.sh	2015-12-04 00:43:30.000000000 +0300
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-addons="WEBIF WEBIF_LIVELOG WEBIF_JQUERY TOUCH WITH_SSL HAVE_DVBAPI READ_SDT_CHARSETS IRDETO_GUESSING CS_ANTICASC WITH_DEBUG MODULE_MONITOR WITH_LB CS_CACHEEX CW_CYCLE_CHECK LCDSUPPORT LEDSUPPORT CLOCKFIX IPV6SUPPORT"
+addons="WEBIF WEBIF_LIVELOG WEBIF_JQUERY TOUCH WITH_SSL HAVE_DVBAPI READ_SDT_CHARSETS IRDETO_GUESSING CS_ANTICASC WITH_DEBUG MODULE_MONITOR WITH_LB CS_CACHEEX CW_CYCLE_CHECK LCDSUPPORT LEDSUPPORT CLOCKFIX IPV6SUPPORT WITH_EMU"
 protocols="MODULE_CAMD33 MODULE_CAMD35 MODULE_CAMD35_TCP MODULE_NEWCAMD MODULE_CCCAM MODULE_CCCSHARE MODULE_GBOX MODULE_RADEGAST MODULE_SCAM MODULE_SERIAL MODULE_CONSTCW MODULE_PANDORA MODULE_GHTTP"
 readers="READER_NAGRA READER_IRDETO READER_CONAX READER_CRYPTOWORKS READER_SECA READER_VIACCESS READER_VIDEOGUARD READER_DRE READER_TONGFANG READER_BULCRYPT READER_GRIFFIN READER_DGCRYPT"
 card_readers="CARDREADER_PHOENIX CARDREADER_INTERNAL CARDREADER_SC8IN1 CARDREADER_MP35 CARDREADER_SMARGO CARDREADER_DB2COM CARDREADER_STAPI CARDREADER_STAPI5 CARDREADER_STINGER"
@@ -24,6 +24,7 @@
 # CONFIG_LEDSUPPORT=n
 CONFIG_CLOCKFIX=y
 # CONFIG_IPV6SUPPORT=n
+CONFIG_WITH_EMU=y
 # CONFIG_MODULE_CAMD33=n
 CONFIG_MODULE_CAMD35=y
 CONFIG_MODULE_CAMD35_TCP=y
@@ -288,12 +289,14 @@
 
 update_deps() {
 	# Calculate dependencies
-	enabled_any $(get_opts readers) $(get_opts card_readers) && enable_opt WITH_CARDREADER >/dev/null
-	disabled_all $(get_opts readers) $(get_opts card_readers) && disable_opt WITH_CARDREADER >/dev/null
+	enabled_any $(get_opts readers) $(get_opts card_readers) WITH_EMU && enable_opt WITH_CARDREADER >/dev/null
+	disabled_all $(get_opts readers) $(get_opts card_readers) WITH_EMU && disable_opt WITH_CARDREADER >/dev/null
 	disabled WEBIF && disable_opt WEBIF_LIVELOG >/dev/null
 	disabled WEBIF && disable_opt WEBIF_JQUERY >/dev/null
 	enabled MODULE_CCCSHARE && enable_opt MODULE_CCCAM >/dev/null
 	enabled_any CARDREADER_DB2COM CARDREADER_MP35 CARDREADER_SC8IN1 CARDREADER_STINGER && enable_opt CARDREADER_PHOENIX >/dev/null
+	enabled WITH_EMU && enable_opt READER_VIACCESS >/dev/null
+	enabled WITH_EMU && enable_opt MODULE_NEWCAMD >/dev/null
 }
 
 list_config() {
@@ -343,9 +346,9 @@
 	not_have_flag USE_LIBCRYPTO && echo "CONFIG_LIB_AES=y" || echo "# CONFIG_LIB_AES=n"
 	enabled MODULE_CCCAM && echo "CONFIG_LIB_RC6=y" || echo "# CONFIG_LIB_RC6=n"
 	not_have_flag USE_LIBCRYPTO && enabled MODULE_CCCAM && echo "CONFIG_LIB_SHA1=y" || echo "# CONFIG_LIB_SHA1=n"
-	enabled_any READER_DRE MODULE_SCAM READER_VIACCESS && echo "CONFIG_LIB_DES=y" || echo "# CONFIG_LIB_DES=n"
-	enabled_any MODULE_CCCAM READER_NAGRA READER_SECA && echo "CONFIG_LIB_IDEA=y" || echo "# CONFIG_LIB_IDEA=n"
-	not_have_flag USE_LIBCRYPTO && enabled_any READER_CONAX READER_CRYPTOWORKS READER_NAGRA && echo "CONFIG_LIB_BIGNUM=y" || echo "# CONFIG_LIB_BIGNUM=n"
+	enabled_any READER_DRE MODULE_SCAM WITH_EMU && echo "CONFIG_LIB_DES=y" || echo "# CONFIG_LIB_DES=n"
+	enabled_any MODULE_CCCAM READER_NAGRA READER_SECA WITH_EMU && echo "CONFIG_LIB_IDEA=y" || echo "# CONFIG_LIB_IDEA=n"
+	not_have_flag USE_LIBCRYPTO && enabled_any READER_CONAX READER_CRYPTOWORKS READER_NAGRA WITH_EMU && echo "CONFIG_LIB_BIGNUM=y" || echo "# CONFIG_LIB_BIGNUM=n"
 }
 
 make_config_c() {
@@ -456,6 +459,7 @@
 		LEDSUPPORT			"LED support"							$(check_test "LEDSUPPORT") \
 		CLOCKFIX			"Clockfix (disable on old systems!)"	$(check_test "CLOCKFIX") \
 		IPV6SUPPORT			"IPv6 support (experimental)"			$(check_test "IPV6SUPPORT") \
+		WITH_EMU			"Emulator support"						$(check_test "WITH_EMU") \
 		2> ${tempfile}
 
 	opt=${?}
diff -ruN oscam-emu-2015-12-03-11142.orig/cscrypt/md5.c oscam-emu-2015-12-03-11142/cscrypt/md5.c
--- oscam-emu-2015-12-03-11142.orig/cscrypt/md5.c	2014-10-23 20:22:41.000000000 +0400
+++ oscam-emu-2015-12-03-11142/cscrypt/md5.c	2015-12-04 00:43:30.000000000 +0300
@@ -25,13 +25,6 @@
 
 #if !defined(WITH_SSL) && !defined(WITH_LIBCRYPTO)
 
-typedef struct MD5Context
-{
-	uint32_t buf[4];
-	uint32_t bits[2];
-	uint32_t in[16];
-} MD5_CTX;
-
 #ifdef __i386__
 #define byteReverse(a, b)
 #else
@@ -155,7 +148,7 @@
  * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
  * initialization constants.
  */
-static void MD5_Init(MD5_CTX *ctx)
+void MD5_Init(MD5_CTX *ctx)
 {
 	ctx->buf[0] = 0x67452301;
 	ctx->buf[1] = 0xefcdab89;
@@ -170,7 +163,7 @@
  * Update context to reflect the concatenation of another buffer full
  * of bytes.
  */
-static void MD5_Update(MD5_CTX *ctx, const unsigned char *buf, unsigned int len)
+void MD5_Update(MD5_CTX *ctx, const unsigned char *buf, unsigned int len)
 {
 	uint32_t t;
 
@@ -219,7 +212,7 @@
  * Final wrapup - pad to 64-byte boundary with the bit pattern
  * 1 0* (64-bit count of bits processed, MSB-first)
  */
-static void MD5_Final(unsigned char digest[MD5_DIGEST_LENGTH], MD5_CTX *ctx)
+void MD5_Final(unsigned char digest[MD5_DIGEST_LENGTH], MD5_CTX *ctx)
 {
 	unsigned count;
 	unsigned char *p;
diff -ruN oscam-emu-2015-12-03-11142.orig/cscrypt/md5.h oscam-emu-2015-12-03-11142/cscrypt/md5.h
--- oscam-emu-2015-12-03-11142.orig/cscrypt/md5.h	2013-10-03 08:04:08.000000000 +0400
+++ oscam-emu-2015-12-03-11142/cscrypt/md5.h	2015-12-04 00:43:30.000000000 +0300
@@ -7,8 +7,16 @@
 #define MD5_DIGEST_LENGTH 16
 
 unsigned char *MD5(const unsigned char *input, unsigned long len, unsigned char *output_hash);
-#endif
 
-char *__md5_crypt(const char *text_pass, const char *salt, char *crypted_passwd);
+typedef struct MD5Context {
+	uint32_t buf[4];
+	uint32_t bits[2];
+	uint32_t in[16];
+} MD5_CTX;
 
+void MD5_Init(MD5_CTX *ctx);
+void MD5_Update(MD5_CTX *ctx, const unsigned char *buf, unsigned int len);
+void MD5_Final(unsigned char digest[MD5_DIGEST_LENGTH], MD5_CTX *ctx);
+#endif
+char *__md5_crypt(const char *text_pass, const char *salt, char *crypted_passwd);
 #endif
diff -ruN oscam-emu-2015-12-03-11142.orig/csctapi/cardreaders.h oscam-emu-2015-12-03-11142/csctapi/cardreaders.h
--- oscam-emu-2015-12-03-11142.orig/csctapi/cardreaders.h	2015-02-22 07:08:03.000000000 +0300
+++ oscam-emu-2015-12-03-11142/csctapi/cardreaders.h	2015-12-04 00:43:30.000000000 +0300
@@ -13,5 +13,6 @@
 extern const struct s_cardreader cardreader_smartreader;
 extern const struct s_cardreader cardreader_stapi;
 extern const struct s_cardreader cardreader_stinger;
+extern const struct s_cardreader cardreader_emu;
 
 #endif
diff -ruN oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/aes_core.c oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/aes_core.c
--- oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/aes_core.c	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/aes_core.c	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,1206 @@
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include "aes.h"
+
+static const u32 Te0[256] = {
+    0xc66363a5U, 0xf87c7c84U, 0xee777799U, 0xf67b7b8dU,
+    0xfff2f20dU, 0xd66b6bbdU, 0xde6f6fb1U, 0x91c5c554U,
+    0x60303050U, 0x02010103U, 0xce6767a9U, 0x562b2b7dU,
+    0xe7fefe19U, 0xb5d7d762U, 0x4dababe6U, 0xec76769aU,
+    0x8fcaca45U, 0x1f82829dU, 0x89c9c940U, 0xfa7d7d87U,
+    0xeffafa15U, 0xb25959ebU, 0x8e4747c9U, 0xfbf0f00bU,
+    0x41adadecU, 0xb3d4d467U, 0x5fa2a2fdU, 0x45afafeaU,
+    0x239c9cbfU, 0x53a4a4f7U, 0xe4727296U, 0x9bc0c05bU,
+    0x75b7b7c2U, 0xe1fdfd1cU, 0x3d9393aeU, 0x4c26266aU,
+    0x6c36365aU, 0x7e3f3f41U, 0xf5f7f702U, 0x83cccc4fU,
+    0x6834345cU, 0x51a5a5f4U, 0xd1e5e534U, 0xf9f1f108U,
+    0xe2717193U, 0xabd8d873U, 0x62313153U, 0x2a15153fU,
+    0x0804040cU, 0x95c7c752U, 0x46232365U, 0x9dc3c35eU,
+    0x30181828U, 0x379696a1U, 0x0a05050fU, 0x2f9a9ab5U,
+    0x0e070709U, 0x24121236U, 0x1b80809bU, 0xdfe2e23dU,
+    0xcdebeb26U, 0x4e272769U, 0x7fb2b2cdU, 0xea75759fU,
+    0x1209091bU, 0x1d83839eU, 0x582c2c74U, 0x341a1a2eU,
+    0x361b1b2dU, 0xdc6e6eb2U, 0xb45a5aeeU, 0x5ba0a0fbU,
+    0xa45252f6U, 0x763b3b4dU, 0xb7d6d661U, 0x7db3b3ceU,
+    0x5229297bU, 0xdde3e33eU, 0x5e2f2f71U, 0x13848497U,
+    0xa65353f5U, 0xb9d1d168U, 0x00000000U, 0xc1eded2cU,
+    0x40202060U, 0xe3fcfc1fU, 0x79b1b1c8U, 0xb65b5bedU,
+    0xd46a6abeU, 0x8dcbcb46U, 0x67bebed9U, 0x7239394bU,
+    0x944a4adeU, 0x984c4cd4U, 0xb05858e8U, 0x85cfcf4aU,
+    0xbbd0d06bU, 0xc5efef2aU, 0x4faaaae5U, 0xedfbfb16U,
+    0x864343c5U, 0x9a4d4dd7U, 0x66333355U, 0x11858594U,
+    0x8a4545cfU, 0xe9f9f910U, 0x04020206U, 0xfe7f7f81U,
+    0xa05050f0U, 0x783c3c44U, 0x259f9fbaU, 0x4ba8a8e3U,
+    0xa25151f3U, 0x5da3a3feU, 0x804040c0U, 0x058f8f8aU,
+    0x3f9292adU, 0x219d9dbcU, 0x70383848U, 0xf1f5f504U,
+    0x63bcbcdfU, 0x77b6b6c1U, 0xafdada75U, 0x42212163U,
+    0x20101030U, 0xe5ffff1aU, 0xfdf3f30eU, 0xbfd2d26dU,
+    0x81cdcd4cU, 0x180c0c14U, 0x26131335U, 0xc3ecec2fU,
+    0xbe5f5fe1U, 0x359797a2U, 0x884444ccU, 0x2e171739U,
+    0x93c4c457U, 0x55a7a7f2U, 0xfc7e7e82U, 0x7a3d3d47U,
+    0xc86464acU, 0xba5d5de7U, 0x3219192bU, 0xe6737395U,
+    0xc06060a0U, 0x19818198U, 0x9e4f4fd1U, 0xa3dcdc7fU,
+    0x44222266U, 0x542a2a7eU, 0x3b9090abU, 0x0b888883U,
+    0x8c4646caU, 0xc7eeee29U, 0x6bb8b8d3U, 0x2814143cU,
+    0xa7dede79U, 0xbc5e5ee2U, 0x160b0b1dU, 0xaddbdb76U,
+    0xdbe0e03bU, 0x64323256U, 0x743a3a4eU, 0x140a0a1eU,
+    0x924949dbU, 0x0c06060aU, 0x4824246cU, 0xb85c5ce4U,
+    0x9fc2c25dU, 0xbdd3d36eU, 0x43acacefU, 0xc46262a6U,
+    0x399191a8U, 0x319595a4U, 0xd3e4e437U, 0xf279798bU,
+    0xd5e7e732U, 0x8bc8c843U, 0x6e373759U, 0xda6d6db7U,
+    0x018d8d8cU, 0xb1d5d564U, 0x9c4e4ed2U, 0x49a9a9e0U,
+    0xd86c6cb4U, 0xac5656faU, 0xf3f4f407U, 0xcfeaea25U,
+    0xca6565afU, 0xf47a7a8eU, 0x47aeaee9U, 0x10080818U,
+    0x6fbabad5U, 0xf0787888U, 0x4a25256fU, 0x5c2e2e72U,
+    0x381c1c24U, 0x57a6a6f1U, 0x73b4b4c7U, 0x97c6c651U,
+    0xcbe8e823U, 0xa1dddd7cU, 0xe874749cU, 0x3e1f1f21U,
+    0x964b4bddU, 0x61bdbddcU, 0x0d8b8b86U, 0x0f8a8a85U,
+    0xe0707090U, 0x7c3e3e42U, 0x71b5b5c4U, 0xcc6666aaU,
+    0x904848d8U, 0x06030305U, 0xf7f6f601U, 0x1c0e0e12U,
+    0xc26161a3U, 0x6a35355fU, 0xae5757f9U, 0x69b9b9d0U,
+    0x17868691U, 0x99c1c158U, 0x3a1d1d27U, 0x279e9eb9U,
+    0xd9e1e138U, 0xebf8f813U, 0x2b9898b3U, 0x22111133U,
+    0xd26969bbU, 0xa9d9d970U, 0x078e8e89U, 0x339494a7U,
+    0x2d9b9bb6U, 0x3c1e1e22U, 0x15878792U, 0xc9e9e920U,
+    0x87cece49U, 0xaa5555ffU, 0x50282878U, 0xa5dfdf7aU,
+    0x038c8c8fU, 0x59a1a1f8U, 0x09898980U, 0x1a0d0d17U,
+    0x65bfbfdaU, 0xd7e6e631U, 0x844242c6U, 0xd06868b8U,
+    0x824141c3U, 0x299999b0U, 0x5a2d2d77U, 0x1e0f0f11U,
+    0x7bb0b0cbU, 0xa85454fcU, 0x6dbbbbd6U, 0x2c16163aU,
+};
+static const u32 Te1[256] = {
+    0xa5c66363U, 0x84f87c7cU, 0x99ee7777U, 0x8df67b7bU,
+    0x0dfff2f2U, 0xbdd66b6bU, 0xb1de6f6fU, 0x5491c5c5U,
+    0x50603030U, 0x03020101U, 0xa9ce6767U, 0x7d562b2bU,
+    0x19e7fefeU, 0x62b5d7d7U, 0xe64dababU, 0x9aec7676U,
+    0x458fcacaU, 0x9d1f8282U, 0x4089c9c9U, 0x87fa7d7dU,
+    0x15effafaU, 0xebb25959U, 0xc98e4747U, 0x0bfbf0f0U,
+    0xec41adadU, 0x67b3d4d4U, 0xfd5fa2a2U, 0xea45afafU,
+    0xbf239c9cU, 0xf753a4a4U, 0x96e47272U, 0x5b9bc0c0U,
+    0xc275b7b7U, 0x1ce1fdfdU, 0xae3d9393U, 0x6a4c2626U,
+    0x5a6c3636U, 0x417e3f3fU, 0x02f5f7f7U, 0x4f83ccccU,
+    0x5c683434U, 0xf451a5a5U, 0x34d1e5e5U, 0x08f9f1f1U,
+    0x93e27171U, 0x73abd8d8U, 0x53623131U, 0x3f2a1515U,
+    0x0c080404U, 0x5295c7c7U, 0x65462323U, 0x5e9dc3c3U,
+    0x28301818U, 0xa1379696U, 0x0f0a0505U, 0xb52f9a9aU,
+    0x090e0707U, 0x36241212U, 0x9b1b8080U, 0x3ddfe2e2U,
+    0x26cdebebU, 0x694e2727U, 0xcd7fb2b2U, 0x9fea7575U,
+    0x1b120909U, 0x9e1d8383U, 0x74582c2cU, 0x2e341a1aU,
+    0x2d361b1bU, 0xb2dc6e6eU, 0xeeb45a5aU, 0xfb5ba0a0U,
+    0xf6a45252U, 0x4d763b3bU, 0x61b7d6d6U, 0xce7db3b3U,
+    0x7b522929U, 0x3edde3e3U, 0x715e2f2fU, 0x97138484U,
+    0xf5a65353U, 0x68b9d1d1U, 0x00000000U, 0x2cc1ededU,
+    0x60402020U, 0x1fe3fcfcU, 0xc879b1b1U, 0xedb65b5bU,
+    0xbed46a6aU, 0x468dcbcbU, 0xd967bebeU, 0x4b723939U,
+    0xde944a4aU, 0xd4984c4cU, 0xe8b05858U, 0x4a85cfcfU,
+    0x6bbbd0d0U, 0x2ac5efefU, 0xe54faaaaU, 0x16edfbfbU,
+    0xc5864343U, 0xd79a4d4dU, 0x55663333U, 0x94118585U,
+    0xcf8a4545U, 0x10e9f9f9U, 0x06040202U, 0x81fe7f7fU,
+    0xf0a05050U, 0x44783c3cU, 0xba259f9fU, 0xe34ba8a8U,
+    0xf3a25151U, 0xfe5da3a3U, 0xc0804040U, 0x8a058f8fU,
+    0xad3f9292U, 0xbc219d9dU, 0x48703838U, 0x04f1f5f5U,
+    0xdf63bcbcU, 0xc177b6b6U, 0x75afdadaU, 0x63422121U,
+    0x30201010U, 0x1ae5ffffU, 0x0efdf3f3U, 0x6dbfd2d2U,
+    0x4c81cdcdU, 0x14180c0cU, 0x35261313U, 0x2fc3ececU,
+    0xe1be5f5fU, 0xa2359797U, 0xcc884444U, 0x392e1717U,
+    0x5793c4c4U, 0xf255a7a7U, 0x82fc7e7eU, 0x477a3d3dU,
+    0xacc86464U, 0xe7ba5d5dU, 0x2b321919U, 0x95e67373U,
+    0xa0c06060U, 0x98198181U, 0xd19e4f4fU, 0x7fa3dcdcU,
+    0x66442222U, 0x7e542a2aU, 0xab3b9090U, 0x830b8888U,
+    0xca8c4646U, 0x29c7eeeeU, 0xd36bb8b8U, 0x3c281414U,
+    0x79a7dedeU, 0xe2bc5e5eU, 0x1d160b0bU, 0x76addbdbU,
+    0x3bdbe0e0U, 0x56643232U, 0x4e743a3aU, 0x1e140a0aU,
+    0xdb924949U, 0x0a0c0606U, 0x6c482424U, 0xe4b85c5cU,
+    0x5d9fc2c2U, 0x6ebdd3d3U, 0xef43acacU, 0xa6c46262U,
+    0xa8399191U, 0xa4319595U, 0x37d3e4e4U, 0x8bf27979U,
+    0x32d5e7e7U, 0x438bc8c8U, 0x596e3737U, 0xb7da6d6dU,
+    0x8c018d8dU, 0x64b1d5d5U, 0xd29c4e4eU, 0xe049a9a9U,
+    0xb4d86c6cU, 0xfaac5656U, 0x07f3f4f4U, 0x25cfeaeaU,
+    0xafca6565U, 0x8ef47a7aU, 0xe947aeaeU, 0x18100808U,
+    0xd56fbabaU, 0x88f07878U, 0x6f4a2525U, 0x725c2e2eU,
+    0x24381c1cU, 0xf157a6a6U, 0xc773b4b4U, 0x5197c6c6U,
+    0x23cbe8e8U, 0x7ca1ddddU, 0x9ce87474U, 0x213e1f1fU,
+    0xdd964b4bU, 0xdc61bdbdU, 0x860d8b8bU, 0x850f8a8aU,
+    0x90e07070U, 0x427c3e3eU, 0xc471b5b5U, 0xaacc6666U,
+    0xd8904848U, 0x05060303U, 0x01f7f6f6U, 0x121c0e0eU,
+    0xa3c26161U, 0x5f6a3535U, 0xf9ae5757U, 0xd069b9b9U,
+    0x91178686U, 0x5899c1c1U, 0x273a1d1dU, 0xb9279e9eU,
+    0x38d9e1e1U, 0x13ebf8f8U, 0xb32b9898U, 0x33221111U,
+    0xbbd26969U, 0x70a9d9d9U, 0x89078e8eU, 0xa7339494U,
+    0xb62d9b9bU, 0x223c1e1eU, 0x92158787U, 0x20c9e9e9U,
+    0x4987ceceU, 0xffaa5555U, 0x78502828U, 0x7aa5dfdfU,
+    0x8f038c8cU, 0xf859a1a1U, 0x80098989U, 0x171a0d0dU,
+    0xda65bfbfU, 0x31d7e6e6U, 0xc6844242U, 0xb8d06868U,
+    0xc3824141U, 0xb0299999U, 0x775a2d2dU, 0x111e0f0fU,
+    0xcb7bb0b0U, 0xfca85454U, 0xd66dbbbbU, 0x3a2c1616U,
+};
+static const u32 Te2[256] = {
+    0x63a5c663U, 0x7c84f87cU, 0x7799ee77U, 0x7b8df67bU,
+    0xf20dfff2U, 0x6bbdd66bU, 0x6fb1de6fU, 0xc55491c5U,
+    0x30506030U, 0x01030201U, 0x67a9ce67U, 0x2b7d562bU,
+    0xfe19e7feU, 0xd762b5d7U, 0xabe64dabU, 0x769aec76U,
+    0xca458fcaU, 0x829d1f82U, 0xc94089c9U, 0x7d87fa7dU,
+    0xfa15effaU, 0x59ebb259U, 0x47c98e47U, 0xf00bfbf0U,
+    0xadec41adU, 0xd467b3d4U, 0xa2fd5fa2U, 0xafea45afU,
+    0x9cbf239cU, 0xa4f753a4U, 0x7296e472U, 0xc05b9bc0U,
+    0xb7c275b7U, 0xfd1ce1fdU, 0x93ae3d93U, 0x266a4c26U,
+    0x365a6c36U, 0x3f417e3fU, 0xf702f5f7U, 0xcc4f83ccU,
+    0x345c6834U, 0xa5f451a5U, 0xe534d1e5U, 0xf108f9f1U,
+    0x7193e271U, 0xd873abd8U, 0x31536231U, 0x153f2a15U,
+    0x040c0804U, 0xc75295c7U, 0x23654623U, 0xc35e9dc3U,
+    0x18283018U, 0x96a13796U, 0x050f0a05U, 0x9ab52f9aU,
+    0x07090e07U, 0x12362412U, 0x809b1b80U, 0xe23ddfe2U,
+    0xeb26cdebU, 0x27694e27U, 0xb2cd7fb2U, 0x759fea75U,
+    0x091b1209U, 0x839e1d83U, 0x2c74582cU, 0x1a2e341aU,
+    0x1b2d361bU, 0x6eb2dc6eU, 0x5aeeb45aU, 0xa0fb5ba0U,
+    0x52f6a452U, 0x3b4d763bU, 0xd661b7d6U, 0xb3ce7db3U,
+    0x297b5229U, 0xe33edde3U, 0x2f715e2fU, 0x84971384U,
+    0x53f5a653U, 0xd168b9d1U, 0x00000000U, 0xed2cc1edU,
+    0x20604020U, 0xfc1fe3fcU, 0xb1c879b1U, 0x5bedb65bU,
+    0x6abed46aU, 0xcb468dcbU, 0xbed967beU, 0x394b7239U,
+    0x4ade944aU, 0x4cd4984cU, 0x58e8b058U, 0xcf4a85cfU,
+    0xd06bbbd0U, 0xef2ac5efU, 0xaae54faaU, 0xfb16edfbU,
+    0x43c58643U, 0x4dd79a4dU, 0x33556633U, 0x85941185U,
+    0x45cf8a45U, 0xf910e9f9U, 0x02060402U, 0x7f81fe7fU,
+    0x50f0a050U, 0x3c44783cU, 0x9fba259fU, 0xa8e34ba8U,
+    0x51f3a251U, 0xa3fe5da3U, 0x40c08040U, 0x8f8a058fU,
+    0x92ad3f92U, 0x9dbc219dU, 0x38487038U, 0xf504f1f5U,
+    0xbcdf63bcU, 0xb6c177b6U, 0xda75afdaU, 0x21634221U,
+    0x10302010U, 0xff1ae5ffU, 0xf30efdf3U, 0xd26dbfd2U,
+    0xcd4c81cdU, 0x0c14180cU, 0x13352613U, 0xec2fc3ecU,
+    0x5fe1be5fU, 0x97a23597U, 0x44cc8844U, 0x17392e17U,
+    0xc45793c4U, 0xa7f255a7U, 0x7e82fc7eU, 0x3d477a3dU,
+    0x64acc864U, 0x5de7ba5dU, 0x192b3219U, 0x7395e673U,
+    0x60a0c060U, 0x81981981U, 0x4fd19e4fU, 0xdc7fa3dcU,
+    0x22664422U, 0x2a7e542aU, 0x90ab3b90U, 0x88830b88U,
+    0x46ca8c46U, 0xee29c7eeU, 0xb8d36bb8U, 0x143c2814U,
+    0xde79a7deU, 0x5ee2bc5eU, 0x0b1d160bU, 0xdb76addbU,
+    0xe03bdbe0U, 0x32566432U, 0x3a4e743aU, 0x0a1e140aU,
+    0x49db9249U, 0x060a0c06U, 0x246c4824U, 0x5ce4b85cU,
+    0xc25d9fc2U, 0xd36ebdd3U, 0xacef43acU, 0x62a6c462U,
+    0x91a83991U, 0x95a43195U, 0xe437d3e4U, 0x798bf279U,
+    0xe732d5e7U, 0xc8438bc8U, 0x37596e37U, 0x6db7da6dU,
+    0x8d8c018dU, 0xd564b1d5U, 0x4ed29c4eU, 0xa9e049a9U,
+    0x6cb4d86cU, 0x56faac56U, 0xf407f3f4U, 0xea25cfeaU,
+    0x65afca65U, 0x7a8ef47aU, 0xaee947aeU, 0x08181008U,
+    0xbad56fbaU, 0x7888f078U, 0x256f4a25U, 0x2e725c2eU,
+    0x1c24381cU, 0xa6f157a6U, 0xb4c773b4U, 0xc65197c6U,
+    0xe823cbe8U, 0xdd7ca1ddU, 0x749ce874U, 0x1f213e1fU,
+    0x4bdd964bU, 0xbddc61bdU, 0x8b860d8bU, 0x8a850f8aU,
+    0x7090e070U, 0x3e427c3eU, 0xb5c471b5U, 0x66aacc66U,
+    0x48d89048U, 0x03050603U, 0xf601f7f6U, 0x0e121c0eU,
+    0x61a3c261U, 0x355f6a35U, 0x57f9ae57U, 0xb9d069b9U,
+    0x86911786U, 0xc15899c1U, 0x1d273a1dU, 0x9eb9279eU,
+    0xe138d9e1U, 0xf813ebf8U, 0x98b32b98U, 0x11332211U,
+    0x69bbd269U, 0xd970a9d9U, 0x8e89078eU, 0x94a73394U,
+    0x9bb62d9bU, 0x1e223c1eU, 0x87921587U, 0xe920c9e9U,
+    0xce4987ceU, 0x55ffaa55U, 0x28785028U, 0xdf7aa5dfU,
+    0x8c8f038cU, 0xa1f859a1U, 0x89800989U, 0x0d171a0dU,
+    0xbfda65bfU, 0xe631d7e6U, 0x42c68442U, 0x68b8d068U,
+    0x41c38241U, 0x99b02999U, 0x2d775a2dU, 0x0f111e0fU,
+    0xb0cb7bb0U, 0x54fca854U, 0xbbd66dbbU, 0x163a2c16U,
+};
+static const u32 Te3[256] = {
+
+    0x6363a5c6U, 0x7c7c84f8U, 0x777799eeU, 0x7b7b8df6U,
+    0xf2f20dffU, 0x6b6bbdd6U, 0x6f6fb1deU, 0xc5c55491U,
+    0x30305060U, 0x01010302U, 0x6767a9ceU, 0x2b2b7d56U,
+    0xfefe19e7U, 0xd7d762b5U, 0xababe64dU, 0x76769aecU,
+    0xcaca458fU, 0x82829d1fU, 0xc9c94089U, 0x7d7d87faU,
+    0xfafa15efU, 0x5959ebb2U, 0x4747c98eU, 0xf0f00bfbU,
+    0xadadec41U, 0xd4d467b3U, 0xa2a2fd5fU, 0xafafea45U,
+    0x9c9cbf23U, 0xa4a4f753U, 0x727296e4U, 0xc0c05b9bU,
+    0xb7b7c275U, 0xfdfd1ce1U, 0x9393ae3dU, 0x26266a4cU,
+    0x36365a6cU, 0x3f3f417eU, 0xf7f702f5U, 0xcccc4f83U,
+    0x34345c68U, 0xa5a5f451U, 0xe5e534d1U, 0xf1f108f9U,
+    0x717193e2U, 0xd8d873abU, 0x31315362U, 0x15153f2aU,
+    0x04040c08U, 0xc7c75295U, 0x23236546U, 0xc3c35e9dU,
+    0x18182830U, 0x9696a137U, 0x05050f0aU, 0x9a9ab52fU,
+    0x0707090eU, 0x12123624U, 0x80809b1bU, 0xe2e23ddfU,
+    0xebeb26cdU, 0x2727694eU, 0xb2b2cd7fU, 0x75759feaU,
+    0x09091b12U, 0x83839e1dU, 0x2c2c7458U, 0x1a1a2e34U,
+    0x1b1b2d36U, 0x6e6eb2dcU, 0x5a5aeeb4U, 0xa0a0fb5bU,
+    0x5252f6a4U, 0x3b3b4d76U, 0xd6d661b7U, 0xb3b3ce7dU,
+    0x29297b52U, 0xe3e33eddU, 0x2f2f715eU, 0x84849713U,
+    0x5353f5a6U, 0xd1d168b9U, 0x00000000U, 0xeded2cc1U,
+    0x20206040U, 0xfcfc1fe3U, 0xb1b1c879U, 0x5b5bedb6U,
+    0x6a6abed4U, 0xcbcb468dU, 0xbebed967U, 0x39394b72U,
+    0x4a4ade94U, 0x4c4cd498U, 0x5858e8b0U, 0xcfcf4a85U,
+    0xd0d06bbbU, 0xefef2ac5U, 0xaaaae54fU, 0xfbfb16edU,
+    0x4343c586U, 0x4d4dd79aU, 0x33335566U, 0x85859411U,
+    0x4545cf8aU, 0xf9f910e9U, 0x02020604U, 0x7f7f81feU,
+    0x5050f0a0U, 0x3c3c4478U, 0x9f9fba25U, 0xa8a8e34bU,
+    0x5151f3a2U, 0xa3a3fe5dU, 0x4040c080U, 0x8f8f8a05U,
+    0x9292ad3fU, 0x9d9dbc21U, 0x38384870U, 0xf5f504f1U,
+    0xbcbcdf63U, 0xb6b6c177U, 0xdada75afU, 0x21216342U,
+    0x10103020U, 0xffff1ae5U, 0xf3f30efdU, 0xd2d26dbfU,
+    0xcdcd4c81U, 0x0c0c1418U, 0x13133526U, 0xecec2fc3U,
+    0x5f5fe1beU, 0x9797a235U, 0x4444cc88U, 0x1717392eU,
+    0xc4c45793U, 0xa7a7f255U, 0x7e7e82fcU, 0x3d3d477aU,
+    0x6464acc8U, 0x5d5de7baU, 0x19192b32U, 0x737395e6U,
+    0x6060a0c0U, 0x81819819U, 0x4f4fd19eU, 0xdcdc7fa3U,
+    0x22226644U, 0x2a2a7e54U, 0x9090ab3bU, 0x8888830bU,
+    0x4646ca8cU, 0xeeee29c7U, 0xb8b8d36bU, 0x14143c28U,
+    0xdede79a7U, 0x5e5ee2bcU, 0x0b0b1d16U, 0xdbdb76adU,
+    0xe0e03bdbU, 0x32325664U, 0x3a3a4e74U, 0x0a0a1e14U,
+    0x4949db92U, 0x06060a0cU, 0x24246c48U, 0x5c5ce4b8U,
+    0xc2c25d9fU, 0xd3d36ebdU, 0xacacef43U, 0x6262a6c4U,
+    0x9191a839U, 0x9595a431U, 0xe4e437d3U, 0x79798bf2U,
+    0xe7e732d5U, 0xc8c8438bU, 0x3737596eU, 0x6d6db7daU,
+    0x8d8d8c01U, 0xd5d564b1U, 0x4e4ed29cU, 0xa9a9e049U,
+    0x6c6cb4d8U, 0x5656faacU, 0xf4f407f3U, 0xeaea25cfU,
+    0x6565afcaU, 0x7a7a8ef4U, 0xaeaee947U, 0x08081810U,
+    0xbabad56fU, 0x787888f0U, 0x25256f4aU, 0x2e2e725cU,
+    0x1c1c2438U, 0xa6a6f157U, 0xb4b4c773U, 0xc6c65197U,
+    0xe8e823cbU, 0xdddd7ca1U, 0x74749ce8U, 0x1f1f213eU,
+    0x4b4bdd96U, 0xbdbddc61U, 0x8b8b860dU, 0x8a8a850fU,
+    0x707090e0U, 0x3e3e427cU, 0xb5b5c471U, 0x6666aaccU,
+    0x4848d890U, 0x03030506U, 0xf6f601f7U, 0x0e0e121cU,
+    0x6161a3c2U, 0x35355f6aU, 0x5757f9aeU, 0xb9b9d069U,
+    0x86869117U, 0xc1c15899U, 0x1d1d273aU, 0x9e9eb927U,
+    0xe1e138d9U, 0xf8f813ebU, 0x9898b32bU, 0x11113322U,
+    0x6969bbd2U, 0xd9d970a9U, 0x8e8e8907U, 0x9494a733U,
+    0x9b9bb62dU, 0x1e1e223cU, 0x87879215U, 0xe9e920c9U,
+    0xcece4987U, 0x5555ffaaU, 0x28287850U, 0xdfdf7aa5U,
+    0x8c8c8f03U, 0xa1a1f859U, 0x89898009U, 0x0d0d171aU,
+    0xbfbfda65U, 0xe6e631d7U, 0x4242c684U, 0x6868b8d0U,
+    0x4141c382U, 0x9999b029U, 0x2d2d775aU, 0x0f0f111eU,
+    0xb0b0cb7bU, 0x5454fca8U, 0xbbbbd66dU, 0x16163a2cU,
+};
+static const u32 Te4[256] = {
+    0x63636363U, 0x7c7c7c7cU, 0x77777777U, 0x7b7b7b7bU,
+    0xf2f2f2f2U, 0x6b6b6b6bU, 0x6f6f6f6fU, 0xc5c5c5c5U,
+    0x30303030U, 0x01010101U, 0x67676767U, 0x2b2b2b2bU,
+    0xfefefefeU, 0xd7d7d7d7U, 0xababababU, 0x76767676U,
+    0xcacacacaU, 0x82828282U, 0xc9c9c9c9U, 0x7d7d7d7dU,
+    0xfafafafaU, 0x59595959U, 0x47474747U, 0xf0f0f0f0U,
+    0xadadadadU, 0xd4d4d4d4U, 0xa2a2a2a2U, 0xafafafafU,
+    0x9c9c9c9cU, 0xa4a4a4a4U, 0x72727272U, 0xc0c0c0c0U,
+    0xb7b7b7b7U, 0xfdfdfdfdU, 0x93939393U, 0x26262626U,
+    0x36363636U, 0x3f3f3f3fU, 0xf7f7f7f7U, 0xccccccccU,
+    0x34343434U, 0xa5a5a5a5U, 0xe5e5e5e5U, 0xf1f1f1f1U,
+    0x71717171U, 0xd8d8d8d8U, 0x31313131U, 0x15151515U,
+    0x04040404U, 0xc7c7c7c7U, 0x23232323U, 0xc3c3c3c3U,
+    0x18181818U, 0x96969696U, 0x05050505U, 0x9a9a9a9aU,
+    0x07070707U, 0x12121212U, 0x80808080U, 0xe2e2e2e2U,
+    0xebebebebU, 0x27272727U, 0xb2b2b2b2U, 0x75757575U,
+    0x09090909U, 0x83838383U, 0x2c2c2c2cU, 0x1a1a1a1aU,
+    0x1b1b1b1bU, 0x6e6e6e6eU, 0x5a5a5a5aU, 0xa0a0a0a0U,
+    0x52525252U, 0x3b3b3b3bU, 0xd6d6d6d6U, 0xb3b3b3b3U,
+    0x29292929U, 0xe3e3e3e3U, 0x2f2f2f2fU, 0x84848484U,
+    0x53535353U, 0xd1d1d1d1U, 0x00000000U, 0xededededU,
+    0x20202020U, 0xfcfcfcfcU, 0xb1b1b1b1U, 0x5b5b5b5bU,
+    0x6a6a6a6aU, 0xcbcbcbcbU, 0xbebebebeU, 0x39393939U,
+    0x4a4a4a4aU, 0x4c4c4c4cU, 0x58585858U, 0xcfcfcfcfU,
+    0xd0d0d0d0U, 0xefefefefU, 0xaaaaaaaaU, 0xfbfbfbfbU,
+    0x43434343U, 0x4d4d4d4dU, 0x33333333U, 0x85858585U,
+    0x45454545U, 0xf9f9f9f9U, 0x02020202U, 0x7f7f7f7fU,
+    0x50505050U, 0x3c3c3c3cU, 0x9f9f9f9fU, 0xa8a8a8a8U,
+    0x51515151U, 0xa3a3a3a3U, 0x40404040U, 0x8f8f8f8fU,
+    0x92929292U, 0x9d9d9d9dU, 0x38383838U, 0xf5f5f5f5U,
+    0xbcbcbcbcU, 0xb6b6b6b6U, 0xdadadadaU, 0x21212121U,
+    0x10101010U, 0xffffffffU, 0xf3f3f3f3U, 0xd2d2d2d2U,
+    0xcdcdcdcdU, 0x0c0c0c0cU, 0x13131313U, 0xececececU,
+    0x5f5f5f5fU, 0x97979797U, 0x44444444U, 0x17171717U,
+    0xc4c4c4c4U, 0xa7a7a7a7U, 0x7e7e7e7eU, 0x3d3d3d3dU,
+    0x64646464U, 0x5d5d5d5dU, 0x19191919U, 0x73737373U,
+    0x60606060U, 0x81818181U, 0x4f4f4f4fU, 0xdcdcdcdcU,
+    0x22222222U, 0x2a2a2a2aU, 0x90909090U, 0x88888888U,
+    0x46464646U, 0xeeeeeeeeU, 0xb8b8b8b8U, 0x14141414U,
+    0xdedededeU, 0x5e5e5e5eU, 0x0b0b0b0bU, 0xdbdbdbdbU,
+    0xe0e0e0e0U, 0x32323232U, 0x3a3a3a3aU, 0x0a0a0a0aU,
+    0x49494949U, 0x06060606U, 0x24242424U, 0x5c5c5c5cU,
+    0xc2c2c2c2U, 0xd3d3d3d3U, 0xacacacacU, 0x62626262U,
+    0x91919191U, 0x95959595U, 0xe4e4e4e4U, 0x79797979U,
+    0xe7e7e7e7U, 0xc8c8c8c8U, 0x37373737U, 0x6d6d6d6dU,
+    0x8d8d8d8dU, 0xd5d5d5d5U, 0x4e4e4e4eU, 0xa9a9a9a9U,
+    0x6c6c6c6cU, 0x56565656U, 0xf4f4f4f4U, 0xeaeaeaeaU,
+    0x65656565U, 0x7a7a7a7aU, 0xaeaeaeaeU, 0x08080808U,
+    0xbabababaU, 0x78787878U, 0x25252525U, 0x2e2e2e2eU,
+    0x1c1c1c1cU, 0xa6a6a6a6U, 0xb4b4b4b4U, 0xc6c6c6c6U,
+    0xe8e8e8e8U, 0xddddddddU, 0x74747474U, 0x1f1f1f1fU,
+    0x4b4b4b4bU, 0xbdbdbdbdU, 0x8b8b8b8bU, 0x8a8a8a8aU,
+    0x70707070U, 0x3e3e3e3eU, 0xb5b5b5b5U, 0x66666666U,
+    0x48484848U, 0x03030303U, 0xf6f6f6f6U, 0x0e0e0e0eU,
+    0x61616161U, 0x35353535U, 0x57575757U, 0xb9b9b9b9U,
+    0x86868686U, 0xc1c1c1c1U, 0x1d1d1d1dU, 0x9e9e9e9eU,
+    0xe1e1e1e1U, 0xf8f8f8f8U, 0x98989898U, 0x11111111U,
+    0x69696969U, 0xd9d9d9d9U, 0x8e8e8e8eU, 0x94949494U,
+    0x9b9b9b9bU, 0x1e1e1e1eU, 0x87878787U, 0xe9e9e9e9U,
+    0xcecececeU, 0x55555555U, 0x28282828U, 0xdfdfdfdfU,
+    0x8c8c8c8cU, 0xa1a1a1a1U, 0x89898989U, 0x0d0d0d0dU,
+    0xbfbfbfbfU, 0xe6e6e6e6U, 0x42424242U, 0x68686868U,
+    0x41414141U, 0x99999999U, 0x2d2d2d2dU, 0x0f0f0f0fU,
+    0xb0b0b0b0U, 0x54545454U, 0xbbbbbbbbU, 0x16161616U,
+};
+static const u32 Td0[256] = {
+    0x51f4a750U, 0x7e416553U, 0x1a17a4c3U, 0x3a275e96U,
+    0x3bab6bcbU, 0x1f9d45f1U, 0xacfa58abU, 0x4be30393U,
+    0x2030fa55U, 0xad766df6U, 0x88cc7691U, 0xf5024c25U,
+    0x4fe5d7fcU, 0xc52acbd7U, 0x26354480U, 0xb562a38fU,
+    0xdeb15a49U, 0x25ba1b67U, 0x45ea0e98U, 0x5dfec0e1U,
+    0xc32f7502U, 0x814cf012U, 0x8d4697a3U, 0x6bd3f9c6U,
+    0x038f5fe7U, 0x15929c95U, 0xbf6d7aebU, 0x955259daU,
+    0xd4be832dU, 0x587421d3U, 0x49e06929U, 0x8ec9c844U,
+    0x75c2896aU, 0xf48e7978U, 0x99583e6bU, 0x27b971ddU,
+    0xbee14fb6U, 0xf088ad17U, 0xc920ac66U, 0x7dce3ab4U,
+    0x63df4a18U, 0xe51a3182U, 0x97513360U, 0x62537f45U,
+    0xb16477e0U, 0xbb6bae84U, 0xfe81a01cU, 0xf9082b94U,
+    0x70486858U, 0x8f45fd19U, 0x94de6c87U, 0x527bf8b7U,
+    0xab73d323U, 0x724b02e2U, 0xe31f8f57U, 0x6655ab2aU,
+    0xb2eb2807U, 0x2fb5c203U, 0x86c57b9aU, 0xd33708a5U,
+    0x302887f2U, 0x23bfa5b2U, 0x02036abaU, 0xed16825cU,
+    0x8acf1c2bU, 0xa779b492U, 0xf307f2f0U, 0x4e69e2a1U,
+    0x65daf4cdU, 0x0605bed5U, 0xd134621fU, 0xc4a6fe8aU,
+    0x342e539dU, 0xa2f355a0U, 0x058ae132U, 0xa4f6eb75U,
+    0x0b83ec39U, 0x4060efaaU, 0x5e719f06U, 0xbd6e1051U,
+    0x3e218af9U, 0x96dd063dU, 0xdd3e05aeU, 0x4de6bd46U,
+    0x91548db5U, 0x71c45d05U, 0x0406d46fU, 0x605015ffU,
+    0x1998fb24U, 0xd6bde997U, 0x894043ccU, 0x67d99e77U,
+    0xb0e842bdU, 0x07898b88U, 0xe7195b38U, 0x79c8eedbU,
+    0xa17c0a47U, 0x7c420fe9U, 0xf8841ec9U, 0x00000000U,
+    0x09808683U, 0x322bed48U, 0x1e1170acU, 0x6c5a724eU,
+    0xfd0efffbU, 0x0f853856U, 0x3daed51eU, 0x362d3927U,
+    0x0a0fd964U, 0x685ca621U, 0x9b5b54d1U, 0x24362e3aU,
+    0x0c0a67b1U, 0x9357e70fU, 0xb4ee96d2U, 0x1b9b919eU,
+    0x80c0c54fU, 0x61dc20a2U, 0x5a774b69U, 0x1c121a16U,
+    0xe293ba0aU, 0xc0a02ae5U, 0x3c22e043U, 0x121b171dU,
+    0x0e090d0bU, 0xf28bc7adU, 0x2db6a8b9U, 0x141ea9c8U,
+    0x57f11985U, 0xaf75074cU, 0xee99ddbbU, 0xa37f60fdU,
+    0xf701269fU, 0x5c72f5bcU, 0x44663bc5U, 0x5bfb7e34U,
+    0x8b432976U, 0xcb23c6dcU, 0xb6edfc68U, 0xb8e4f163U,
+    0xd731dccaU, 0x42638510U, 0x13972240U, 0x84c61120U,
+    0x854a247dU, 0xd2bb3df8U, 0xaef93211U, 0xc729a16dU,
+    0x1d9e2f4bU, 0xdcb230f3U, 0x0d8652ecU, 0x77c1e3d0U,
+    0x2bb3166cU, 0xa970b999U, 0x119448faU, 0x47e96422U,
+    0xa8fc8cc4U, 0xa0f03f1aU, 0x567d2cd8U, 0x223390efU,
+    0x87494ec7U, 0xd938d1c1U, 0x8ccaa2feU, 0x98d40b36U,
+    0xa6f581cfU, 0xa57ade28U, 0xdab78e26U, 0x3fadbfa4U,
+    0x2c3a9de4U, 0x5078920dU, 0x6a5fcc9bU, 0x547e4662U,
+    0xf68d13c2U, 0x90d8b8e8U, 0x2e39f75eU, 0x82c3aff5U,
+    0x9f5d80beU, 0x69d0937cU, 0x6fd52da9U, 0xcf2512b3U,
+    0xc8ac993bU, 0x10187da7U, 0xe89c636eU, 0xdb3bbb7bU,
+    0xcd267809U, 0x6e5918f4U, 0xec9ab701U, 0x834f9aa8U,
+    0xe6956e65U, 0xaaffe67eU, 0x21bccf08U, 0xef15e8e6U,
+    0xbae79bd9U, 0x4a6f36ceU, 0xea9f09d4U, 0x29b07cd6U,
+    0x31a4b2afU, 0x2a3f2331U, 0xc6a59430U, 0x35a266c0U,
+    0x744ebc37U, 0xfc82caa6U, 0xe090d0b0U, 0x33a7d815U,
+    0xf104984aU, 0x41ecdaf7U, 0x7fcd500eU, 0x1791f62fU,
+    0x764dd68dU, 0x43efb04dU, 0xccaa4d54U, 0xe49604dfU,
+    0x9ed1b5e3U, 0x4c6a881bU, 0xc12c1fb8U, 0x4665517fU,
+    0x9d5eea04U, 0x018c355dU, 0xfa877473U, 0xfb0b412eU,
+    0xb3671d5aU, 0x92dbd252U, 0xe9105633U, 0x6dd64713U,
+    0x9ad7618cU, 0x37a10c7aU, 0x59f8148eU, 0xeb133c89U,
+    0xcea927eeU, 0xb761c935U, 0xe11ce5edU, 0x7a47b13cU,
+    0x9cd2df59U, 0x55f2733fU, 0x1814ce79U, 0x73c737bfU,
+    0x53f7cdeaU, 0x5ffdaa5bU, 0xdf3d6f14U, 0x7844db86U,
+    0xcaaff381U, 0xb968c43eU, 0x3824342cU, 0xc2a3405fU,
+    0x161dc372U, 0xbce2250cU, 0x283c498bU, 0xff0d9541U,
+    0x39a80171U, 0x080cb3deU, 0xd8b4e49cU, 0x6456c190U,
+    0x7bcb8461U, 0xd532b670U, 0x486c5c74U, 0xd0b85742U,
+};
+static const u32 Td1[256] = {
+    0x5051f4a7U, 0x537e4165U, 0xc31a17a4U, 0x963a275eU,
+    0xcb3bab6bU, 0xf11f9d45U, 0xabacfa58U, 0x934be303U,
+    0x552030faU, 0xf6ad766dU, 0x9188cc76U, 0x25f5024cU,
+    0xfc4fe5d7U, 0xd7c52acbU, 0x80263544U, 0x8fb562a3U,
+    0x49deb15aU, 0x6725ba1bU, 0x9845ea0eU, 0xe15dfec0U,
+    0x02c32f75U, 0x12814cf0U, 0xa38d4697U, 0xc66bd3f9U,
+    0xe7038f5fU, 0x9515929cU, 0xebbf6d7aU, 0xda955259U,
+    0x2dd4be83U, 0xd3587421U, 0x2949e069U, 0x448ec9c8U,
+    0x6a75c289U, 0x78f48e79U, 0x6b99583eU, 0xdd27b971U,
+    0xb6bee14fU, 0x17f088adU, 0x66c920acU, 0xb47dce3aU,
+    0x1863df4aU, 0x82e51a31U, 0x60975133U, 0x4562537fU,
+    0xe0b16477U, 0x84bb6baeU, 0x1cfe81a0U, 0x94f9082bU,
+    0x58704868U, 0x198f45fdU, 0x8794de6cU, 0xb7527bf8U,
+    0x23ab73d3U, 0xe2724b02U, 0x57e31f8fU, 0x2a6655abU,
+    0x07b2eb28U, 0x032fb5c2U, 0x9a86c57bU, 0xa5d33708U,
+    0xf2302887U, 0xb223bfa5U, 0xba02036aU, 0x5ced1682U,
+    0x2b8acf1cU, 0x92a779b4U, 0xf0f307f2U, 0xa14e69e2U,
+    0xcd65daf4U, 0xd50605beU, 0x1fd13462U, 0x8ac4a6feU,
+    0x9d342e53U, 0xa0a2f355U, 0x32058ae1U, 0x75a4f6ebU,
+    0x390b83ecU, 0xaa4060efU, 0x065e719fU, 0x51bd6e10U,
+    0xf93e218aU, 0x3d96dd06U, 0xaedd3e05U, 0x464de6bdU,
+    0xb591548dU, 0x0571c45dU, 0x6f0406d4U, 0xff605015U,
+    0x241998fbU, 0x97d6bde9U, 0xcc894043U, 0x7767d99eU,
+    0xbdb0e842U, 0x8807898bU, 0x38e7195bU, 0xdb79c8eeU,
+    0x47a17c0aU, 0xe97c420fU, 0xc9f8841eU, 0x00000000U,
+    0x83098086U, 0x48322bedU, 0xac1e1170U, 0x4e6c5a72U,
+    0xfbfd0effU, 0x560f8538U, 0x1e3daed5U, 0x27362d39U,
+    0x640a0fd9U, 0x21685ca6U, 0xd19b5b54U, 0x3a24362eU,
+    0xb10c0a67U, 0x0f9357e7U, 0xd2b4ee96U, 0x9e1b9b91U,
+    0x4f80c0c5U, 0xa261dc20U, 0x695a774bU, 0x161c121aU,
+    0x0ae293baU, 0xe5c0a02aU, 0x433c22e0U, 0x1d121b17U,
+    0x0b0e090dU, 0xadf28bc7U, 0xb92db6a8U, 0xc8141ea9U,
+    0x8557f119U, 0x4caf7507U, 0xbbee99ddU, 0xfda37f60U,
+    0x9ff70126U, 0xbc5c72f5U, 0xc544663bU, 0x345bfb7eU,
+    0x768b4329U, 0xdccb23c6U, 0x68b6edfcU, 0x63b8e4f1U,
+    0xcad731dcU, 0x10426385U, 0x40139722U, 0x2084c611U,
+    0x7d854a24U, 0xf8d2bb3dU, 0x11aef932U, 0x6dc729a1U,
+    0x4b1d9e2fU, 0xf3dcb230U, 0xec0d8652U, 0xd077c1e3U,
+    0x6c2bb316U, 0x99a970b9U, 0xfa119448U, 0x2247e964U,
+    0xc4a8fc8cU, 0x1aa0f03fU, 0xd8567d2cU, 0xef223390U,
+    0xc787494eU, 0xc1d938d1U, 0xfe8ccaa2U, 0x3698d40bU,
+    0xcfa6f581U, 0x28a57adeU, 0x26dab78eU, 0xa43fadbfU,
+    0xe42c3a9dU, 0x0d507892U, 0x9b6a5fccU, 0x62547e46U,
+    0xc2f68d13U, 0xe890d8b8U, 0x5e2e39f7U, 0xf582c3afU,
+    0xbe9f5d80U, 0x7c69d093U, 0xa96fd52dU, 0xb3cf2512U,
+    0x3bc8ac99U, 0xa710187dU, 0x6ee89c63U, 0x7bdb3bbbU,
+    0x09cd2678U, 0xf46e5918U, 0x01ec9ab7U, 0xa8834f9aU,
+    0x65e6956eU, 0x7eaaffe6U, 0x0821bccfU, 0xe6ef15e8U,
+    0xd9bae79bU, 0xce4a6f36U, 0xd4ea9f09U, 0xd629b07cU,
+    0xaf31a4b2U, 0x312a3f23U, 0x30c6a594U, 0xc035a266U,
+    0x37744ebcU, 0xa6fc82caU, 0xb0e090d0U, 0x1533a7d8U,
+    0x4af10498U, 0xf741ecdaU, 0x0e7fcd50U, 0x2f1791f6U,
+    0x8d764dd6U, 0x4d43efb0U, 0x54ccaa4dU, 0xdfe49604U,
+    0xe39ed1b5U, 0x1b4c6a88U, 0xb8c12c1fU, 0x7f466551U,
+    0x049d5eeaU, 0x5d018c35U, 0x73fa8774U, 0x2efb0b41U,
+    0x5ab3671dU, 0x5292dbd2U, 0x33e91056U, 0x136dd647U,
+    0x8c9ad761U, 0x7a37a10cU, 0x8e59f814U, 0x89eb133cU,
+    0xeecea927U, 0x35b761c9U, 0xede11ce5U, 0x3c7a47b1U,
+    0x599cd2dfU, 0x3f55f273U, 0x791814ceU, 0xbf73c737U,
+    0xea53f7cdU, 0x5b5ffdaaU, 0x14df3d6fU, 0x867844dbU,
+    0x81caaff3U, 0x3eb968c4U, 0x2c382434U, 0x5fc2a340U,
+    0x72161dc3U, 0x0cbce225U, 0x8b283c49U, 0x41ff0d95U,
+    0x7139a801U, 0xde080cb3U, 0x9cd8b4e4U, 0x906456c1U,
+    0x617bcb84U, 0x70d532b6U, 0x74486c5cU, 0x42d0b857U,
+};
+static const u32 Td2[256] = {
+    0xa75051f4U, 0x65537e41U, 0xa4c31a17U, 0x5e963a27U,
+    0x6bcb3babU, 0x45f11f9dU, 0x58abacfaU, 0x03934be3U,
+    0xfa552030U, 0x6df6ad76U, 0x769188ccU, 0x4c25f502U,
+    0xd7fc4fe5U, 0xcbd7c52aU, 0x44802635U, 0xa38fb562U,
+    0x5a49deb1U, 0x1b6725baU, 0x0e9845eaU, 0xc0e15dfeU,
+    0x7502c32fU, 0xf012814cU, 0x97a38d46U, 0xf9c66bd3U,
+    0x5fe7038fU, 0x9c951592U, 0x7aebbf6dU, 0x59da9552U,
+    0x832dd4beU, 0x21d35874U, 0x692949e0U, 0xc8448ec9U,
+    0x896a75c2U, 0x7978f48eU, 0x3e6b9958U, 0x71dd27b9U,
+    0x4fb6bee1U, 0xad17f088U, 0xac66c920U, 0x3ab47dceU,
+    0x4a1863dfU, 0x3182e51aU, 0x33609751U, 0x7f456253U,
+    0x77e0b164U, 0xae84bb6bU, 0xa01cfe81U, 0x2b94f908U,
+    0x68587048U, 0xfd198f45U, 0x6c8794deU, 0xf8b7527bU,
+    0xd323ab73U, 0x02e2724bU, 0x8f57e31fU, 0xab2a6655U,
+    0x2807b2ebU, 0xc2032fb5U, 0x7b9a86c5U, 0x08a5d337U,
+    0x87f23028U, 0xa5b223bfU, 0x6aba0203U, 0x825ced16U,
+    0x1c2b8acfU, 0xb492a779U, 0xf2f0f307U, 0xe2a14e69U,
+    0xf4cd65daU, 0xbed50605U, 0x621fd134U, 0xfe8ac4a6U,
+    0x539d342eU, 0x55a0a2f3U, 0xe132058aU, 0xeb75a4f6U,
+    0xec390b83U, 0xefaa4060U, 0x9f065e71U, 0x1051bd6eU,
+
+    0x8af93e21U, 0x063d96ddU, 0x05aedd3eU, 0xbd464de6U,
+    0x8db59154U, 0x5d0571c4U, 0xd46f0406U, 0x15ff6050U,
+    0xfb241998U, 0xe997d6bdU, 0x43cc8940U, 0x9e7767d9U,
+    0x42bdb0e8U, 0x8b880789U, 0x5b38e719U, 0xeedb79c8U,
+    0x0a47a17cU, 0x0fe97c42U, 0x1ec9f884U, 0x00000000U,
+    0x86830980U, 0xed48322bU, 0x70ac1e11U, 0x724e6c5aU,
+    0xfffbfd0eU, 0x38560f85U, 0xd51e3daeU, 0x3927362dU,
+    0xd9640a0fU, 0xa621685cU, 0x54d19b5bU, 0x2e3a2436U,
+    0x67b10c0aU, 0xe70f9357U, 0x96d2b4eeU, 0x919e1b9bU,
+    0xc54f80c0U, 0x20a261dcU, 0x4b695a77U, 0x1a161c12U,
+    0xba0ae293U, 0x2ae5c0a0U, 0xe0433c22U, 0x171d121bU,
+    0x0d0b0e09U, 0xc7adf28bU, 0xa8b92db6U, 0xa9c8141eU,
+    0x198557f1U, 0x074caf75U, 0xddbbee99U, 0x60fda37fU,
+    0x269ff701U, 0xf5bc5c72U, 0x3bc54466U, 0x7e345bfbU,
+    0x29768b43U, 0xc6dccb23U, 0xfc68b6edU, 0xf163b8e4U,
+    0xdccad731U, 0x85104263U, 0x22401397U, 0x112084c6U,
+    0x247d854aU, 0x3df8d2bbU, 0x3211aef9U, 0xa16dc729U,
+    0x2f4b1d9eU, 0x30f3dcb2U, 0x52ec0d86U, 0xe3d077c1U,
+    0x166c2bb3U, 0xb999a970U, 0x48fa1194U, 0x642247e9U,
+    0x8cc4a8fcU, 0x3f1aa0f0U, 0x2cd8567dU, 0x90ef2233U,
+    0x4ec78749U, 0xd1c1d938U, 0xa2fe8ccaU, 0x0b3698d4U,
+    0x81cfa6f5U, 0xde28a57aU, 0x8e26dab7U, 0xbfa43fadU,
+    0x9de42c3aU, 0x920d5078U, 0xcc9b6a5fU, 0x4662547eU,
+    0x13c2f68dU, 0xb8e890d8U, 0xf75e2e39U, 0xaff582c3U,
+    0x80be9f5dU, 0x937c69d0U, 0x2da96fd5U, 0x12b3cf25U,
+    0x993bc8acU, 0x7da71018U, 0x636ee89cU, 0xbb7bdb3bU,
+    0x7809cd26U, 0x18f46e59U, 0xb701ec9aU, 0x9aa8834fU,
+    0x6e65e695U, 0xe67eaaffU, 0xcf0821bcU, 0xe8e6ef15U,
+    0x9bd9bae7U, 0x36ce4a6fU, 0x09d4ea9fU, 0x7cd629b0U,
+    0xb2af31a4U, 0x23312a3fU, 0x9430c6a5U, 0x66c035a2U,
+    0xbc37744eU, 0xcaa6fc82U, 0xd0b0e090U, 0xd81533a7U,
+    0x984af104U, 0xdaf741ecU, 0x500e7fcdU, 0xf62f1791U,
+    0xd68d764dU, 0xb04d43efU, 0x4d54ccaaU, 0x04dfe496U,
+    0xb5e39ed1U, 0x881b4c6aU, 0x1fb8c12cU, 0x517f4665U,
+    0xea049d5eU, 0x355d018cU, 0x7473fa87U, 0x412efb0bU,
+    0x1d5ab367U, 0xd25292dbU, 0x5633e910U, 0x47136dd6U,
+    0x618c9ad7U, 0x0c7a37a1U, 0x148e59f8U, 0x3c89eb13U,
+    0x27eecea9U, 0xc935b761U, 0xe5ede11cU, 0xb13c7a47U,
+    0xdf599cd2U, 0x733f55f2U, 0xce791814U, 0x37bf73c7U,
+    0xcdea53f7U, 0xaa5b5ffdU, 0x6f14df3dU, 0xdb867844U,
+    0xf381caafU, 0xc43eb968U, 0x342c3824U, 0x405fc2a3U,
+    0xc372161dU, 0x250cbce2U, 0x498b283cU, 0x9541ff0dU,
+    0x017139a8U, 0xb3de080cU, 0xe49cd8b4U, 0xc1906456U,
+    0x84617bcbU, 0xb670d532U, 0x5c74486cU, 0x5742d0b8U,
+};
+static const u32 Td3[256] = {
+    0xf4a75051U, 0x4165537eU, 0x17a4c31aU, 0x275e963aU,
+    0xab6bcb3bU, 0x9d45f11fU, 0xfa58abacU, 0xe303934bU,
+    0x30fa5520U, 0x766df6adU, 0xcc769188U, 0x024c25f5U,
+    0xe5d7fc4fU, 0x2acbd7c5U, 0x35448026U, 0x62a38fb5U,
+    0xb15a49deU, 0xba1b6725U, 0xea0e9845U, 0xfec0e15dU,
+    0x2f7502c3U, 0x4cf01281U, 0x4697a38dU, 0xd3f9c66bU,
+    0x8f5fe703U, 0x929c9515U, 0x6d7aebbfU, 0x5259da95U,
+    0xbe832dd4U, 0x7421d358U, 0xe0692949U, 0xc9c8448eU,
+    0xc2896a75U, 0x8e7978f4U, 0x583e6b99U, 0xb971dd27U,
+    0xe14fb6beU, 0x88ad17f0U, 0x20ac66c9U, 0xce3ab47dU,
+    0xdf4a1863U, 0x1a3182e5U, 0x51336097U, 0x537f4562U,
+    0x6477e0b1U, 0x6bae84bbU, 0x81a01cfeU, 0x082b94f9U,
+    0x48685870U, 0x45fd198fU, 0xde6c8794U, 0x7bf8b752U,
+    0x73d323abU, 0x4b02e272U, 0x1f8f57e3U, 0x55ab2a66U,
+    0xeb2807b2U, 0xb5c2032fU, 0xc57b9a86U, 0x3708a5d3U,
+    0x2887f230U, 0xbfa5b223U, 0x036aba02U, 0x16825cedU,
+    0xcf1c2b8aU, 0x79b492a7U, 0x07f2f0f3U, 0x69e2a14eU,
+    0xdaf4cd65U, 0x05bed506U, 0x34621fd1U, 0xa6fe8ac4U,
+    0x2e539d34U, 0xf355a0a2U, 0x8ae13205U, 0xf6eb75a4U,
+    0x83ec390bU, 0x60efaa40U, 0x719f065eU, 0x6e1051bdU,
+    0x218af93eU, 0xdd063d96U, 0x3e05aeddU, 0xe6bd464dU,
+    0x548db591U, 0xc45d0571U, 0x06d46f04U, 0x5015ff60U,
+    0x98fb2419U, 0xbde997d6U, 0x4043cc89U, 0xd99e7767U,
+    0xe842bdb0U, 0x898b8807U, 0x195b38e7U, 0xc8eedb79U,
+    0x7c0a47a1U, 0x420fe97cU, 0x841ec9f8U, 0x00000000U,
+    0x80868309U, 0x2bed4832U, 0x1170ac1eU, 0x5a724e6cU,
+    0x0efffbfdU, 0x8538560fU, 0xaed51e3dU, 0x2d392736U,
+    0x0fd9640aU, 0x5ca62168U, 0x5b54d19bU, 0x362e3a24U,
+    0x0a67b10cU, 0x57e70f93U, 0xee96d2b4U, 0x9b919e1bU,
+    0xc0c54f80U, 0xdc20a261U, 0x774b695aU, 0x121a161cU,
+    0x93ba0ae2U, 0xa02ae5c0U, 0x22e0433cU, 0x1b171d12U,
+    0x090d0b0eU, 0x8bc7adf2U, 0xb6a8b92dU, 0x1ea9c814U,
+    0xf1198557U, 0x75074cafU, 0x99ddbbeeU, 0x7f60fda3U,
+    0x01269ff7U, 0x72f5bc5cU, 0x663bc544U, 0xfb7e345bU,
+    0x4329768bU, 0x23c6dccbU, 0xedfc68b6U, 0xe4f163b8U,
+    0x31dccad7U, 0x63851042U, 0x97224013U, 0xc6112084U,
+    0x4a247d85U, 0xbb3df8d2U, 0xf93211aeU, 0x29a16dc7U,
+    0x9e2f4b1dU, 0xb230f3dcU, 0x8652ec0dU, 0xc1e3d077U,
+    0xb3166c2bU, 0x70b999a9U, 0x9448fa11U, 0xe9642247U,
+    0xfc8cc4a8U, 0xf03f1aa0U, 0x7d2cd856U, 0x3390ef22U,
+    0x494ec787U, 0x38d1c1d9U, 0xcaa2fe8cU, 0xd40b3698U,
+    0xf581cfa6U, 0x7ade28a5U, 0xb78e26daU, 0xadbfa43fU,
+    0x3a9de42cU, 0x78920d50U, 0x5fcc9b6aU, 0x7e466254U,
+    0x8d13c2f6U, 0xd8b8e890U, 0x39f75e2eU, 0xc3aff582U,
+    0x5d80be9fU, 0xd0937c69U, 0xd52da96fU, 0x2512b3cfU,
+    0xac993bc8U, 0x187da710U, 0x9c636ee8U, 0x3bbb7bdbU,
+    0x267809cdU, 0x5918f46eU, 0x9ab701ecU, 0x4f9aa883U,
+    0x956e65e6U, 0xffe67eaaU, 0xbccf0821U, 0x15e8e6efU,
+    0xe79bd9baU, 0x6f36ce4aU, 0x9f09d4eaU, 0xb07cd629U,
+    0xa4b2af31U, 0x3f23312aU, 0xa59430c6U, 0xa266c035U,
+    0x4ebc3774U, 0x82caa6fcU, 0x90d0b0e0U, 0xa7d81533U,
+    0x04984af1U, 0xecdaf741U, 0xcd500e7fU, 0x91f62f17U,
+    0x4dd68d76U, 0xefb04d43U, 0xaa4d54ccU, 0x9604dfe4U,
+    0xd1b5e39eU, 0x6a881b4cU, 0x2c1fb8c1U, 0x65517f46U,
+    0x5eea049dU, 0x8c355d01U, 0x877473faU, 0x0b412efbU,
+    0x671d5ab3U, 0xdbd25292U, 0x105633e9U, 0xd647136dU,
+    0xd7618c9aU, 0xa10c7a37U, 0xf8148e59U, 0x133c89ebU,
+    0xa927eeceU, 0x61c935b7U, 0x1ce5ede1U, 0x47b13c7aU,
+    0xd2df599cU, 0xf2733f55U, 0x14ce7918U, 0xc737bf73U,
+    0xf7cdea53U, 0xfdaa5b5fU, 0x3d6f14dfU, 0x44db8678U,
+    0xaff381caU, 0x68c43eb9U, 0x24342c38U, 0xa3405fc2U,
+    0x1dc37216U, 0xe2250cbcU, 0x3c498b28U, 0x0d9541ffU,
+    0xa8017139U, 0x0cb3de08U, 0xb4e49cd8U, 0x56c19064U,
+    0xcb84617bU, 0x32b670d5U, 0x6c5c7448U, 0xb85742d0U,
+};
+static const u32 Td4[256] = {
+    0x52525252U, 0x09090909U, 0x6a6a6a6aU, 0xd5d5d5d5U,
+    0x30303030U, 0x36363636U, 0xa5a5a5a5U, 0x38383838U,
+    0xbfbfbfbfU, 0x40404040U, 0xa3a3a3a3U, 0x9e9e9e9eU,
+    0x81818181U, 0xf3f3f3f3U, 0xd7d7d7d7U, 0xfbfbfbfbU,
+    0x7c7c7c7cU, 0xe3e3e3e3U, 0x39393939U, 0x82828282U,
+    0x9b9b9b9bU, 0x2f2f2f2fU, 0xffffffffU, 0x87878787U,
+    0x34343434U, 0x8e8e8e8eU, 0x43434343U, 0x44444444U,
+    0xc4c4c4c4U, 0xdedededeU, 0xe9e9e9e9U, 0xcbcbcbcbU,
+    0x54545454U, 0x7b7b7b7bU, 0x94949494U, 0x32323232U,
+    0xa6a6a6a6U, 0xc2c2c2c2U, 0x23232323U, 0x3d3d3d3dU,
+    0xeeeeeeeeU, 0x4c4c4c4cU, 0x95959595U, 0x0b0b0b0bU,
+    0x42424242U, 0xfafafafaU, 0xc3c3c3c3U, 0x4e4e4e4eU,
+    0x08080808U, 0x2e2e2e2eU, 0xa1a1a1a1U, 0x66666666U,
+    0x28282828U, 0xd9d9d9d9U, 0x24242424U, 0xb2b2b2b2U,
+    0x76767676U, 0x5b5b5b5bU, 0xa2a2a2a2U, 0x49494949U,
+    0x6d6d6d6dU, 0x8b8b8b8bU, 0xd1d1d1d1U, 0x25252525U,
+    0x72727272U, 0xf8f8f8f8U, 0xf6f6f6f6U, 0x64646464U,
+    0x86868686U, 0x68686868U, 0x98989898U, 0x16161616U,
+    0xd4d4d4d4U, 0xa4a4a4a4U, 0x5c5c5c5cU, 0xccccccccU,
+    0x5d5d5d5dU, 0x65656565U, 0xb6b6b6b6U, 0x92929292U,
+    0x6c6c6c6cU, 0x70707070U, 0x48484848U, 0x50505050U,
+    0xfdfdfdfdU, 0xededededU, 0xb9b9b9b9U, 0xdadadadaU,
+    0x5e5e5e5eU, 0x15151515U, 0x46464646U, 0x57575757U,
+    0xa7a7a7a7U, 0x8d8d8d8dU, 0x9d9d9d9dU, 0x84848484U,
+    0x90909090U, 0xd8d8d8d8U, 0xababababU, 0x00000000U,
+    0x8c8c8c8cU, 0xbcbcbcbcU, 0xd3d3d3d3U, 0x0a0a0a0aU,
+    0xf7f7f7f7U, 0xe4e4e4e4U, 0x58585858U, 0x05050505U,
+    0xb8b8b8b8U, 0xb3b3b3b3U, 0x45454545U, 0x06060606U,
+    0xd0d0d0d0U, 0x2c2c2c2cU, 0x1e1e1e1eU, 0x8f8f8f8fU,
+    0xcacacacaU, 0x3f3f3f3fU, 0x0f0f0f0fU, 0x02020202U,
+    0xc1c1c1c1U, 0xafafafafU, 0xbdbdbdbdU, 0x03030303U,
+    0x01010101U, 0x13131313U, 0x8a8a8a8aU, 0x6b6b6b6bU,
+    0x3a3a3a3aU, 0x91919191U, 0x11111111U, 0x41414141U,
+    0x4f4f4f4fU, 0x67676767U, 0xdcdcdcdcU, 0xeaeaeaeaU,
+    0x97979797U, 0xf2f2f2f2U, 0xcfcfcfcfU, 0xcecececeU,
+    0xf0f0f0f0U, 0xb4b4b4b4U, 0xe6e6e6e6U, 0x73737373U,
+    0x96969696U, 0xacacacacU, 0x74747474U, 0x22222222U,
+    0xe7e7e7e7U, 0xadadadadU, 0x35353535U, 0x85858585U,
+    0xe2e2e2e2U, 0xf9f9f9f9U, 0x37373737U, 0xe8e8e8e8U,
+    0x1c1c1c1cU, 0x75757575U, 0xdfdfdfdfU, 0x6e6e6e6eU,
+    0x47474747U, 0xf1f1f1f1U, 0x1a1a1a1aU, 0x71717171U,
+    0x1d1d1d1dU, 0x29292929U, 0xc5c5c5c5U, 0x89898989U,
+    0x6f6f6f6fU, 0xb7b7b7b7U, 0x62626262U, 0x0e0e0e0eU,
+    0xaaaaaaaaU, 0x18181818U, 0xbebebebeU, 0x1b1b1b1bU,
+    0xfcfcfcfcU, 0x56565656U, 0x3e3e3e3eU, 0x4b4b4b4bU,
+    0xc6c6c6c6U, 0xd2d2d2d2U, 0x79797979U, 0x20202020U,
+    0x9a9a9a9aU, 0xdbdbdbdbU, 0xc0c0c0c0U, 0xfefefefeU,
+    0x78787878U, 0xcdcdcdcdU, 0x5a5a5a5aU, 0xf4f4f4f4U,
+    0x1f1f1f1fU, 0xddddddddU, 0xa8a8a8a8U, 0x33333333U,
+    0x88888888U, 0x07070707U, 0xc7c7c7c7U, 0x31313131U,
+    0xb1b1b1b1U, 0x12121212U, 0x10101010U, 0x59595959U,
+    0x27272727U, 0x80808080U, 0xececececU, 0x5f5f5f5fU,
+    0x60606060U, 0x51515151U, 0x7f7f7f7fU, 0xa9a9a9a9U,
+    0x19191919U, 0xb5b5b5b5U, 0x4a4a4a4aU, 0x0d0d0d0dU,
+    0x2d2d2d2dU, 0xe5e5e5e5U, 0x7a7a7a7aU, 0x9f9f9f9fU,
+    0x93939393U, 0xc9c9c9c9U, 0x9c9c9c9cU, 0xefefefefU,
+    0xa0a0a0a0U, 0xe0e0e0e0U, 0x3b3b3b3bU, 0x4d4d4d4dU,
+    0xaeaeaeaeU, 0x2a2a2a2aU, 0xf5f5f5f5U, 0xb0b0b0b0U,
+    0xc8c8c8c8U, 0xebebebebU, 0xbbbbbbbbU, 0x3c3c3c3cU,
+    0x83838383U, 0x53535353U, 0x99999999U, 0x61616161U,
+    0x17171717U, 0x2b2b2b2bU, 0x04040404U, 0x7e7e7e7eU,
+    0xbabababaU, 0x77777777U, 0xd6d6d6d6U, 0x26262626U,
+    0xe1e1e1e1U, 0x69696969U, 0x14141414U, 0x63636363U,
+    0x55555555U, 0x21212121U, 0x0c0c0c0cU, 0x7d7d7d7dU,
+};
+static const u32 rcon[] = {
+	0x01000000, 0x02000000, 0x04000000, 0x08000000,
+	0x10000000, 0x20000000, 0x40000000, 0x80000000,
+	0x1B000000, 0x36000000, /* for 128-bit blocks, Rijndael never uses more than 10 rcon values */
+};
+
+/**
+ * Expand the cipher key into the encryption key schedule.
+ */
+static int AES_set_encrypt_key(const unsigned char *userKey, const int bits,
+			AES_KEY *key) {
+
+	u32 *rk;
+   	int i = 0;
+	u32 temp;
+
+	if (!userKey || !key)
+		return -1;
+	if (bits != 128 && bits != 192 && bits != 256)
+		return -2;
+
+	rk = key->rd_key;
+
+	if (bits==128)
+		key->rounds = 10;
+	else if (bits==192)
+		key->rounds = 12;
+	else
+		key->rounds = 14;
+
+	rk[0] = GETU32(userKey     );
+	rk[1] = GETU32(userKey +  4);
+	rk[2] = GETU32(userKey +  8);
+	rk[3] = GETU32(userKey + 12);
+	if (bits == 128) {
+		while (1) {
+			temp  = rk[3];
+			rk[4] = rk[0] ^
+				(Te4[(temp >> 16) & 0xff] & 0xff000000) ^
+				(Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^
+				(Te4[(temp      ) & 0xff] & 0x0000ff00) ^
+				(Te4[(temp >> 24)       ] & 0x000000ff) ^
+				rcon[i];
+			rk[5] = rk[1] ^ rk[4];
+			rk[6] = rk[2] ^ rk[5];
+			rk[7] = rk[3] ^ rk[6];
+			if (++i == 10) {
+				return 0;
+			}
+			rk += 4;
+		}
+	}
+	rk[4] = GETU32(userKey + 16);
+	rk[5] = GETU32(userKey + 20);
+	if (bits == 192) {
+		while (1) {
+			temp = rk[ 5];
+			rk[ 6] = rk[ 0] ^
+				(Te4[(temp >> 16) & 0xff] & 0xff000000) ^
+				(Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^
+				(Te4[(temp      ) & 0xff] & 0x0000ff00) ^
+				(Te4[(temp >> 24)       ] & 0x000000ff) ^
+				rcon[i];
+			rk[ 7] = rk[ 1] ^ rk[ 6];
+			rk[ 8] = rk[ 2] ^ rk[ 7];
+			rk[ 9] = rk[ 3] ^ rk[ 8];
+			if (++i == 8) {
+				return 0;
+			}
+			rk[10] = rk[ 4] ^ rk[ 9];
+			rk[11] = rk[ 5] ^ rk[10];
+			rk += 6;
+		}
+	}
+	rk[6] = GETU32(userKey + 24);
+	rk[7] = GETU32(userKey + 28);
+	if (bits == 256) {
+		while (1) {
+			temp = rk[ 7];
+			rk[ 8] = rk[ 0] ^
+				(Te4[(temp >> 16) & 0xff] & 0xff000000) ^
+				(Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^
+				(Te4[(temp      ) & 0xff] & 0x0000ff00) ^
+				(Te4[(temp >> 24)       ] & 0x000000ff) ^
+				rcon[i];
+			rk[ 9] = rk[ 1] ^ rk[ 8];
+			rk[10] = rk[ 2] ^ rk[ 9];
+			rk[11] = rk[ 3] ^ rk[10];
+			if (++i == 7) {
+				return 0;
+			}
+			temp = rk[11];
+			rk[12] = rk[ 4] ^
+				(Te4[(temp >> 24)       ] & 0xff000000) ^
+				(Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^
+				(Te4[(temp >>  8) & 0xff] & 0x0000ff00) ^
+				(Te4[(temp      ) & 0xff] & 0x000000ff);
+			rk[13] = rk[ 5] ^ rk[12];
+			rk[14] = rk[ 6] ^ rk[13];
+			rk[15] = rk[ 7] ^ rk[14];
+
+			rk += 8;
+        	}
+	}
+	return 0;
+}
+
+/**
+ * Expand the cipher key into the decryption key schedule.
+ */
+static int AES_set_decrypt_key(const unsigned char *userKey, const int bits,
+			 AES_KEY *key) {
+
+        u32 *rk;
+	int i, j, status;
+	u32 temp;
+
+	/* first, start with an encryption schedule */
+	status = AES_set_encrypt_key(userKey, bits, key);
+	if (status < 0)
+		return status;
+
+	rk = key->rd_key;
+
+	/* invert the order of the round keys: */
+	for (i = 0, j = 4*(key->rounds); i < j; i += 4, j -= 4) {
+		temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;
+		temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;
+		temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;
+		temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;
+	}
+	/* apply the inverse MixColumn transform to all round keys but the first and the last: */
+	for (i = 1; i < (key->rounds); i++) {
+		rk += 4;
+		rk[0] =
+			Td0[Te4[(rk[0] >> 24)       ] & 0xff] ^
+			Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^
+			Td2[Te4[(rk[0] >>  8) & 0xff] & 0xff] ^
+			Td3[Te4[(rk[0]      ) & 0xff] & 0xff];
+		rk[1] =
+			Td0[Te4[(rk[1] >> 24)       ] & 0xff] ^
+			Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^
+			Td2[Te4[(rk[1] >>  8) & 0xff] & 0xff] ^
+			Td3[Te4[(rk[1]      ) & 0xff] & 0xff];
+		rk[2] =
+			Td0[Te4[(rk[2] >> 24)       ] & 0xff] ^
+			Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^
+			Td2[Te4[(rk[2] >>  8) & 0xff] & 0xff] ^
+			Td3[Te4[(rk[2]      ) & 0xff] & 0xff];
+		rk[3] =
+			Td0[Te4[(rk[3] >> 24)       ] & 0xff] ^
+			Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^
+			Td2[Te4[(rk[3] >>  8) & 0xff] & 0xff] ^
+			Td3[Te4[(rk[3]      ) & 0xff] & 0xff];
+	}
+	return 0;
+}
+
+/*
+ * Encrypt a single block
+ * in and out can overlap
+ */
+static void AES_encrypt(const unsigned char *in, unsigned char *out,
+		 const AES_KEY *key) {
+
+	const u32 *rk;
+	u32 s0, s1, s2, s3, t0, t1, t2, t3;
+#ifndef FULL_UNROLL
+	int r;
+#endif /* ?FULL_UNROLL */
+
+	assert(in && out && key);
+	rk = key->rd_key;
+
+	/*
+	 * map byte array block to cipher state
+	 * and add initial round key:
+	 */
+	s0 = GETU32(in     ) ^ rk[0];
+	s1 = GETU32(in +  4) ^ rk[1];
+	s2 = GETU32(in +  8) ^ rk[2];
+	s3 = GETU32(in + 12) ^ rk[3];
+#ifdef FULL_UNROLL
+	/* round 1: */
+   	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[ 4];
+   	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[ 5];
+   	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[ 6];
+   	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[ 7];
+   	/* round 2: */
+   	s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[ 8];
+   	s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[ 9];
+   	s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[10];
+   	s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[11];
+	/* round 3: */
+   	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[12];
+   	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[13];
+   	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[14];
+   	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[15];
+   	/* round 4: */
+   	s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[16];
+   	s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[17];
+   	s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[18];
+   	s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[19];
+	/* round 5: */
+   	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[20];
+   	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[21];
+   	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[22];
+   	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[23];
+   	/* round 6: */
+   	s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[24];
+   	s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[25];
+   	s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[26];
+   	s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[27];
+	/* round 7: */
+   	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[28];
+   	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[29];
+   	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[30];
+   	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[31];
+   	/* round 8: */
+   	s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[32];
+   	s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[33];
+   	s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[34];
+   	s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[35];
+	/* round 9: */
+   	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[36];
+   	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[37];
+   	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[38];
+   	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[39];
+    if (key->rounds > 10) {
+        /* round 10: */
+        s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[40];
+        s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[41];
+        s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[42];
+        s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[43];
+        /* round 11: */
+        t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[44];
+        t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[45];
+        t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[46];
+        t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[47];
+        if (key->rounds > 12) {
+            /* round 12: */
+            s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[48];
+            s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[49];
+            s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[50];
+            s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[51];
+            /* round 13: */
+            t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[52];
+            t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[53];
+            t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[54];
+            t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[55];
+        }
+    }
+    rk += key->rounds << 2;
+#else  /* !FULL_UNROLL */
+    /*
+     * Nr - 1 full rounds:
+     */
+    r = key->rounds >> 1;
+    for (;;) {
+        t0 =
+            Te0[(s0 >> 24)       ] ^
+            Te1[(s1 >> 16) & 0xff] ^
+            Te2[(s2 >>  8) & 0xff] ^
+            Te3[(s3      ) & 0xff] ^
+            rk[4];
+        t1 =
+            Te0[(s1 >> 24)       ] ^
+            Te1[(s2 >> 16) & 0xff] ^
+            Te2[(s3 >>  8) & 0xff] ^
+            Te3[(s0      ) & 0xff] ^
+            rk[5];
+        t2 =
+            Te0[(s2 >> 24)       ] ^
+            Te1[(s3 >> 16) & 0xff] ^
+            Te2[(s0 >>  8) & 0xff] ^
+            Te3[(s1      ) & 0xff] ^
+            rk[6];
+        t3 =
+            Te0[(s3 >> 24)       ] ^
+            Te1[(s0 >> 16) & 0xff] ^
+            Te2[(s1 >>  8) & 0xff] ^
+            Te3[(s2      ) & 0xff] ^
+            rk[7];
+
+        rk += 8;
+        if (--r == 0) {
+            break;
+        }
+
+        s0 =
+            Te0[(t0 >> 24)       ] ^
+            Te1[(t1 >> 16) & 0xff] ^
+            Te2[(t2 >>  8) & 0xff] ^
+            Te3[(t3      ) & 0xff] ^
+            rk[0];
+        s1 =
+            Te0[(t1 >> 24)       ] ^
+            Te1[(t2 >> 16) & 0xff] ^
+            Te2[(t3 >>  8) & 0xff] ^
+            Te3[(t0      ) & 0xff] ^
+            rk[1];
+        s2 =
+            Te0[(t2 >> 24)       ] ^
+            Te1[(t3 >> 16) & 0xff] ^
+            Te2[(t0 >>  8) & 0xff] ^
+            Te3[(t1      ) & 0xff] ^
+            rk[2];
+        s3 =
+            Te0[(t3 >> 24)       ] ^
+            Te1[(t0 >> 16) & 0xff] ^
+            Te2[(t1 >>  8) & 0xff] ^
+            Te3[(t2      ) & 0xff] ^
+            rk[3];
+    }
+#endif /* ?FULL_UNROLL */
+    /*
+	 * apply last round and
+	 * map cipher state to byte array block:
+	 */
+	s0 =
+		(Te4[(t0 >> 24)       ] & 0xff000000) ^
+		(Te4[(t1 >> 16) & 0xff] & 0x00ff0000) ^
+		(Te4[(t2 >>  8) & 0xff] & 0x0000ff00) ^
+		(Te4[(t3      ) & 0xff] & 0x000000ff) ^
+		rk[0];
+	PUTU32(out     , s0);
+	s1 =
+		(Te4[(t1 >> 24)       ] & 0xff000000) ^
+		(Te4[(t2 >> 16) & 0xff] & 0x00ff0000) ^
+		(Te4[(t3 >>  8) & 0xff] & 0x0000ff00) ^
+		(Te4[(t0      ) & 0xff] & 0x000000ff) ^
+		rk[1];
+	PUTU32(out +  4, s1);
+	s2 =
+		(Te4[(t2 >> 24)       ] & 0xff000000) ^
+		(Te4[(t3 >> 16) & 0xff] & 0x00ff0000) ^
+		(Te4[(t0 >>  8) & 0xff] & 0x0000ff00) ^
+		(Te4[(t1      ) & 0xff] & 0x000000ff) ^
+		rk[2];
+	PUTU32(out +  8, s2);
+	s3 =
+		(Te4[(t3 >> 24)       ] & 0xff000000) ^
+		(Te4[(t0 >> 16) & 0xff] & 0x00ff0000) ^
+		(Te4[(t1 >>  8) & 0xff] & 0x0000ff00) ^
+		(Te4[(t2      ) & 0xff] & 0x000000ff) ^
+		rk[3];
+	PUTU32(out + 12, s3);
+}
+
+/*
+ * Decrypt a single block
+ * in and out can overlap
+ */
+static void AES_decrypt(const unsigned char *in, unsigned char *out,
+		 const AES_KEY *key) {
+
+	const u32 *rk;
+	u32 s0, s1, s2, s3, t0, t1, t2, t3;
+#ifndef FULL_UNROLL
+	int r;
+#endif /* ?FULL_UNROLL */
+
+	assert(in && out && key);
+	rk = key->rd_key;
+
+	/*
+	 * map byte array block to cipher state
+	 * and add initial round key:
+	 */
+    s0 = GETU32(in     ) ^ rk[0];
+    s1 = GETU32(in +  4) ^ rk[1];
+    s2 = GETU32(in +  8) ^ rk[2];
+    s3 = GETU32(in + 12) ^ rk[3];
+#ifdef FULL_UNROLL
+    /* round 1: */
+    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[ 4];
+    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[ 5];
+    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[ 6];
+    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[ 7];
+    /* round 2: */
+    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[ 8];
+    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[ 9];
+    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[10];
+    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[11];
+    /* round 3: */
+    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[12];
+    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[13];
+    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[14];
+    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[15];
+    /* round 4: */
+    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[16];
+    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[17];
+    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[18];
+    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[19];
+    /* round 5: */
+    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[20];
+    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[21];
+    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[22];
+    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[23];
+    /* round 6: */
+    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[24];
+    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[25];
+    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[26];
+    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[27];
+    /* round 7: */
+    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[28];
+    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[29];
+    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[30];
+    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[31];
+    /* round 8: */
+    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[32];
+    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[33];
+    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[34];
+    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[35];
+    /* round 9: */
+    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[36];
+    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[37];
+    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[38];
+    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[39];
+    if (key->rounds > 10) {
+        /* round 10: */
+        s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[40];
+        s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[41];
+        s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[42];
+        s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[43];
+        /* round 11: */
+        t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[44];
+        t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[45];
+        t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[46];
+        t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[47];
+        if (key->rounds > 12) {
+            /* round 12: */
+            s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[48];
+            s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[49];
+            s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[50];
+            s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[51];
+            /* round 13: */
+            t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[52];
+            t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[53];
+            t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[54];
+            t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[55];
+        }
+    }
+	rk += key->rounds << 2;
+#else  /* !FULL_UNROLL */
+    /*
+     * Nr - 1 full rounds:
+     */
+    r = key->rounds >> 1;
+    for (;;) {
+        t0 =
+            Td0[(s0 >> 24)       ] ^
+            Td1[(s3 >> 16) & 0xff] ^
+            Td2[(s2 >>  8) & 0xff] ^
+            Td3[(s1      ) & 0xff] ^
+            rk[4];
+        t1 =
+            Td0[(s1 >> 24)       ] ^
+            Td1[(s0 >> 16) & 0xff] ^
+            Td2[(s3 >>  8) & 0xff] ^
+            Td3[(s2      ) & 0xff] ^
+            rk[5];
+        t2 =
+            Td0[(s2 >> 24)       ] ^
+            Td1[(s1 >> 16) & 0xff] ^
+            Td2[(s0 >>  8) & 0xff] ^
+            Td3[(s3      ) & 0xff] ^
+            rk[6];
+        t3 =
+            Td0[(s3 >> 24)       ] ^
+            Td1[(s2 >> 16) & 0xff] ^
+            Td2[(s1 >>  8) & 0xff] ^
+            Td3[(s0      ) & 0xff] ^
+            rk[7];
+
+        rk += 8;
+        if (--r == 0) {
+            break;
+        }
+
+        s0 =
+            Td0[(t0 >> 24)       ] ^
+            Td1[(t3 >> 16) & 0xff] ^
+            Td2[(t2 >>  8) & 0xff] ^
+            Td3[(t1      ) & 0xff] ^
+            rk[0];
+        s1 =
+            Td0[(t1 >> 24)       ] ^
+            Td1[(t0 >> 16) & 0xff] ^
+            Td2[(t3 >>  8) & 0xff] ^
+            Td3[(t2      ) & 0xff] ^
+            rk[1];
+        s2 =
+            Td0[(t2 >> 24)       ] ^
+            Td1[(t1 >> 16) & 0xff] ^
+            Td2[(t0 >>  8) & 0xff] ^
+            Td3[(t3      ) & 0xff] ^
+            rk[2];
+        s3 =
+            Td0[(t3 >> 24)       ] ^
+            Td1[(t2 >> 16) & 0xff] ^
+            Td2[(t1 >>  8) & 0xff] ^
+            Td3[(t0      ) & 0xff] ^
+            rk[3];
+    }
+#endif /* ?FULL_UNROLL */
+    /*
+	 * apply last round and
+	 * map cipher state to byte array block:
+	 */
+   	s0 =
+   		(Td4[(t0 >> 24)       ] & 0xff000000) ^
+   		(Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^
+   		(Td4[(t2 >>  8) & 0xff] & 0x0000ff00) ^
+   		(Td4[(t1      ) & 0xff] & 0x000000ff) ^
+   		rk[0];
+	PUTU32(out     , s0);
+   	s1 =
+   		(Td4[(t1 >> 24)       ] & 0xff000000) ^
+   		(Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^
+   		(Td4[(t3 >>  8) & 0xff] & 0x0000ff00) ^
+   		(Td4[(t2      ) & 0xff] & 0x000000ff) ^
+   		rk[1];
+	PUTU32(out +  4, s1);
+   	s2 =
+   		(Td4[(t2 >> 24)       ] & 0xff000000) ^
+   		(Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^
+   		(Td4[(t0 >>  8) & 0xff] & 0x0000ff00) ^
+   		(Td4[(t3      ) & 0xff] & 0x000000ff) ^
+   		rk[2];
+	PUTU32(out +  8, s2);
+   	s3 =
+   		(Td4[(t3 >> 24)       ] & 0xff000000) ^
+   		(Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^
+   		(Td4[(t1 >>  8) & 0xff] & 0x0000ff00) ^
+   		(Td4[(t0      ) & 0xff] & 0x000000ff) ^
+   		rk[3];
+	PUTU32(out + 12, s3);
+}
diff -ruN oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/aes.h oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/aes.h
--- oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/aes.h	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/aes.h	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,57 @@
+#ifndef HEADER_AES_H
+#define HEADER_AES_H
+
+#define AES_ENCRYPT	1
+#define AES_DECRYPT	0
+
+/* Because array size can't be a const in C, the following two are macros.
+   Both sizes are in bytes. */
+#define AES_MAXNR 14
+#define AES_BLOCK_SIZE 16
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#if defined(_MSC_VER) && !defined(OPENSSL_SYS_WINCE)
+# define SWAP(x) (_lrotl(x, 8) & 0x00ff00ff | _lrotr(x, 8) & 0xff00ff00)
+# define GETU32(p) SWAP(*((u32 *)(p)))
+# define PUTU32(ct, st) { *((u32 *)(ct)) = SWAP((st)); }
+#else
+# define GETU32(pt) (((u32)(pt)[0] << 24) ^ ((u32)(pt)[1] << 16) ^ ((u32)(pt)[2] <<  8) ^ ((u32)(pt)[3]))
+# define PUTU32(ct, st) { (ct)[0] = (u8)((st) >> 24); (ct)[1] = (u8)((st) >> 16); (ct)[2] = (u8)((st) >>  8); (ct)[3] = (u8)(st); }
+#endif
+
+typedef unsigned long u32;
+typedef unsigned short u16;
+typedef unsigned char u8;
+
+#define MAXKC   (256/32)
+#define MAXKB   (256/8)
+#define MAXNR   14
+
+/* This controls loop-unrolling in aes_core.c */
+#undef FULL_UNROLL
+
+/* This should be a hidden type, but EVP requires that the size be known */
+struct aes_key_st {
+    unsigned long rd_key[4 *(AES_MAXNR + 1)];
+    int rounds;
+};
+typedef struct aes_key_st AES_KEY;
+
+static int AES_set_encrypt_key(const unsigned char *userKey, const int bits,
+	AES_KEY *key);
+static int AES_set_decrypt_key(const unsigned char *userKey, const int bits,
+	AES_KEY *key);
+
+static void AES_encrypt(const unsigned char *in, unsigned char *out,
+	const AES_KEY *key);
+static void AES_decrypt(const unsigned char *in, unsigned char *out,
+	const AES_KEY *key);
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif /* !HEADER_AES_H */
diff -ruN oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/crc32.c oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/crc32.c
--- oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/crc32.c	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/crc32.c	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,87 @@
+/* crc32.c -- compute the CRC-32 of a data stream
+ * Copyright (C) 1995-1996 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* $Id: crc32.c,v 1.1.1.1 1997/03/19 15:06:37 kivinen Exp $ */
+
+/* ========================================================================
+ * Table of CRC-32's of all single-byte values (made by make_crc_table)
+ */
+static unsigned long crc_table[256] = {
+  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
+  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
+  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
+  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
+  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
+  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
+  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
+  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
+  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
+  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
+  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
+  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
+  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
+  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
+  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
+  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
+  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
+  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
+  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
+  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
+  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
+  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
+  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
+  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
+  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
+  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
+  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
+  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
+  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
+  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
+  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
+  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
+  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
+  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
+  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
+  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
+  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
+  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
+  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
+  0x2d02ef8dL
+};
+
+#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
+#define DO2(buf) DO1(buf); DO1(buf);
+#define DO4(buf) DO2(buf); DO2(buf);
+#define DO8(buf) DO4(buf); DO4(buf);
+
+static unsigned long crc32(crc, buf, len)
+    unsigned long crc;
+    const unsigned char *buf;
+    unsigned int len;
+{
+    if (!buf) return(0L);
+    crc = crc ^ 0xffffffffL;
+    while (len >= 8)
+    {
+      DO8(buf);
+      len -= 8;
+    }
+    if (len) do {
+      DO1(buf);
+    } while (--len);
+    return(crc^0xffffffffL);
+}
diff -ruN oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/icons.inc oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/icons.inc
--- oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/icons.inc	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/icons.inc	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,408 @@
+static unsigned char icon_plus[]={
+ 0x18, 0x00, 0x18, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0xff, 0xff, 0xff, 0xff, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0xff, 0xff, 0xff, 0xff, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+static unsigned char icon_minus[]={
+ 0x18, 0x00, 0x18, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0xff, 0xff, 0xff, 0xff, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0xff, 0xff, 0xff, 0xff, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+static unsigned char icon_power_button[]={
+ 0x18, 0x00, 0x18, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x03, 0x33, 0x33, 0x3f, 0xf3, 0x33, 0x33, 0x30, 0x00, 0x00,
+ 0x00, 0x00, 0x33, 0x33, 0x33, 0x3f, 0xf3, 0x33, 0x33, 0x33, 0x00, 0x00,
+ 0x00, 0x33, 0x33, 0x33, 0xf3, 0x3f, 0xf3, 0x3f, 0x33, 0x33, 0x33, 0x00,
+ 0x03, 0x33, 0x33, 0x3f, 0xf3, 0x3f, 0xf3, 0x3f, 0xf3, 0x33, 0x33, 0x30,
+ 0x03, 0x33, 0x33, 0xff, 0xf3, 0x3f, 0xf3, 0x3f, 0xff, 0x33, 0x33, 0x30,
+ 0x33, 0x33, 0x3f, 0xff, 0x33, 0x33, 0x33, 0x33, 0xff, 0xf3, 0x33, 0x33,
+ 0x33, 0x33, 0x3f, 0xf3, 0x33, 0x33, 0x33, 0x33, 0x3f, 0xf3, 0x33, 0x33,
+ 0x33, 0x33, 0x3f, 0xf3, 0x33, 0x33, 0x33, 0x33, 0x3f, 0xf3, 0x33, 0x33,
+ 0x33, 0x33, 0x3f, 0xf3, 0x33, 0x33, 0x33, 0x33, 0x3f, 0xf3, 0x33, 0x33,
+ 0x33, 0x33, 0x3f, 0xf3, 0x33, 0x33, 0x33, 0x33, 0x3f, 0xf3, 0x33, 0x33,
+ 0x33, 0x33, 0x3f, 0xff, 0x33, 0x33, 0x33, 0x33, 0xff, 0xf3, 0x33, 0x33,
+ 0x03, 0x33, 0x33, 0xff, 0xf3, 0x33, 0x33, 0x3f, 0xff, 0x33, 0x33, 0x30,
+ 0x03, 0x33, 0x33, 0x3f, 0xff, 0x33, 0x33, 0xff, 0xf3, 0x33, 0x33, 0x30,
+ 0x00, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0x33, 0x33, 0x33, 0x00,
+ 0x00, 0x00, 0x33, 0x33, 0x3f, 0xff, 0xff, 0xf3, 0x33, 0x33, 0x00, 0x00,
+ 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+static unsigned char icon_help[]={
+ 0x18, 0x00, 0x18, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0xff, 0xff, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x80,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0xff, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+static unsigned char icon_info[]={
+ 0x18, 0x00, 0x18, 0x00, 0x0d,
+ 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
+ 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0x8d, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
+ 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xd0, 0x08, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
+ 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0x0f, 0xb0, 0x8d, 0xdd, 0xdd, 0xdd, 0xdd,
+ 0xdd, 0xdd, 0xdd, 0xdd, 0xd0, 0xfb, 0xfb, 0x08, 0xdd, 0xdd, 0xdd, 0xdd,
+ 0xdd, 0xdd, 0xdd, 0xdd, 0x0f, 0xbf, 0xbf, 0xb0, 0x8d, 0xdd, 0xdd, 0xdd,
+ 0xdd, 0xdd, 0xdd, 0xd0, 0xfb, 0xfb, 0xfb, 0xfb, 0x08, 0xdd, 0xdd, 0xdd,
+ 0xdd, 0xdd, 0xdd, 0x0f, 0xbf, 0x44, 0x44, 0xbf, 0xb0, 0x8d, 0xdd, 0xdd,
+ 0xdd, 0xdd, 0xd0, 0xfb, 0xfb, 0x44, 0x44, 0xfb, 0xf7, 0x08, 0xdd, 0xdd,
+ 0xdd, 0xdd, 0x0f, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xb0, 0x8d, 0xdd,
+ 0xdd, 0xd0, 0xfb, 0xfb, 0xfb, 0xfb, 0xfb, 0xfb, 0xfb, 0xfb, 0x08, 0xdd,
+ 0xdd, 0x0f, 0xbf, 0xbf, 0xbf, 0x44, 0x44, 0xbf, 0xbf, 0xbf, 0xb0, 0x8d,
+ 0xd0, 0xfb, 0xfb, 0xfb, 0xfb, 0x44, 0x44, 0xfb, 0xfb, 0xfb, 0xfb, 0x08,
+ 0xd8, 0x0f, 0xbf, 0xbf, 0xbf, 0x44, 0x44, 0xbf, 0xbf, 0xbf, 0xb0, 0x8d,
+ 0xdd, 0x80, 0xfb, 0xfb, 0xfb, 0x44, 0x44, 0xfb, 0xfb, 0xfb, 0x08, 0xdd,
+ 0xdd, 0xd8, 0x0f, 0xbf, 0xbf, 0x44, 0x44, 0xbf, 0xbf, 0xb0, 0x8d, 0xdd,
+ 0xdd, 0xdd, 0x80, 0xfb, 0xfb, 0x44, 0x44, 0xfb, 0xfb, 0x08, 0xdd, 0xdd,
+ 0xdd, 0xdd, 0xd8, 0x0f, 0xbf, 0x44, 0x44, 0xbf, 0xb0, 0x8d, 0xdd, 0xdd,
+ 0xdd, 0xdd, 0xdd, 0x80, 0xfb, 0xfb, 0xfb, 0xfb, 0x08, 0xdd, 0xdd, 0xdd,
+ 0xdd, 0xdd, 0xdd, 0xd8, 0x0f, 0xbf, 0xbf, 0xb0, 0x8d, 0xdd, 0xdd, 0xdd,
+ 0xdd, 0xdd, 0xdd, 0xdd, 0x80, 0xfb, 0xfb, 0x08, 0xdd, 0xdd, 0xdd, 0xdd,
+ 0xdd, 0xdd, 0xdd, 0xdd, 0xd8, 0x0f, 0xb0, 0x8d, 0xdd, 0xdd, 0xdd, 0xdd,
+ 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0x80, 0x08, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
+ 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xd8, 0x8d, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd };
+
+static unsigned char icon_mute_small[]={
+ 0x18, 0x00, 0x18, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x00,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0xf8, 0xf8, 0xf8, 0x88, 0xf8, 0x88, 0x80,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0x88, 0xf8, 0x8f, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0xff, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0xff, 0xf8, 0xf8, 0x8f, 0xff, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0xff, 0xf8, 0xf8, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0xff, 0xf8, 0xf8, 0x8f, 0xff, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0xff, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0x88, 0x88, 0x88,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x8f, 0x88, 0xf8, 0x8f, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0xf8, 0xf8, 0xf8, 0x88, 0xf8, 0x88, 0x80,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+static unsigned char icon_up[]={
+ 0x18, 0x00, 0x18, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0xff, 0xff, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x8f, 0xff, 0xff, 0xf8, 0x88, 0x88, 0x88, 0x80,
+ 0x88, 0x88, 0x88, 0x88, 0xff, 0xff, 0xff, 0xff, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+static unsigned char icon_down[]={
+ 0x18, 0x00, 0x18, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0xff, 0xff, 0xff, 0xff, 0x88, 0x88, 0x88, 0x88,
+ 0x08, 0x88, 0x88, 0x88, 0x8f, 0xff, 0xff, 0xf8, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0xff, 0xff, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+static unsigned char icon_left[]={
+ 0x18, 0x00, 0x18, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x88, 0x88, 0x88, 0x88, 0xff, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x8f, 0xff, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0xff, 0xff, 0xff, 0xff, 0xff, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0xff, 0xff, 0xff, 0xff, 0xff, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x8f, 0xff, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0xff, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x08, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+static unsigned char icon_right[]={
+ 0x18, 0x00, 0x18, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x80,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xff, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xff, 0xf8, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0xff, 0xff, 0xff, 0xff, 0xff, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0xff, 0xff, 0xff, 0xff, 0xff, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xff, 0xf8, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xff, 0x88, 0x88, 0x88, 0x88,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0xf8, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x8f, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+static unsigned char icon_lock[]={
+ 0x18, 0x00, 0x18, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0xbb, 0xbb, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x0b, 0xbb, 0xbb, 0xbb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x0b, 0xbb, 0xbb, 0xbb, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0x00,
+ 0xbb, 0x00, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xb0,
+ 0xbb, 0x00, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xb0,
+ 0xbb, 0x00, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0x00,
+ 0xbb, 0xbb, 0xbb, 0xbb, 0xb0, 0xbb, 0xb0, 0x00, 0xbb, 0xb0, 0xb0, 0x00,
+ 0x0b, 0xbb, 0xbb, 0xbb, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x0b, 0xbb, 0xbb, 0xbb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0xbb, 0xbb, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+#ifdef NOT_USED_NOW
+static unsigned char icon_dbox[]={
+ 0x18, 0x00, 0x18, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0xf8, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x88, 0x88, 0x88, 0xf8, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0xff, 0xf8, 0xff, 0xf8, 0x88, 0xff, 0x88, 0xf8, 0xf8, 0x88,
+ 0x88, 0x8f, 0x88, 0xf8, 0xf8, 0x8f, 0x8f, 0x88, 0xf8, 0x8f, 0x88, 0x88,
+ 0x88, 0x8f, 0x88, 0xf8, 0xf8, 0x8f, 0x8f, 0x88, 0xf8, 0x8f, 0x88, 0x88,
+ 0x88, 0x88, 0xff, 0xf8, 0xff, 0xf8, 0x88, 0xff, 0x88, 0xf8, 0xf8, 0x88,
+ 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+static unsigned char icon_ok[]={
+ 0x18, 0x00, 0x18, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0xff, 0xff, 0xf8, 0x8f, 0xf8, 0x8f, 0xf8, 0x88, 0x80,
+ 0x88, 0x88, 0x8f, 0xf8, 0x88, 0xff, 0x8f, 0xf8, 0xff, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x8f, 0xf8, 0x88, 0xff, 0x8f, 0xff, 0xf8, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x8f, 0xf8, 0x88, 0xff, 0x8f, 0xff, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x8f, 0xf8, 0x88, 0xff, 0x8f, 0xff, 0xf8, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x8f, 0xf8, 0x88, 0xff, 0x8f, 0xf8, 0xff, 0x88, 0x88, 0x88,
+ 0x88, 0x88, 0x88, 0xff, 0xff, 0xf8, 0x8f, 0xf8, 0x8f, 0xf8, 0x88, 0x88,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+ #endif
+
+#if (!defined(MPCSMON_DREAM_PPC)) && (!defined(MPCSMON_DREAM_7025))
+static unsigned char icon_home[]={
+ 0x18, 0x00, 0x18, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x88, 0x8f, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x8f, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
+ 0x88, 0x8f, 0xff, 0xf8, 0x8f, 0xf8, 0x8f, 0xff, 0xf8, 0x88, 0xf8, 0x88,
+ 0x88, 0x8f, 0x88, 0xf8, 0xf8, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x88,
+ 0x88, 0x8f, 0x88, 0xf8, 0xf8, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x88, 0x88,
+ 0x88, 0x8f, 0x88, 0xf8, 0x8f, 0xf8, 0x8f, 0x8f, 0x8f, 0x88, 0xff, 0x88,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80,
+ 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00,
+ 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00,
+ 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+#endif
+
+static unsigned char icon_lame[]={
+ 0x18, 0x00, 0x18, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x01, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0x00, 0x00,
+ 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00,
+ 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00,
+ 0x01, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10,
+ 0x01, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10,
+ 0x11, 0xf1, 0x11, 0x11, 0xff, 0x11, 0xf1, 0x11, 0xf1, 0xff, 0xff, 0x11,
+ 0x11, 0xf1, 0x11, 0x1f, 0x11, 0xf1, 0xff, 0x1f, 0xf1, 0xf1, 0x11, 0x11,
+ 0x11, 0xf1, 0x11, 0x1f, 0x11, 0xf1, 0xf1, 0xf1, 0xf1, 0xff, 0xf1, 0x11,
+ 0x11, 0xf1, 0x11, 0x1f, 0xff, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0x11, 0x11,
+ 0x11, 0xf1, 0x11, 0x1f, 0x11, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0x11, 0x11,
+ 0x11, 0xff, 0xff, 0x1f, 0x11, 0xf1, 0xf1, 0xf1, 0xf1, 0xff, 0xff, 0x11,
+ 0x01, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10,
+ 0x01, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10,
+ 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00,
+ 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00,
+ 0x00, 0x00, 0x01, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
diff -ruN oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/Makefile.am oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/Makefile.am
--- oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/Makefile.am	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/Makefile.am	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,17 @@
+AM_CPPFLAGS = @FREETYPE_CFLAGS@ -I$(top_srcdir)/include
+
+noinst_LTLIBRARIES = mpcsmon.la
+
+mpcsmon_la_SOURCES = mpcsmon.c
+
+mpcsmon_la_LIBADD = @FREETYPE_LIBS@
+
+mpcsmon_la_LDFLAGS = -rpath $(PLUGINDIR) -module -avoid-version
+
+install-exec-local:
+	install -d $(DESTDIR)$(PLUGINDIR)
+	install -d $(DESTDIR)$(CONFIGDIR)
+	install -d $(DESTDIR)$(CONFIGDIR)/mpcsmon
+	$(LIBTOOL) --mode=install install mpcsmon.la $(DESTDIR)$(PLUGINDIR)
+	install -m 0644 $(srcdir)/mpcsmon.cfg $(DESTDIR)$(PLUGINDIR)
+	install -m 0644 $(srcdir)/mpcsmon.conf $(DESTDIR)$(CONFIGDIR)/mpcsmon.conf
diff -ruN oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/Makefile.in oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/Makefile.in
--- oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/Makefile.in	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/Makefile.in	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,366 @@
+# Makefile.in generated automatically by automake 1.4-p4 from Makefile.am
+
+# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+SHELL = @SHELL@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+
+bindir = @bindir@
+sbindir = @sbindir@
+libexecdir = @libexecdir@
+datadir = @datadir@
+sysconfdir = @sysconfdir@
+sharedstatedir = @sharedstatedir@
+localstatedir = @localstatedir@
+libdir = @libdir@
+infodir = @infodir@
+mandir = @mandir@
+includedir = @includedir@
+oldincludedir = /usr/include
+
+DESTDIR =
+
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+
+top_builddir = ..
+
+ACLOCAL = @ACLOCAL@
+AUTOCONF = @AUTOCONF@
+AUTOMAKE = @AUTOMAKE@
+AUTOHEADER = @AUTOHEADER@
+
+INSTALL = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@ $(AM_INSTALL_PROGRAM_FLAGS)
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+transform = @program_transform_name@
+
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_alias = @host_alias@
+host_triplet = @host@
+AS = @AS@
+CATALOGS = @CATALOGS@
+CC = @CC@
+CONFIGDIR = @CONFIGDIR@
+CXX = @CXX@
+DATADIR = @DATADIR@
+DLLTOOL = @DLLTOOL@
+DRIVER = @DRIVER@
+DUMMYPOFILES = @DUMMYPOFILES@
+ECHO = @ECHO@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FONTDIR = @FONTDIR@
+GAMESDIR = @GAMESDIR@
+GMOFILES = @GMOFILES@
+GMSGFMT = @GMSGFMT@
+LIBDIR = @LIBDIR@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MSGFMT = @MSGFMT@
+MSGMERGE = @MSGMERGE@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PKG_CONFIG = @PKG_CONFIG@
+PLUGINDIR = @PLUGINDIR@
+POFILES = @POFILES@
+RANLIB = @RANLIB@
+STRIP = @STRIP@
+TARGET_ = @TARGET_@
+UCODEDIR = @UCODEDIR@
+UPDATEPOFILES = @UPDATEPOFILES@
+USE_NLS = @USE_NLS@
+VERSION = @VERSION@
+XGETTEXT = @XGETTEXT@
+
+AM_CPPFLAGS = @FREETYPE_CFLAGS@ -I$(top_srcdir)/include
+
+noinst_LTLIBRARIES = mpcsmon.la
+
+mpcsmon_la_SOURCES = mpcsmon.c
+
+mpcsmon_la_LIBADD = @FREETYPE_LIBS@
+
+mpcsmon_la_LDFLAGS = -rpath $(PLUGINDIR) -module -avoid-version
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = ../config.h
+CONFIG_CLEAN_FILES = 
+LTLIBRARIES =  $(noinst_LTLIBRARIES)
+
+
+DEFS = @DEFS@ -I. -I$(srcdir) -I..
+CPPFLAGS = @CPPFLAGS@
+LDFLAGS = @LDFLAGS@
+LIBS = @LIBS@
+mpcsmon_la_DEPENDENCIES = 
+mpcsmon_la_OBJECTS =  mpcsmon.lo
+CFLAGS = @CFLAGS@
+COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@
+DIST_COMMON =  Makefile.am Makefile.in
+
+
+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
+
+TAR = tar
+GZIP_ENV = --best
+DEP_FILES =  .deps/mpcsmon.P
+SOURCES = $(mpcsmon_la_SOURCES)
+OBJECTS = $(mpcsmon_la_OBJECTS)
+
+all: all-redirect
+.SUFFIXES:
+.SUFFIXES: .S .c .lo .o .obj .s
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ Makefile.am $(top_srcdir)/configure.ac $(ACLOCAL_M4) 
+	cd $(top_srcdir) && $(AUTOMAKE) --gnu mpcsmon/Makefile
+
+Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status $(BUILT_SOURCES)
+	cd $(top_builddir) \
+	  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status
+
+
+mostlyclean-noinstLTLIBRARIES:
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+
+distclean-noinstLTLIBRARIES:
+
+maintainer-clean-noinstLTLIBRARIES:
+
+# FIXME: We should only use cygpath when building on Windows,
+# and only if it is available.
+.c.obj:
+	$(COMPILE) -c `cygpath -w $<`
+
+.s.o:
+	$(COMPILE) -c $<
+
+.S.o:
+	$(COMPILE) -c $<
+
+mostlyclean-compile:
+	-rm -f *.o core *.core
+	-rm -f *.$(OBJEXT)
+
+clean-compile:
+
+distclean-compile:
+	-rm -f *.tab.c
+
+maintainer-clean-compile:
+
+.s.lo:
+	$(LIBTOOL) --mode=compile $(COMPILE) -c $<
+
+.S.lo:
+	$(LIBTOOL) --mode=compile $(COMPILE) -c $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+
+maintainer-clean-libtool:
+
+mpcsmon.la: $(mpcsmon_la_OBJECTS) $(mpcsmon_la_DEPENDENCIES)
+	$(LINK)  $(mpcsmon_la_LDFLAGS) $(mpcsmon_la_OBJECTS) $(mpcsmon_la_LIBADD) $(LIBS)
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS)'; \
+	unique=`for i in $$list; do echo $$i; done | \
+	  awk '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	here=`pwd` && cd $(srcdir) \
+	  && mkid -f$$here/ID $$unique $(LISP)
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)'; \
+	unique=`for i in $$list; do echo $$i; done | \
+	  awk '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$unique$(LISP)$$tags" \
+	  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags  $$unique $(LISP) -o $$here/TAGS)
+
+mostlyclean-tags:
+
+clean-tags:
+
+distclean-tags:
+	-rm -f TAGS ID
+
+maintainer-clean-tags:
+
+distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
+
+subdir = mpcsmon
+
+distdir: $(DISTFILES)
+	here=`cd $(top_builddir) && pwd`; \
+	top_distdir=`cd $(top_distdir) && pwd`; \
+	distdir=`cd $(distdir) && pwd`; \
+	cd $(top_srcdir) \
+	  && $(AUTOMAKE) --include-deps --build-dir=$$here --srcdir-name=$(top_srcdir) --output-dir=$$top_distdir --gnu mpcsmon/Makefile
+	@for file in $(DISTFILES); do \
+	  d=$(srcdir); \
+	  if test -d $$d/$$file; then \
+	    cp -pr $$d/$$file $(distdir)/$$file; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
+	    || cp -p $$d/$$file $(distdir)/$$file || :; \
+	  fi; \
+	done
+
+DEPS_MAGIC := $(shell mkdir .deps > /dev/null 2>&1 || :)
+
+-include $(DEP_FILES)
+
+mostlyclean-depend:
+
+clean-depend:
+
+distclean-depend:
+	-rm -rf .deps
+
+maintainer-clean-depend:
+
+%.o: %.c
+	@echo '$(COMPILE) -c $<'; \
+	$(COMPILE) -Wp,-MD,.deps/$(*F).pp -c $<
+	@-cp .deps/$(*F).pp .deps/$(*F).P; \
+	tr ' ' '\012' < .deps/$(*F).pp \
+	  | sed -e 's/^\\$$//' -e '/^$$/ d' -e '/:$$/ d' -e 's/$$/ :/' \
+	    >> .deps/$(*F).P; \
+	rm .deps/$(*F).pp
+
+%.lo: %.c
+	@echo '$(LTCOMPILE) -c $<'; \
+	$(LTCOMPILE) -Wp,-MD,.deps/$(*F).pp -c $<
+	@-sed -e 's/^\([^:]*\)\.o[ 	]*:/\1.lo \1.o :/' \
+	  < .deps/$(*F).pp > .deps/$(*F).P; \
+	tr ' ' '\012' < .deps/$(*F).pp \
+	  | sed -e 's/^\\$$//' -e '/^$$/ d' -e '/:$$/ d' -e 's/$$/ :/' \
+	    >> .deps/$(*F).P; \
+	rm -f .deps/$(*F).pp
+info-am:
+info: info-am
+dvi-am:
+dvi: dvi-am
+check-am: all-am
+check: check-am
+installcheck-am:
+installcheck: installcheck-am
+install-exec-am: install-exec-local
+install-exec: install-exec-am
+
+install-data-am:
+install-data: install-data-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+install: install-am
+uninstall-am:
+uninstall: uninstall-am
+all-am: Makefile $(LTLIBRARIES)
+all-redirect: all-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) AM_INSTALL_PROGRAM_FLAGS=-s install
+installdirs:
+
+
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-rm -f config.cache config.log stamp-h stamp-h[0-9]*
+
+maintainer-clean-generic:
+mostlyclean-am:  mostlyclean-noinstLTLIBRARIES mostlyclean-compile \
+		mostlyclean-libtool mostlyclean-tags mostlyclean-depend \
+		mostlyclean-generic
+
+mostlyclean: mostlyclean-am
+
+clean-am:  clean-noinstLTLIBRARIES clean-compile clean-libtool \
+		clean-tags clean-depend clean-generic mostlyclean-am
+
+clean: clean-am
+
+distclean-am:  distclean-noinstLTLIBRARIES distclean-compile \
+		distclean-libtool distclean-tags distclean-depend \
+		distclean-generic clean-am
+	-rm -f libtool
+
+distclean: distclean-am
+
+maintainer-clean-am:  maintainer-clean-noinstLTLIBRARIES \
+		maintainer-clean-compile maintainer-clean-libtool \
+		maintainer-clean-tags maintainer-clean-depend \
+		maintainer-clean-generic distclean-am
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+
+maintainer-clean: maintainer-clean-am
+
+.PHONY: mostlyclean-noinstLTLIBRARIES distclean-noinstLTLIBRARIES \
+clean-noinstLTLIBRARIES maintainer-clean-noinstLTLIBRARIES \
+mostlyclean-compile distclean-compile clean-compile \
+maintainer-clean-compile mostlyclean-libtool distclean-libtool \
+clean-libtool maintainer-clean-libtool tags mostlyclean-tags \
+distclean-tags clean-tags maintainer-clean-tags distdir \
+mostlyclean-depend distclean-depend clean-depend \
+maintainer-clean-depend info-am info dvi-am dvi check check-am \
+installcheck-am installcheck install-exec-local install-exec-am \
+install-exec install-data-am install-data install-am install \
+uninstall-am uninstall all-redirect all-am all installdirs \
+mostlyclean-generic distclean-generic clean-generic \
+maintainer-clean-generic clean mostlyclean distclean maintainer-clean
+
+
+install-exec-local:
+	install -d $(DESTDIR)$(PLUGINDIR)
+	install -d $(DESTDIR)$(CONFIGDIR)
+	install -d $(DESTDIR)$(CONFIGDIR)/mpcsmon
+	$(LIBTOOL) --mode=install install mpcsmon.la $(DESTDIR)$(PLUGINDIR)
+	install -m 0644 $(srcdir)/mpcsmon.cfg $(DESTDIR)$(PLUGINDIR)
+	install -m 0644 $(srcdir)/mpcsmon.conf $(DESTDIR)$(CONFIGDIR)/mpcsmon.conf
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -ruN oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/md5.c oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/md5.c
--- oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/md5.c	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/md5.c	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,413 @@
+/* md5.c - Functions to compute MD5 message digest of files or memory blocks
+   according to the definition of MD5 in RFC 1321 from April 1992.
+   Copyright (C) 1995, 1996 Free Software Foundation, Inc.
+   NOTE: The canonical source of this file is maintained with the GNU C
+   Library.  Bugs can be reported to bug-glibc@prep.ai.mit.edu.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2, or (at your option) any
+   later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <sys/types.h>
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "md5.h"
+
+#ifdef HAVE_ENDIAN_H
+# include <endian.h>
+# if __BYTE_ORDER == __BIG_ENDIAN
+#  define WORDS_BIGENDIAN 1
+# endif
+#endif
+
+#ifdef WORDS_BIGENDIAN
+# define SWAP(n)							\
+    (((n) << 24) | (((n) & 0xff00) << 8) | (((n) >> 8) & 0xff00) | ((n) >> 24))
+#else
+# define SWAP(n) (n)
+#endif
+
+
+/* This array contains the bytes used to pad the buffer to the next
+   64-byte boundary.  (RFC 1321, 3.1: Step 1)  */
+static const unsigned char fillbuf[64] = { 0x80, 0 /* , 0, 0, ...  */ };
+
+
+/* Initialize structure containing state of computation.
+   (RFC 1321, 3.3: Step 3)  */
+void
+md5_init_ctx (ctx)
+     struct md5_ctx *ctx;
+{
+  ctx->A = 0x67452301;
+  ctx->B = 0xefcdab89;
+  ctx->C = 0x98badcfe;
+  ctx->D = 0x10325476;
+
+  ctx->total[0] = ctx->total[1] = 0;
+  ctx->buflen = 0;
+}
+
+/* Put result from CTX in first 16 bytes following RESBUF.  The result
+   must be in little endian byte order.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32 bits value.  */
+void *
+md5_read_ctx (ctx, resbuf)
+     const struct md5_ctx *ctx;
+     void *resbuf;
+{
+  ((md5_uint32 *) resbuf)[0] = SWAP (ctx->A);
+  ((md5_uint32 *) resbuf)[1] = SWAP (ctx->B);
+  ((md5_uint32 *) resbuf)[2] = SWAP (ctx->C);
+  ((md5_uint32 *) resbuf)[3] = SWAP (ctx->D);
+
+  return resbuf;
+}
+
+/* Process the remaining bytes in the internal buffer and the usual
+   prolog according to the standard and write the result to RESBUF.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32 bits value.  */
+void *
+md5_finish_ctx (ctx, resbuf)
+     struct md5_ctx *ctx;
+     void *resbuf;
+{
+  /* Take yet unprocessed bytes into account.  */
+  md5_uint32 bytes = ctx->buflen;
+  size_t pad;
+
+  /* Now count remaining bytes.  */
+  ctx->total[0] += bytes;
+  if (ctx->total[0] < bytes)
+    ++ctx->total[1];
+
+  pad = bytes >= 56 ? 64 + 56 - bytes : 56 - bytes;
+  memcpy (&ctx->buffer[bytes], fillbuf, pad);
+
+  /* Put the 64-bit file length in *bits* at the end of the buffer.  */
+  *(md5_uint32 *) &ctx->buffer[bytes + pad] = SWAP (ctx->total[0] << 3);
+  *(md5_uint32 *) &ctx->buffer[bytes + pad + 4] = SWAP ((ctx->total[1] << 3) |
+							(ctx->total[0] >> 29));
+
+  /* Process last bytes.  */
+  md5_process_block (ctx->buffer, bytes + pad + 8, ctx);
+
+  return md5_read_ctx (ctx, resbuf);
+}
+
+/* Compute MD5 message digest for bytes read from STREAM.  The
+   resulting message digest number will be written into the 16 bytes
+   beginning at RESBLOCK.  */
+int
+md5_stream (stream, resblock)
+     FILE *stream;
+     void *resblock;
+{
+  /* Important: BLOCKSIZE must be a multiple of 64.  */
+#define BLOCKSIZE 4096
+  struct md5_ctx ctx;
+  char buffer[BLOCKSIZE + 72];
+  size_t sum;
+
+  /* Initialize the computation context.  */
+  md5_init_ctx (&ctx);
+
+  /* Iterate over full file contents.  */
+  while (1)
+    {
+      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the
+	 computation function processes the whole buffer so that with the
+	 next round of the loop another block can be read.  */
+      size_t n;
+      sum = 0;
+
+      /* Read block.  Take care for partial reads.  */
+      do
+	{
+	  n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);
+
+	  sum += n;
+	}
+      while (sum < BLOCKSIZE && n != 0);
+      if (n == 0 && ferror (stream))
+        return 1;
+
+      /* If end of file is reached, end the loop.  */
+      if (n == 0)
+	break;
+
+      /* Process buffer with BLOCKSIZE bytes.  Note that
+			BLOCKSIZE % 64 == 0
+       */
+      md5_process_block (buffer, BLOCKSIZE, &ctx);
+    }
+
+  /* Add the last bytes if necessary.  */
+  if (sum > 0)
+    md5_process_bytes (buffer, sum, &ctx);
+
+  /* Construct result in desired memory.  */
+  md5_finish_ctx (&ctx, resblock);
+  return 0;
+}
+
+/* Compute MD5 message digest for LEN bytes beginning at BUFFER.  The
+   result is always in little endian byte order, so that a byte-wise
+   output yields to the wanted ASCII representation of the message
+   digest.  */
+void *
+md5_buffer (buffer, len, resblock)
+     const char *buffer;
+     size_t len;
+     void *resblock;
+{
+  struct md5_ctx ctx;
+
+  /* Initialize the computation context.  */
+  md5_init_ctx (&ctx);
+
+  /* Process whole buffer but last len % 64 bytes.  */
+  md5_process_bytes (buffer, len, &ctx);
+
+  /* Put result in desired memory area.  */
+  return md5_finish_ctx (&ctx, resblock);
+}
+
+
+void
+md5_process_bytes (buffer, len, ctx)
+     const void *buffer;
+     size_t len;
+     struct md5_ctx *ctx;
+{
+  /* When we already have some bits in our internal buffer concatenate
+     both inputs first.  */
+  if (ctx->buflen != 0)
+    {
+      size_t left_over = ctx->buflen;
+      size_t add = 128 - left_over > len ? len : 128 - left_over;
+
+      memcpy (&ctx->buffer[left_over], buffer, add);
+      ctx->buflen += add;
+
+      if (left_over + add > 64)
+	{
+	  md5_process_block (ctx->buffer, (left_over + add) & ~63, ctx);
+	  /* The regions in the following copy operation cannot overlap.  */
+	  memcpy (ctx->buffer, &ctx->buffer[(left_over + add) & ~63],
+		  (left_over + add) & 63);
+	  ctx->buflen = (left_over + add) & 63;
+	}
+
+      buffer = (const char *) buffer + add;
+      len -= add;
+    }
+
+  /* Process available complete blocks.  */
+  if (len > 64)
+    {
+      md5_process_block (buffer, len & ~63, ctx);
+      buffer = (const char *) buffer + (len & ~63);
+      len &= 63;
+    }
+
+  /* Move remaining bytes in internal buffer.  */
+  if (len > 0)
+    {
+      memcpy (ctx->buffer, buffer, len);
+      ctx->buflen = len;
+    }
+}
+
+
+/* These are the four functions used in the four steps of the MD5 algorithm
+   and defined in the RFC 1321.  The first function is a little bit optimized
+   (as found in Colin Plumbs public domain implementation).  */
+/* #define FF(b, c, d) ((b & c) | (~b & d)) */
+#define FF(b, c, d) (d ^ (b & (c ^ d)))
+#define FG(b, c, d) FF (d, b, c)
+#define FH(b, c, d) (b ^ c ^ d)
+#define FI(b, c, d) (c ^ (b | ~d))
+
+/* Process LEN bytes of BUFFER, accumulating context into CTX.
+   It is assumed that LEN % 64 == 0.  */
+
+void
+md5_process_block (buffer, len, ctx)
+     const void *buffer;
+     size_t len;
+     struct md5_ctx *ctx;
+{
+  md5_uint32 correct_words[16];
+  const md5_uint32 *words = buffer;
+  size_t nwords = len / sizeof (md5_uint32);
+  const md5_uint32 *endp = words + nwords;
+  md5_uint32 A = ctx->A;
+  md5_uint32 B = ctx->B;
+  md5_uint32 C = ctx->C;
+  md5_uint32 D = ctx->D;
+
+  /* First increment the byte count.  RFC 1321 specifies the possible
+     length of the file up to 2^64 bits.  Here we only compute the
+     number of bytes.  Do a double word increment.  */
+  ctx->total[0] += len;
+  if (ctx->total[0] < len)
+    ++ctx->total[1];
+
+  /* Process all bytes in the buffer with 64 bytes in each round of
+     the loop.  */
+  while (words < endp)
+    {
+      md5_uint32 *cwp = correct_words;
+      md5_uint32 A_save = A;
+      md5_uint32 B_save = B;
+      md5_uint32 C_save = C;
+      md5_uint32 D_save = D;
+
+      /* First round: using the given function, the context and a constant
+	 the next context is computed.  Because the algorithms processing
+	 unit is a 32-bit word and it is determined to work on words in
+	 little endian byte order we perhaps have to change the byte order
+	 before the computation.  To reduce the work for the next steps
+	 we store the swapped words in the array CORRECT_WORDS.  */
+
+#define OP(a, b, c, d, s, T)						\
+      do								\
+        {								\
+	  a += FF (b, c, d) + (*cwp++ = SWAP (*words)) + T;		\
+	  ++words;							\
+	  CYCLIC (a, s);						\
+	  a += b;							\
+        }								\
+      while (0)
+
+      /* It is unfortunate that C does not provide an operator for
+	 cyclic rotation.  Hope the C compiler is smart enough.  */
+#define CYCLIC(w, s) (w = (w << s) | (w >> (32 - s)))
+
+      /* Before we start, one word to the strange constants.
+	 They are defined in RFC 1321 as
+
+	 T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64
+       */
+
+      /* Round 1.  */
+      OP (A, B, C, D,  7, 0xd76aa478);
+      OP (D, A, B, C, 12, 0xe8c7b756);
+      OP (C, D, A, B, 17, 0x242070db);
+      OP (B, C, D, A, 22, 0xc1bdceee);
+      OP (A, B, C, D,  7, 0xf57c0faf);
+      OP (D, A, B, C, 12, 0x4787c62a);
+      OP (C, D, A, B, 17, 0xa8304613);
+      OP (B, C, D, A, 22, 0xfd469501);
+      OP (A, B, C, D,  7, 0x698098d8);
+      OP (D, A, B, C, 12, 0x8b44f7af);
+      OP (C, D, A, B, 17, 0xffff5bb1);
+      OP (B, C, D, A, 22, 0x895cd7be);
+      OP (A, B, C, D,  7, 0x6b901122);
+      OP (D, A, B, C, 12, 0xfd987193);
+      OP (C, D, A, B, 17, 0xa679438e);
+      OP (B, C, D, A, 22, 0x49b40821);
+
+      /* For the second to fourth round we have the possibly swapped words
+	 in CORRECT_WORDS.  Redefine the macro to take an additional first
+	 argument specifying the function to use.  */
+#undef OP
+#define OP(f, a, b, c, d, k, s, T)					\
+      do 								\
+	{								\
+	  a += f (b, c, d) + correct_words[k] + T;			\
+	  CYCLIC (a, s);						\
+	  a += b;							\
+	}								\
+      while (0)
+
+      /* Round 2.  */
+      OP (FG, A, B, C, D,  1,  5, 0xf61e2562);
+      OP (FG, D, A, B, C,  6,  9, 0xc040b340);
+      OP (FG, C, D, A, B, 11, 14, 0x265e5a51);
+      OP (FG, B, C, D, A,  0, 20, 0xe9b6c7aa);
+      OP (FG, A, B, C, D,  5,  5, 0xd62f105d);
+      OP (FG, D, A, B, C, 10,  9, 0x02441453);
+      OP (FG, C, D, A, B, 15, 14, 0xd8a1e681);
+      OP (FG, B, C, D, A,  4, 20, 0xe7d3fbc8);
+      OP (FG, A, B, C, D,  9,  5, 0x21e1cde6);
+      OP (FG, D, A, B, C, 14,  9, 0xc33707d6);
+      OP (FG, C, D, A, B,  3, 14, 0xf4d50d87);
+      OP (FG, B, C, D, A,  8, 20, 0x455a14ed);
+      OP (FG, A, B, C, D, 13,  5, 0xa9e3e905);
+      OP (FG, D, A, B, C,  2,  9, 0xfcefa3f8);
+      OP (FG, C, D, A, B,  7, 14, 0x676f02d9);
+      OP (FG, B, C, D, A, 12, 20, 0x8d2a4c8a);
+
+      /* Round 3.  */
+      OP (FH, A, B, C, D,  5,  4, 0xfffa3942);
+      OP (FH, D, A, B, C,  8, 11, 0x8771f681);
+      OP (FH, C, D, A, B, 11, 16, 0x6d9d6122);
+      OP (FH, B, C, D, A, 14, 23, 0xfde5380c);
+      OP (FH, A, B, C, D,  1,  4, 0xa4beea44);
+      OP (FH, D, A, B, C,  4, 11, 0x4bdecfa9);
+      OP (FH, C, D, A, B,  7, 16, 0xf6bb4b60);
+      OP (FH, B, C, D, A, 10, 23, 0xbebfbc70);
+      OP (FH, A, B, C, D, 13,  4, 0x289b7ec6);
+      OP (FH, D, A, B, C,  0, 11, 0xeaa127fa);
+      OP (FH, C, D, A, B,  3, 16, 0xd4ef3085);
+      OP (FH, B, C, D, A,  6, 23, 0x04881d05);
+      OP (FH, A, B, C, D,  9,  4, 0xd9d4d039);
+      OP (FH, D, A, B, C, 12, 11, 0xe6db99e5);
+      OP (FH, C, D, A, B, 15, 16, 0x1fa27cf8);
+      OP (FH, B, C, D, A,  2, 23, 0xc4ac5665);
+
+      /* Round 4.  */
+      OP (FI, A, B, C, D,  0,  6, 0xf4292244);
+      OP (FI, D, A, B, C,  7, 10, 0x432aff97);
+      OP (FI, C, D, A, B, 14, 15, 0xab9423a7);
+      OP (FI, B, C, D, A,  5, 21, 0xfc93a039);
+      OP (FI, A, B, C, D, 12,  6, 0x655b59c3);
+      OP (FI, D, A, B, C,  3, 10, 0x8f0ccc92);
+      OP (FI, C, D, A, B, 10, 15, 0xffeff47d);
+      OP (FI, B, C, D, A,  1, 21, 0x85845dd1);
+      OP (FI, A, B, C, D,  8,  6, 0x6fa87e4f);
+      OP (FI, D, A, B, C, 15, 10, 0xfe2ce6e0);
+      OP (FI, C, D, A, B,  6, 15, 0xa3014314);
+      OP (FI, B, C, D, A, 13, 21, 0x4e0811a1);
+      OP (FI, A, B, C, D,  4,  6, 0xf7537e82);
+      OP (FI, D, A, B, C, 11, 10, 0xbd3af235);
+      OP (FI, C, D, A, B,  2, 15, 0x2ad7d2bb);
+      OP (FI, B, C, D, A,  9, 21, 0xeb86d391);
+
+      /* Add the starting values of the context.  */
+      A += A_save;
+      B += B_save;
+      C += C_save;
+      D += D_save;
+    }
+
+  /* Put checksum in context given as argument.  */
+  ctx->A = A;
+  ctx->B = B;
+  ctx->C = C;
+  ctx->D = D;
+}
diff -ruN oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/md5.h oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/md5.h
--- oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/md5.h	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/md5.h	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,146 @@
+/* md5.h - Declaration of functions and data types used for MD5 sum
+   computing library functions.
+   Copyright (C) 1995, 1996 Free Software Foundation, Inc.
+   NOTE: The canonical source of this file is maintained with the GNU C
+   Library.  Bugs can be reported to bug-glibc@prep.ai.mit.edu.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2, or (at your option) any
+   later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifndef _MD5_H
+#define _MD5_H 1
+
+#include <stdio.h>
+
+#if defined HAVE_LIMITS_H || _LIBC
+# include <limits.h>
+#endif
+
+/* The following contortions are an attempt to use the C preprocessor
+   to determine an unsigned integral type that is 32 bits wide.  An
+   alternative approach is to use autoconf's AC_CHECK_SIZEOF macro, but
+   doing that would require that the configure script compile and *run*
+   the resulting executable.  Locally running cross-compiled executables
+   is usually not possible.  */
+
+#ifdef _LIBC
+# include <sys/types.h>
+typedef u_int32_t md5_uint32;
+#else
+# if defined __STDC__ && __STDC__
+#  define UINT_MAX_32_BITS 4294967295U
+# else
+#  define UINT_MAX_32_BITS 0xFFFFFFFF
+# endif
+
+/* If UINT_MAX isn't defined, assume it's a 32-bit type.
+   This should be valid for all systems GNU cares about because
+   that doesn't include 16-bit systems, and only modern systems
+   (that certainly have <limits.h>) have 64+-bit integral types.  */
+
+# ifndef UINT_MAX
+#  define UINT_MAX UINT_MAX_32_BITS
+# endif
+
+# if UINT_MAX == UINT_MAX_32_BITS
+   typedef unsigned int md5_uint32;
+# else
+#  if USHRT_MAX == UINT_MAX_32_BITS
+    typedef unsigned short md5_uint32;
+#  else
+#   if ULONG_MAX == UINT_MAX_32_BITS
+     typedef unsigned long md5_uint32;
+#   else
+     /* The following line is intended to evoke an error.
+        Using #error is not portable enough.  */
+     "Cannot determine unsigned 32-bit data type."
+#   endif
+#  endif
+# endif
+#endif
+
+#undef __P
+#if defined (__STDC__) && __STDC__
+#define	__P(x) x
+#else
+#define	__P(x) ()
+#endif
+
+/* Structure to save state of computation between the single steps.  */
+struct md5_ctx
+{
+  md5_uint32 A;
+  md5_uint32 B;
+  md5_uint32 C;
+  md5_uint32 D;
+
+  md5_uint32 total[2];
+  md5_uint32 buflen;
+  char buffer[128];
+};
+
+/*
+ * The following three functions are build up the low level used in
+ * the functions `md5_stream' and `md5_buffer'.
+ */
+
+/* Initialize structure containing state of computation.
+   (RFC 1321, 3.3: Step 3)  */
+extern void md5_init_ctx __P ((struct md5_ctx *ctx));
+
+/* Starting with the result of former calls of this function (or the
+   initialization function update the context for the next LEN bytes
+   starting at BUFFER.
+   It is necessary that LEN is a multiple of 64!!! */
+extern void md5_process_block __P ((const void *buffer, size_t len,
+				    struct md5_ctx *ctx));
+
+/* Starting with the result of former calls of this function (or the
+   initialization function update the context for the next LEN bytes
+   starting at BUFFER.
+   It is NOT required that LEN is a multiple of 64.  */
+extern void md5_process_bytes __P ((const void *buffer, size_t len,
+				    struct md5_ctx *ctx));
+
+/* Process the remaining bytes in the buffer and put result from CTX
+   in first 16 bytes following RESBUF.  The result is always in little
+   endian byte order, so that a byte-wise output yields to the wanted
+   ASCII representation of the message digest.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32 bits value.  */
+extern void *md5_finish_ctx __P ((struct md5_ctx *ctx, void *resbuf));
+
+
+/* Put result from CTX in first 16 bytes following RESBUF.  The result is
+   always in little endian byte order, so that a byte-wise output yields
+   to the wanted ASCII representation of the message digest.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32 bits value.  */
+extern void *md5_read_ctx __P ((const struct md5_ctx *ctx, void *resbuf));
+
+
+/* Compute MD5 message digest for bytes read from STREAM.  The
+   resulting message digest number will be written into the 16 bytes
+   beginning at RESBLOCK.  */
+extern int md5_stream __P ((FILE *stream, void *resblock));
+
+/* Compute MD5 message digest for LEN bytes beginning at BUFFER.  The
+   result is always in little endian byte order, so that a byte-wise
+   output yields to the wanted ASCII representation of the message
+   digest.  */
+extern void *md5_buffer __P ((const char *buffer, size_t len, void *resblock));
+
+#endif
diff -ruN oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/mpcsmon.c oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/mpcsmon.c
--- oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/mpcsmon.c	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/mpcsmon.c	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,1653 @@
+#include "mpcsmon.h"
+
+#ifdef MPCSMON_DREAM_7025
+
+#include "aes_core.c"
+#include "crc32.c"
+#include "md5.c"
+
+#else	// MPCSMON_DREAM_7025
+
+#include <tuxbox/libmd5sum.h>
+extern void *md5_buffer(const char *, size_t, void *);
+
+//
+//	using the libcrypto will save about 16kb.
+//	if you like to use libcrypto change the define below to undef.
+//	in addition to the define you have to change the Makefile.am.
+//	change
+//		mpcsmon_la_LIBADD = @FREETYPE_LIBS@
+//	into
+//		mpcsmon_la_LIBADD = @FREETYPE_LIBS@ -lcrypto
+//
+#define BUILTIN_CRYPTO
+
+#ifdef BUILTIN_CRYPTO
+#  include "aes_core.c"
+#  include "crc32.c"
+#else
+#  include <openssl/aes.h>
+#  include <zlib.h>
+#endif
+
+#endif	// MPCSMON_DREAM_7025
+
+#define	MAXCLIENTS	48
+#define	MAXSERVER	8
+#define	MAXFIELDS	16
+#define	MAXFIELDSIZE	32
+
+#include "icons.inc"
+
+typedef	struct	s_server
+{
+	char 	*name;
+	char	*label;
+	char	*user;
+	char	*pwd;
+	uint16_t port;
+}	SERVER;
+
+static	FT_Library	library;
+static	FTC_Manager	manager;
+static	FTC_SBitCache	cache;
+static	FTC_SBit	sbit;
+#ifdef OLDFT
+static	FTC_ImageDesc	desc;
+#else
+static	FTC_ImageTypeRec desc;
+#endif
+static	FT_Face		face;
+static	FT_UInt		prev_glyphindex;
+static	FT_Bool		use_kerning;
+
+static	int		is_dbox=0;
+static	int		fb, rc, lcd;	// devices
+static	unsigned char	*lfb=0, *lbb=0, *lbb0=0, *lbb1=0, *lbb2=0;
+static	int		startx, starty;
+static	int		fbsize;
+
+static	char 		*montxt="mpcsmon";
+static	char 		*monver="0.6";
+static	int		sfd=0, connected=0;
+static	struct		sockaddr_in sa;
+static	unsigned char	raddr[4]={0,0,0,0};
+static	int		tbidx=0;
+static	char		txtbuf[MAXCLIENTS<<8], *tptr[MAXCLIENTS+1][16];
+static	char		*fontpath=(char *)txtbuf; // simple trick to save space
+static	char		*icon_esc=icon_lame; // for safety, lame always exists
+static	int		lbidx=0, logwy=0;
+static	char		logbuf[32][128];
+static	time_t		logsent=0;
+static	int		cur_server=0, num_server=0;
+static	char		cfgbuf[MAXSERVER<<8], *cfgptr=cfgbuf;
+static	SERVER		server[MAXSERVER];
+static	int		syspage=0, cs_uptime=0;
+static	int		hidemonitor=0, smallfont=0, mode2=0;
+static	char		pin[4]={10,10,10,10};
+static	AES_KEY		d_key, e_key;
+static	unsigned char	ucrc[4];
+static	int		px1=0, py1, px2, py2;
+
+static void csmon_show_clients(void);
+
+static char *trim(char *txt)
+{
+  register int l;
+  register char *p1, *p2;
+
+  if (*txt==' ')
+  {
+    for (p1=p2=txt;
+        (*p1==' ') || (*p1=='\t') || (*p1=='\n') || (*p1=='\r');
+         p1++);
+    while (*p1)
+      *p2++=*p1++;
+    *p2='\0';
+  }
+  if ((l=strlen(txt))>0)
+    for (p1=txt+l-1;
+        (*p1==' ') || (*p1=='\t') || (*p1=='\n') || (*p1=='\r');
+         *p1--='\0');
+
+  return(txt);
+}
+
+static char *strtolower(char *txt)
+{
+  char *p;
+  for (p=txt; *p; p++)
+    *p=tolower(*p);
+  return(txt);
+}
+
+static void csmon_log(char *fmt,...)
+{
+  va_list params;
+  va_start(params, fmt);
+  printf("%s: ", montxt);
+  vprintf(fmt, params);
+  fflush(stdout);
+  va_end(params);
+}
+
+static char *csmon_add_para(char *txt)
+{
+  char *ptr;
+  strcpy(ptr=cfgptr, txt);
+  cfgptr+=strlen(txt)+1;
+  return(ptr);
+}
+
+static void csmon_parse_url(char *url)
+{
+  char *service="mpcsmon://", *port, *para;
+  SERVER this;
+
+  if (num_server>=MAXSERVER) return;
+  if (strncmp(url, service, strlen(service))) return;
+  this.user=url+strlen(service);
+  if (!(this.name=strchr(this.user, '@'))) return;
+  *this.name++='\0';
+  if (!(this.pwd=strchr(this.user, ':'))) return;
+  *this.pwd++='\0';
+  if (!(port=strchr(this.name, ':'))) return;
+  *port++='\0';
+  this.label=this.name;
+  if ((para=strchr(port, '?')))
+  {
+    char *ptr1, *ptr2;
+    *para++='\0';
+    for (ptr1=strtok(para, "&"); ptr1; ptr1=strtok(NULL, ","))
+    {
+      if (!(ptr2=strchr(ptr1, '='))) continue;
+      *ptr2++='\0';
+      strtolower(ptr1);
+      if (!strcmp("label", ptr1)) this.label=ptr2;
+    }
+  }
+  if ((server[num_server].port=atoi(port)))
+  {
+    server[num_server].user =csmon_add_para(this.user);
+    server[num_server].pwd  =csmon_add_para(this.pwd);
+    server[num_server].name =csmon_add_para(this.name);
+    server[num_server].label=csmon_add_para(this.label);
+    num_server++;
+  }
+}
+
+static void csmon_chk_para(char *token, char *value)
+{
+  if (!strcmp(token, "server"))
+    csmon_parse_url(value);
+  else if (!strcmp(token, "font"))
+    strncpy(fontpath, value, 256);
+  else if (!strcmp(token, "hidemonitor"))
+    { if (atoi(value)) hidemonitor=1; }
+  else if (!strcmp(token, "startwithip"))
+    { if (atoi(value)) mode2=1; }
+  else if (!strcmp(token, "smallfont"))
+    { if (atoi(value)) smallfont=1; }
+  else if (!strcmp(token, "tinyfont"))
+    { if (atoi(value)) smallfont=2; }
+  else if (!strcmp(token, "pin"))
+    { 
+      if (strlen(value)==4) 
+      { 
+        int i; 
+        for (i=0; i<4; i++) 
+        { 
+          if ((value[i]<'0') || (value[i]>'9'))	// invalid
+            pin[0]=10;	// flag for no pin
+	  else
+            pin[i]=value[i]-'0';
+        }
+      }
+    }
+}
+
+static int csmon_read_config()
+{
+  FILE *fp;
+  char token[256];
+
+  strcpy(fontpath, FONT);
+  if (!(fp=fopen(CFGFILE, "r")))
+    return(-1);
+  while(fgets(token, sizeof(token), fp))
+  {
+    char *value;
+    if (!(value=strchr(trim(token), '='))) continue;
+    *value++='\0';
+    csmon_chk_para(trim(strtolower(token)), trim(value));
+  }
+  fclose(fp);
+  return(0);
+}
+
+static void csmon_set_key(char *key)
+{
+  AES_set_encrypt_key(key, 128, &e_key);
+  AES_set_decrypt_key(key, 128, &d_key);
+}
+
+static unsigned char *i2b(int n, ulong i)
+{
+  static unsigned char b[4];
+  switch(n)
+  {
+    case 2:
+      b[0]=(i>> 8) & 0xff;
+      b[1]=(i    ) & 0xff;
+      break;
+    case 4:
+      b[0]=(i>>24) & 0xff;
+      b[1]=(i>>16) & 0xff;
+      b[2]=(i>> 8) & 0xff;
+      b[3]=(i    ) & 0xff;
+      break;
+  }
+  return(b);
+}
+
+static void csmon_set_account(char *user, char *pwd)
+{
+  unsigned long c;
+  unsigned long md5[4];
+  c=crc32(0L, md5_buffer(user, strlen(user), md5), 16);
+  ucrc[0]=(c>>24) & 0xff; ucrc[1]=(c>>16) & 0xff;
+  ucrc[2]=(c>> 8) & 0xff; ucrc[3]=(c    ) & 0xff;
+  csmon_set_key(md5_buffer(pwd, strlen(pwd), md5));
+}
+
+#define boundary(exp, n) (((((n)-1)>>(exp))+1)<<(exp))
+
+static int csmon_send(char *txt)
+{
+  int i, l;
+  unsigned char buf[256+32];
+  buf[0]='&';
+  buf[9]=strlen(txt);
+  l=boundary(4, buf[9]+5)+5;
+  strcpy(buf+10, txt);
+  memcpy(buf+5, i2b(4, crc32(0L, buf+10, l-10)), 4);
+  for(i=0; i<(l-5); i+=16)
+    AES_encrypt(buf+5+i, buf+5+i, &e_key);
+  memcpy(buf+1, ucrc, 4);
+  return(send(sfd, buf, l, 0));
+}
+
+static int csmon_recv(unsigned char *buf, int l)
+{
+  int i, n;
+  if (!sfd) return(-1);
+  if ((n=recv(sfd, buf, l, 0))<10)
+    return(-1);
+  if (buf[0]!='&')		// not crypted
+    return(-1);
+  if (memcmp(buf+1, ucrc, 4))	// wrong user crc
+    return(-1);
+  for(i=0; i<(n-5); i+=16)
+    AES_decrypt(buf+5+i, buf+5+i, &d_key);
+  if (memcmp(buf+5, i2b(4, crc32(0L, buf+10, n-10)), 4))
+  {
+    csmon_log("CRC error while receiving ! wrong password ?\n");
+    return(-1);
+  }
+  n=buf[9];
+  buf[10+n]='\0';
+  memmove(buf, buf+10, n+1);
+  return(n);
+}
+
+static int csmon_recv_timer(unsigned char *txt, int l, int sec)
+{
+  struct timeval tv;
+  fd_set fds;
+  int rc;
+
+  if (!sfd) return(-1);
+  tv.tv_sec = sec;
+  tv.tv_usec = 0;
+  FD_ZERO(&fds);
+  FD_SET(sfd, &fds);
+
+  select(sfd+1, &fds, 0, 0, &tv);
+
+  rc=0;
+  if (FD_ISSET(sfd, &fds))
+    if (!(rc=csmon_recv(txt, l)))
+      rc=-1;
+
+  return(rc);
+}
+
+static int csmon_gets(unsigned char *txt, int sec)
+{
+  int r, done=0;
+  unsigned char *ptr;
+  static unsigned char lbuf[4096];
+  static int p=0;
+  txt[0]='\0';
+  while (!done)
+  {
+    lbuf[p]=0;
+    if ((ptr=strchr(lbuf, '\n')))
+    {
+      *ptr=0;
+      strcpy(txt, lbuf);
+      ptr++;
+      p-=ptr-lbuf;
+      if (p>0) memmove(lbuf, ptr, p+1);
+      done=1;
+    }
+    else
+    {
+      if ((r=csmon_recv_timer(lbuf+p, sizeof(lbuf)-p, sec))>0)
+        p+=r;
+      else
+        done=1;
+    }
+  }
+  return(txt[0]);
+}
+
+static void csmon_disconnect(void)
+{
+  if (sfd)
+  {
+    csmon_send("exit");
+    close(sfd);
+  }
+  for (lbidx=31; lbidx; lbidx--)
+    logbuf[lbidx][0]='\0';
+  logsent=0;
+  sfd=0;
+  memset(tptr, tbidx=0, sizeof(tptr));
+  cs_uptime=0;
+}
+
+static int csmon_connect(int srvidx)
+{
+  int sd;
+  struct protoent *ptrp;
+
+  csmon_show_clients();
+  connected=0;
+  if (!((int)(ptrp=getprotobyname("udp"))))
+    return(0);
+
+  memset((char *)&sa, 0, sizeof(sa));
+  sa.sin_family = AF_INET;
+  sa.sin_port = htons(server[srvidx].port);
+  memcpy(&sa.sin_addr, raddr, sizeof(raddr));
+
+  if ((sd=socket(PF_INET, SOCK_DGRAM, ptrp->p_proto))<0)
+    return(0);
+
+  if (connect(sd, (struct sockaddr *)&sa, sizeof(sa))<0)
+  {
+    close(sd);
+    return(0);
+  }
+  csmon_set_account(server[srvidx].user, server[srvidx].pwd);
+  connected=1;
+  cs_uptime=0;
+  return(sd);
+}
+
+static int csmon_chkcon(int srvidx)
+{
+  struct hostent *rht;
+  if (!(rht=gethostbyname(server[srvidx].name)))
+    return(-1);
+  if (memcmp(raddr, rht->h_addr, sizeof(raddr)))
+  {
+    csmon_disconnect();
+    memcpy(raddr, rht->h_addr, sizeof(raddr));
+  }
+  if (!sfd)
+  {
+    sfd=csmon_connect(srvidx);
+//    if (sfd) csmon_send("log on");
+  }
+  return(sfd);
+}
+
+#ifndef MPCSMON_DREAM_PPC
+
+/******************************************************************************
+ * GetRCCode
+ ******************************************************************************/
+
+static long GetRCCode_API3()
+{
+  long rcc=(-1);
+  static __u16 rc_last_key = KEY_RESERVED;
+
+  if (read(rc, &ev, sizeof(ev))==sizeof(ev))
+  {
+    if (ev.value)
+    {
+      if (ev.code!=rc_last_key)
+      {
+        rc_last_key=ev.code;
+        switch(ev.code)
+        {
+          case KEY_UP:		rcc=RC_UP;      break;
+          case KEY_DOWN:	rcc=RC_DOWN;    break;
+          case KEY_LEFT:	rcc=RC_LEFT;    break;
+          case KEY_RIGHT:	rcc=RC_RIGHT;   break;
+          case KEY_OK:		rcc=RC_OK;      break;
+          case KEY_0:		rcc=RC_0;       break;
+          case KEY_1:		rcc=RC_1;       break;
+          case KEY_2:		rcc=RC_2;       break;
+          case KEY_3:		rcc=RC_3;       break;
+          case KEY_4:		rcc=RC_4;       break;
+          case KEY_5:		rcc=RC_5;       break;
+          case KEY_6:		rcc=RC_6;       break;
+          case KEY_7:		rcc=RC_7;       break;
+          case KEY_8:		rcc=RC_8;       break;
+          case KEY_9:		rcc=RC_9;       break;
+          case KEY_RED:		rcc=RC_RED;     break;
+          case KEY_GREEN:	rcc=RC_GREEN;   break;
+          case KEY_YELLOW:	rcc=RC_YELLOW;  break;
+          case KEY_BLUE:	rcc=RC_BLUE;    break;
+          case KEY_VOLUMEUP:	rcc=RC_PLUS;    break;
+          case KEY_VOLUMEDOWN:	rcc=RC_MINUS;   break;
+          case KEY_MUTE:	rcc=RC_MUTE;    break;
+          case KEY_HELP:	rcc=RC_HELP;    break;
+          case KEY_SETUP:	rcc=RC_DBOX;    break;
+#ifdef MPCSMON_DREAM_7025
+          case KEY_EXIT:
+#endif
+          case KEY_HOME:	rcc=RC_HOME;    break;
+          case KEY_POWER:	rcc=RC_STANDBY;
+        }
+      }
+    }
+    else
+      rc_last_key=KEY_RESERVED;
+  }
+  return(rcc);
+}
+
+#endif
+#ifndef MPCSMON_DREAM_7025
+
+/******************************************************************************
+ * GetRCCode
+ ******************************************************************************/
+
+static long GetRCCode_API1()
+{
+  unsigned short rccode;
+  long rcc=(-1);
+  static unsigned short LastKey=(-1);
+
+  if (read(rc, &rccode, sizeof(rccode))==sizeof(rccode))
+  {
+    if(rccode!=LastKey)
+    {
+      LastKey=rccode;
+      if ((rccode&0xFF00)==0x5C00) //translation required?
+      {
+        switch(rccode)
+        {
+          case RC1_UP:		rcc=RC_UP;      break;
+          case RC1_DOWN:	rcc=RC_DOWN;    break;
+          case RC1_LEFT:	rcc=RC_LEFT;    break;
+          case RC1_RIGHT:	rcc=RC_RIGHT;   break;
+          case RC1_OK:		rcc=RC_OK;      break;
+          case RC1_0:		rcc=RC_0;       break;
+          case RC1_1:		rcc=RC_1;       break;
+          case RC1_2:		rcc=RC_2;       break;
+          case RC1_3:		rcc=RC_3;       break;
+          case RC1_4:		rcc=RC_4;       break;
+          case RC1_5:		rcc=RC_5;       break;
+          case RC1_6:		rcc=RC_6;       break;
+          case RC1_7:		rcc=RC_7;       break;
+          case RC1_8:		rcc=RC_8;       break;
+          case RC1_9:		rcc=RC_9;       break;
+          case RC1_RED:		rcc=RC_RED;     break;
+          case RC1_GREEN:	rcc=RC_GREEN;   break;
+          case RC1_YELLOW:	rcc=RC_YELLOW;  break;
+          case RC1_BLUE:	rcc=RC_BLUE;    break;
+          case RC1_PLUS:	rcc=RC_PLUS;    break;
+          case RC1_MINUS:	rcc=RC_MINUS;   break;
+          case RC1_MUTE:	rcc=RC_MUTE;    break;
+          case RC1_HELP:	rcc=RC_HELP;    break;
+          case RC1_DBOX:	rcc=RC_DBOX;    break;
+          case RC1_HOME:	rcc=RC_HOME;    break;
+          case RC1_STANDBY:	rcc=RC_STANDBY;
+        }
+      }
+      else
+        rcc=rccode&0x003F;
+    }
+  }
+  return(rcc);
+}
+#endif
+
+static long csmon_getrc()
+{
+  fd_set fds;
+  FD_ZERO(&fds);
+  FD_SET(rc, &fds);
+  select(rc+1, &fds, 0, 0, 0);
+  if (FD_ISSET(rc, &fds))
+#ifdef MPCSMON_DREAM_7025
+    return(GetRCCode_API3());
+#else
+#  ifdef MPCSMON_DREAM_PPC
+    return(GetRCCode_API1());
+#  else
+    return(is_dbox ? GetRCCode_API3() : GetRCCode_API1());
+#  endif
+#endif
+  else
+    return(-1);
+}
+
+/******************************************************************************
+ * MyFaceRequester
+ ******************************************************************************/
+
+static FT_Error MyFaceRequester(FTC_FaceID face_id, FT_Library library, FT_Pointer request_data, FT_Face *aface)
+{
+  FT_Error result;
+
+  result=FT_New_Face(library, face_id, 0, aface);
+  csmon_log("<Font \"%s\" %s>\n", (char *)face_id,
+           (result) ? "failed" : "loaded");
+  return(result);
+}
+
+#ifdef NOT_USED_YET
+/******************************************************************************
+ * RenderLCDDigit
+ ******************************************************************************/
+
+void RenderLCDDigit(int digit, int sx, int sy)
+{
+  int x, y;
+
+  for(y=0; y<15; y++)
+  {
+    for(x=0; x<10; x++)
+    {
+      if (lcd_digits[digit*15*10+x+y*10])
+        lcd_buffer[sx+x+((sy+y)/8)*120] |= 1<<((sy+y)%8);
+      else
+        lcd_buffer[sx+x+((sy+y)/8)*120] &= ~(1<<((sy+y)%8));
+    }
+  }
+}
+
+/******************************************************************************
+ * UpdateLCD
+ ******************************************************************************/
+
+void UpdateLCD(int account)
+{
+	int x, y;
+
+	//set online status
+
+		for(y = 0; y < 19; y++)
+		{
+			for(x = 0; x < 17; x++)
+			{
+				if(lcd_status[online*17*19 + x + y*17]) lcd_buffer[4 + x + ((18 + y)/8)*120] |= 1 << ((18 + y)%8);
+				else lcd_buffer[4 + x + ((18 + y)/8)*120] &= ~(1 << ((18 + y)%8));
+			}
+		}
+
+	//set digits
+
+		RenderLCDDigit(maildb[account].nr[0] - '0', 41, 20);
+
+		RenderLCDDigit(maildb[account].time[0] - '0', 58, 20);
+		RenderLCDDigit(maildb[account].time[1] - '0', 71, 20);
+		RenderLCDDigit(maildb[account].time[3] - '0', 93, 20);
+		RenderLCDDigit(maildb[account].time[4] - '0', 106, 20);
+
+		RenderLCDDigit(maildb[account].status[0] - '0', 28, 44);
+		RenderLCDDigit(maildb[account].status[1] - '0', 41, 44);
+		RenderLCDDigit(maildb[account].status[2] - '0', 54, 44);
+		RenderLCDDigit(maildb[account].status[4] - '0', 80, 44);
+		RenderLCDDigit(maildb[account].status[5] - '0', 93, 44);
+		RenderLCDDigit(maildb[account].status[6] - '0', 106, 44);
+
+	//copy to lcd
+
+		write(lcd, &lcd_buffer, sizeof(lcd_buffer));
+}
+#endif
+
+/******************************************************************************
+ * bufsize / SetPixel / HorLine - speed up with defines
+ ******************************************************************************/
+
+#ifdef MPCSMON_FB_32BPP
+# define bufsize(n) ((n)<<2)
+# define SetPixel(x, y, c)  memcpy(lbb + ((startx + (x))<<2) + fix_screeninfo.line_length*(starty + (y)), bgra[c], 4)
+static void HorLine(int x, int y, int l, int color)
+{
+  for (l+=x; x<l; x++)
+    SetPixel(x, y, color);
+}
+#else
+# define bufsize(n) (n)
+# define SetPixel(x, y, c)  *(lbb + startx + (x) + fix_screeninfo.line_length*(starty + (y)))=(c)
+# define HorLine(x, y, l, c)  memset(lbb + startx + (x) + fix_screeninfo.line_length*(starty + (y)), c, l)
+#endif
+
+/******************************************************************************
+ * RenderChar
+ ******************************************************************************/
+
+static int RenderChar(FT_ULong currentchar, int sx, int sy, int ex, int color)
+{
+  int row, pitch, bit, x = 0, y = 0;
+  FT_Error error;
+  FT_UInt glyphindex;
+  FT_Vector kerning;
+  FTC_Node anode;
+
+  //load char
+  if (!(glyphindex=FT_Get_Char_Index(face, (int)currentchar))) // cast (int) due to 7025
+  {
+    csmon_log("<FT_Get_Char_Index for Char \"%c\" failed: \"undefined character code\">\n", (int)currentchar);
+    return(0);
+  }
+
+  if ((error=FTC_SBitCache_Lookup(cache, &desc, glyphindex, &sbit, &anode)))
+  {
+    csmon_log("<FTC_SBitCache_Lookup for Char \"%c\" failed with Errorcode 0x%.2X>\n", (int)currentchar, error);
+    return(0);
+  }
+
+  if (use_kerning)
+  {
+    FT_Get_Kerning(face, prev_glyphindex, glyphindex, ft_kerning_default, &kerning);
+    prev_glyphindex=glyphindex;
+    kerning.x>>=6;
+  }
+  else
+    kerning.x=0;
+
+  //render char
+  if (color!=(-1))	/* don't render char, return charwidth only */
+  {
+    if (sx+sbit->xadvance>=ex) return(-1);	/* limit to maxwidth */
+
+    for (row=0; row<sbit->height; row++)
+    {
+      for (pitch=0; pitch<sbit->pitch; pitch++)
+      {
+        for (bit=7; bit>=0; bit--)
+        {
+          if (pitch*8+7-bit >= sbit->width) break; /* render needed bits only */
+          if ((sbit->buffer[row*sbit->pitch+pitch]) & 1<<bit)
+            SetPixel(sx + x + sbit->left + kerning.x, sy + y - sbit->top, color);
+          x++;
+        }
+      }
+      x=0;
+      y++;
+    }
+  }
+  return(sbit->xadvance + kerning.x);		// return charwidth
+}
+
+/******************************************************************************
+ * GetStringLen
+ ******************************************************************************/
+
+static int GetStringLen(unsigned char *string)
+{
+  int stringlen=0;
+
+  prev_glyphindex=0;
+  while (*string!='\0')
+  {
+    stringlen+=RenderChar(*string, -1, -1, -1, -1);
+    string++;
+  }
+  return(stringlen);
+}
+
+/******************************************************************************
+ * RenderString
+ ******************************************************************************/
+
+static void RenderString(unsigned char *string, int sx, int sy, int maxwidth, int layout, int size, int color)
+{
+  int stringlen, ex, charwidth;
+
+  //set size
+  switch(size)
+  {
+    case TINY:
+      desc.font.pix_width = desc.font.pix_height = 20;
+      break;
+    case SMALL:
+      desc.font.pix_width = desc.font.pix_height = 24;
+      break;
+//    case BIG:
+    default:
+      desc.font.pix_width = desc.font.pix_height = 32; // 40
+      break;
+  }
+
+  //set alignment
+  if (layout!=LEFT)
+  {
+    stringlen=GetStringLen(string);
+    switch(layout)
+    {
+      case CENTER: if (stringlen<maxwidth) sx+=(maxwidth-stringlen)/2;
+                   break;
+
+      case RIGHT:  if (stringlen<maxwidth) sx+=maxwidth-stringlen;
+    }
+  }
+
+  //reset kerning
+  prev_glyphindex=0;
+
+  //render string
+  ex = sx + maxwidth;
+
+  while(*string!='\0')
+  {
+    if ((charwidth=RenderChar(*string, sx, sy, ex, color))==-1)
+      return;			/* string > maxwidth */
+    sx+=charwidth;
+    string++;
+  }
+}
+
+/******************************************************************************
+ * RenderBox
+ ******************************************************************************/
+
+static void RenderBox(int sx, int sy, int ex, int ey, int mode, int color)
+{
+  int loop;
+
+  if (mode==FILL)
+    for(; sy<=ey; sy++)
+      HorLine(sx, sy, ex-sx+1, color);
+  else
+  {
+    //hor lines
+    for(loop=sx; loop<=ex; loop++)
+    {
+      SetPixel(loop, sy  , color);
+      SetPixel(loop, sy+1, color);
+      SetPixel(loop, ey-1, color);
+      SetPixel(loop, ey  , color);
+    }
+    //ver lines
+    for(loop=sy; loop<=ey; loop++)
+    {
+      SetPixel(sx  , loop, color);
+      SetPixel(sx+1, loop, color);
+      SetPixel(ex-1, loop, color);
+      SetPixel(ex  , loop, color);
+    }
+  }
+}
+
+/******************************************************************************
+ * RenderCircle
+ ******************************************************************************/
+
+static void RenderCircle(int sx, int sy, int color)
+{
+  int x, y;
+
+  for (y=0; y<15; y++)
+    for (x=0; x<15; x++)
+      if (circle[x+y*15])
+        SetPixel(sx + x, sy + y, color);
+}
+
+/******************************************************************************
+ * PaintIcon
+ ******************************************************************************/
+
+struct rawHeader
+{
+  uint8_t width_lo;
+  uint8_t width_hi;
+  uint8_t height_lo;
+  uint8_t height_hi;
+  uint8_t transp;
+} __attribute__ ((packed));
+
+static void PaintIcon(unsigned char *icon, int sx, int sy)
+{
+  struct rawHeader header;
+  uint16_t         width, height;
+  int              x, y;
+
+  memcpy(&header, icon, sizeof(struct rawHeader));
+  width  = (header.width_hi  << 8) | header.width_lo;
+  height = (header.height_hi << 8) | header.height_lo;
+  icon+=sizeof(struct rawHeader);
+
+  for (y=0; y<height; y++)
+  {
+    for (x=0; x<width; x+=2)
+    {
+      unsigned char pix;
+      pix = (*icon & 0xf0) >> 4;
+      if (pix != header.transp)
+        SetPixel(sx+x, sy+y, pix+1);
+      pix = (*icon++ & 0x0f);
+      if (pix != header.transp)
+        SetPixel(sx+x+1, sy+y, pix+1);
+    }
+  }
+}
+
+/******************************************************************************
+ * Pop-Up's
+ ******************************************************************************/
+
+static void csmon_redraw_screen(int lbb_no)
+{
+  lbb=(lbb_no) ? lbb1 : lbb0;	// set default backbuffer;
+  if (px1)	// active popup
+  {
+    int y;
+    memcpy(lbb2, lbb0, fbsize);
+    for(y=py1; y<=py2; y++)
+    {
+      long offset=bufsize(startx + px1) + fix_screeninfo.line_length*(starty + y);
+      memcpy(lbb2 + offset, lbb1 + offset, bufsize(px2-px1+1));
+    }
+    memcpy(lfb, lbb2, fbsize);
+  }
+  else
+    memcpy(lfb, lbb0, fbsize);
+}
+
+#define LABEL_YS 32
+
+#define csmon_popup_close() csmon_redraw_screen(px1=0)
+
+static void csmon_popup_window(char *label, char *icon, int x1, int y1, int xs, int ys)
+{
+  lbb=lbb1;	// while painting popup use popup-backbuffer
+  if (x1<0) x1=((var_screeninfo.xres-xs)>>1)-startx;
+  if (y1<0) y1=((var_screeninfo.yres-ys)>>1)-starty;
+  px1=x1; py1=y1; px2=x1+xs; py2=y1+ys;
+  RenderBox(px1+1, py1+1, px2+1, py2+1, GRID, BLACK);
+  RenderBox(px1+2, py1+2, px2+2, py2+2, GRID, BLACK);
+  RenderBox(px1  , py1  , px2  , py1+LABEL_YS, FILL, BLUE3);
+  RenderBox(px1  , py1+LABEL_YS, px2  , py2, FILL, BLUE);
+  PaintIcon(icon, px1+4, py1+2);
+  RenderString(label, px1+32, py1+24, px2, LEFT, BIG, ORANGE);
+  RenderBox(px2-110, py2-36  , px2-10  , py2-10, FILL, BLUE2);
+  PaintIcon(icon_esc, px2-105, py2-34);
+  RenderString("Zurck", px2-70, py2-16, px2-10, LEFT, SMALL, BLACK);
+  px2+=2; py2+=2;
+}
+
+static void csmon_message(int waitflag, char *label, char *txt)
+{
+  int xs;
+  RenderString("", startx, starty, startx, LEFT, BIG, WHITE);
+  xs=GetStringLen(txt)+32;
+  if (xs<300) xs=300;
+  csmon_popup_window(label, icon_info, -1, -1, xs, 130);
+  RenderString(txt, px1, py1+(LABEL_YS<<1)+8, px2-px1, CENTER, BIG, WHITE);
+  csmon_redraw_screen(0);
+  if (waitflag)
+  {
+    long rccode;
+    while (waitflag)
+      waitflag=(((rccode=csmon_getrc())!=RC_HOME) && (rccode!=RC_OK));
+    csmon_popup_close();
+  }
+}
+
+#define PINCX 32
+#define PINCY 40
+static int csmon_getpin(char *cp)
+{
+  int cy, cx, state, cell=0, action=1;
+
+  if (cp[0]>9) return(2);	// no pin needed
+  char c[]={10,10,10,10};
+//  csmon_popup_window("PIN-Abfrage", icon_lock, -1, -1, 300, 100);
+//  cx=px1+32;
+  csmon_popup_window("PIN-Abfrage", icon_lock, -1, -1, 300, 150);
+  cx=px1+((px2-px1)>>1)-(PINCX<<1);
+  cy=py1+LABEL_YS+20;
+  RenderBox(cx, cy, cx+(PINCX<<2), cy+PINCY, GRID, WHITE);
+  RenderBox(cx+3*PINCX, cy, cx+(PINCX<<2), cy+PINCY, GRID, WHITE);
+  RenderBox(cx+PINCX, cy, cx+(PINCX<<1), cy+PINCY, GRID, WHITE);
+  for (state=2; state>1;)
+  {
+    int i;
+    long rccode;
+    if (action)
+      for (i=0; i<4; i++)
+      {
+        RenderBox(cx+1+(i*PINCX), cy+1, cx+((i+1)*PINCX)-1, cy+PINCY-1, FILL, (i==cell) ? BLUE2 : BLUE1);
+        if (c[i]<10) RenderCircle(cx+8+(i*PINCX), cy+13, WHITE);
+      }
+    csmon_redraw_screen(1);
+    action=1;
+    switch(rccode=csmon_getrc())
+    {
+      case RC_0: case RC_1:
+      case RC_2: case RC_3:
+      case RC_4: case RC_5:
+      case RC_6: case RC_7:
+      case RC_8: case RC_9: c[cell]=rccode-RC_0; // fall through
+      case RC_RIGHT       : cell+=1;  break;
+      case RC_LEFT        : cell+=3;  break;
+//      case RC_OK          : state=1;  break;	// for test ONLY !
+      case RC_HOME        : state=0;  break;
+      default             : action=0;		// no refresh needed
+    }
+    cell%=4;
+    if (!memcmp(cp, c, 4)) state=1;
+  }
+  csmon_popup_close();
+  return(state);
+}
+
+static void csmon_helpscreen()
+{
+  int cy, x1, x2, tc=B_GRAY;
+  csmon_popup_window("Tastenbelegung", icon_info, -1, -1, 350, 380);
+  cy=py1+LABEL_YS+10;
+  x1=px1+24;
+  x2=px1+70;
+  RenderCircle(x1+4, cy+6, RED);
+  RenderString("Client-Prozesse anzeigen", x2, cy+24, px2-x2, LEFT, BIG, tc);
+  cy+=28;
+  RenderCircle(x1+4, cy+6, GREEN);
+  RenderString("Server-Prozesse anzeigen", x2, cy+24, px2-x2, LEFT, BIG, tc);
+  cy+=28;
+  PaintIcon(icon_up, x1, cy+3);
+  RenderString("Nchster Server", x2, cy+24, px2-x2, LEFT, BIG, tc);
+  cy+=28;
+  PaintIcon(icon_down, x1, cy+3);
+  RenderString("Vorheriger Server", x2, cy+24, px2-x2, LEFT, BIG, tc);
+  cy+=28;
+  PaintIcon(icon_left, x1-10, cy+3);
+  PaintIcon(icon_right, x1+10, cy+3);
+  RenderString("Toggle Felder (groe Schrift)", x2, cy+24, px2-x2, LEFT, BIG, tc);
+  cy+=28;
+  PaintIcon(icon_plus, x1, cy+3);
+  RenderString("Groe Schrift", x2, cy+24, px2-x2, LEFT, BIG, tc);
+  cy+=28;
+  PaintIcon(icon_minus, x1, cy+3);
+  RenderString("Kleine Schrift", x2, cy+24, px2-x2, LEFT, BIG, tc);
+  cy+=28;
+  PaintIcon(icon_mute_small, x1, cy+3);
+  RenderString("Monitor-Clients ausblenden", x2, cy+24, px2-x2, LEFT, BIG, tc);
+  cy+=28;
+  PaintIcon(icon_power_button, x1, cy+3);
+  RenderString("Cardserver beenden", x2, cy+24, px2-x2, LEFT, BIG, tc);
+  cy+=28;
+  PaintIcon(icon_help, x1, cy+3);
+  RenderString("Hilfe ein-/ausblenden", x2, cy+24, px2-x2, LEFT, BIG, tc);
+  cy+=28;
+  PaintIcon(icon_esc, x1, cy+3);
+  RenderString("Monitor beenden", x2, cy+24, px2-x2, LEFT, BIG, tc);
+  csmon_redraw_screen(0);
+}
+
+static void csmon_show_log(int force)
+{
+  int i, y, idx, color;
+  int ys, fontsize;
+
+  if (smallfont == 2)
+  {
+    ys = 16;
+    fontsize = TINY;
+  }
+  else
+  {
+    ys = 20;
+    fontsize = SMALL;
+  }
+  static int last=-1;
+  if (force) last=-1;
+  if (last!=lbidx)
+  {
+    RenderBox(0, logwy, 619, 504, FILL, BLUE1);
+    RenderBox(0, logwy, 619, 504, GRID, BLUE2);
+//    for (y=498, i=64; y>(logwy+15); y-=20, i--)
+    for (y=498, i=64; y>(logwy+15); y-=ys, i--)
+    {
+      idx=(lbidx+i-1)&0x1f;
+      if (logbuf[idx][0])
+      {
+        logbuf[idx][8]='\0';
+//        RenderString(logbuf[idx], 4, y,  72, LEFT, SMALL, WHITE);
+        RenderString(logbuf[idx], 4, y,  72, LEFT, fontsize, WHITE);
+        switch(logbuf[idx][/*16*/18])
+        {
+          case 'n':
+          case 'l':
+          case 's': color=ORANGE; break;
+          case 'p':
+          case 'r': color=YELLOW; break;
+          default : color=WHITE;
+        }
+//        RenderString(logbuf[idx]+16, 80, y,  520, LEFT, SMALL, color);
+        RenderString(logbuf[idx]+20, 80, y,  520, LEFT, fontsize, color);
+      }
+    }
+    csmon_redraw_screen(0);
+    last=lbidx;
+  }
+}
+
+static int csmon_add_client(char *line)
+{
+  int i, n, l;
+  char *ptr, *txt, *str[32];
+  static int nr=0;
+  static char seq=0;
+  txt=line+8;
+//printf("header=%-8.8s\n", line); fflush(stdout);
+  if ((line[2]=='S') || (line[2]=='B'))
+  {
+    seq=line[3];
+    memset(tptr, tbidx=nr=0, sizeof(tptr));
+  }
+  if (line[3]!=seq)	// check block sequence id
+    return(0);
+  memset(str, 0, sizeof(str));
+  if (nr>MAXCLIENTS) return(0);
+  for (i=n=0, l=strlen(txt), str[0]=ptr=txt; n<l; n++)
+  {
+    if (txt[n]=='|')
+    {
+      txt[n]='\0';
+      str[++i]=txt+n+1;
+    }
+  }
+  for (i=0; i<MAXFIELDS; i++)
+  {
+    tptr[nr][i]=txtbuf+tbidx;
+    strncpy(tptr[nr][i], str[i] ? str[i] : "", MAXFIELDSIZE);
+    txtbuf[tbidx+MAXFIELDSIZE]='\0';
+    tbidx+=1+strlen(tptr[nr][i]);
+  }
+  if (*tptr[nr][1]=='s')
+    cs_uptime=atoi(tptr[nr][11]);
+//printf("tbidx=%d rc=%d\n", tbidx, (line[2]=='E') || (line[2]=='S'));
+  nr++;
+  return((line[2]=='E') || (line[2]=='S'));
+}
+
+static char *csmon_sec2disp(int sec, char *buf)
+{
+  int lmin, ltmp;
+  buf[0]='\0';
+  lmin=sec/60;
+  if ((ltmp=(lmin/60/24)))
+  {
+    sprintf(buf, "%dt ", ltmp);
+    lmin%=24*60;
+  }
+  ltmp=strlen(buf);
+  sprintf(buf+ltmp, "%d:%02dh", lmin/60, lmin%60);
+  return(buf);
+}
+
+void csmon_show_nick(void)
+{
+  int l;
+  char buf[64], txt[16], *ptr;
+  if (cs_uptime)
+    snprintf(ptr=buf, sizeof(buf)-1, "%s - %s",
+             server[cur_server].label, csmon_sec2disp(cs_uptime, txt));
+  else
+    ptr=server[cur_server].label;
+  desc.font.pix_width = desc.font.pix_height = 32;
+  l=16+(GetStringLen(ptr)>>1);
+  if (l>250) l=250;
+  RenderBox(300-l, 0, 340+l, 30, FILL, BLUE1);
+  RenderBox(300-l, 0, 340+l, 30, GRID, BLUE2);
+  RenderString(ptr, 320-l, 23, l<<1, CENTER , BIG, WHITE);
+//PaintIcon(icon_lock, 1, 1);
+}
+
+static int csmon_circol(int order, char *txt)
+{
+  int n;
+  n=atoi(txt);
+  if (order)
+  {
+    order=n;
+    n=(order==0) ? 2 : (order<0) ? 1 : 0;
+  }
+  switch(n)
+  {
+    case  0: n=B_GREEN ; break;
+    case  1: n=YELLOW  ; break;
+    default: n=B_RED   ; break;
+  }
+  return(n);
+}
+
+static void csmon_show_client(int idx, int y, int siz)
+{
+  int i, col, label;
+//  int p1[]={64, 180, 280, 460, 526, 610, 790, 610};
+  int p1[]={64+24, 180+24, 280+24, 460, 526, 610, 790, 610};
+  int p2[8];
+  char iptxt[32], buf[32], ctype[8], *user, *nrtxt;
+  col=WHITE;
+  if ((label=(idx<0)))
+  {
+    idx=MAXCLIENTS;
+    tptr[idx][0]="PID";
+    tptr[idx][1]="Typ";
+    tptr[idx][2]="Nr";
+    tptr[idx][3]="Benutzer";
+    tptr[idx][4]="AU";
+    tptr[idx][5]="Crypted";
+    tptr[idx][6]="IP";
+    tptr[idx][7]="Port";
+    tptr[idx][8]="Protokoll";
+    tptr[idx][11]="Online";
+    tptr[idx][13]="Sender";
+    tptr[idx][14]="Idle";
+    tptr[idx][15]="On";
+    col=YELLOW;
+  }
+  for (i=0; i<7; i++)
+    p2[i]=(siz==BIG) ? p1[i] : p1[0]+((p1[i]-p1[0])*3/4);
+  sprintf(iptxt, "%s:%s", tptr[idx][6], tptr[idx][7]);
+  user=(*tptr[idx][3]) ? tptr[idx][3] : "anonym";
+  switch(*tptr[idx][1])
+  {
+    case 'm': 
+    case 'c': nrtxt=tptr[idx][2]; break;
+    case 'p': 
+    case 'r': sprintf(nrtxt=ctype, "%c%02d", *tptr[idx][1], atoi(tptr[idx][2])); break;
+    default : nrtxt=tptr[idx][1];
+  }
+
+  if (syspage)
+  {
+    RenderString(label ? tptr[idx][1] : nrtxt
+		                 ,    13, y,  45, LEFT, siz, col);
+  }
+  else
+  {
+    RenderString(label ? tptr[idx][2] : nrtxt
+                                 ,     4, y,  24, RIGHT, siz, col);
+    if (label)
+      RenderString(tptr[idx][15] ,    28, y,  28, RIGHT, siz, col);
+    else
+      RenderCircle(40, y-15, csmon_circol(0, tptr[idx][15]));
+  }
+  if (label)
+    RenderString(tptr[idx][4]  ,    54, y,  28, RIGHT, siz, col);
+  else
+  {
+    int c;
+    switch(*tptr[idx][1])
+    {
+      case 's': case 'l':
+      case 'n': case 'm': c=GRAY; break;
+      default :           c=csmon_circol(1, tptr[idx][4]);
+    }
+    RenderCircle(64, y-15, c);
+  }
+
+  RenderString(user              , p2[0], y, (p2[1]-p2[0])-1, LEFT , siz, col);
+  RenderString(tptr[idx][8]      , p2[1], y, (p2[2]-p2[1])-1, LEFT , siz, col);
+
+  user = ((mode2) && (siz==BIG)) ? iptxt : tptr[idx][13];
+  RenderString(user              , p2[2], y, (p2[4]-p2[2])-1, LEFT , siz, col);
+
+  user = tptr[idx][syspage ? 14 : 11];
+  if (!label)
+    user = csmon_sec2disp(atoi(user), buf);
+  RenderString(user              , p2[4], y, (p2[5]-p2[4])-1, LEFT , siz, col);
+
+  if (siz!=BIG)
+    RenderString(iptxt           , p2[5], y, 180, LEFT , siz, col);
+}
+
+static int csmon_chk_client(int idx)
+{
+   if (syspage==1)
+     return((*tptr[idx][1]!='c') && (*tptr[idx][1]!='m'));
+   else
+#if 0
+     return((*tptr[idx][1]=='c')||((*tptr[idx][1]=='m') && (!hidemonitor)));
+#else
+   {
+     if ((*tptr[idx][1]!='c')&&((*tptr[idx][1]!='m') || (hidemonitor)))
+       return(0);
+//printf("IDLE=%d[%s]\n", atoi(tptr[idx][14]), tptr[idx][14]);
+     if (hidemonitor)
+     {
+       if (tptr[idx][14] && (atoi(tptr[idx][14])>120))
+         return(0);
+       if (!strcmp(tptr[idx][12], "FFFE:FFFE"))
+         return(0);
+     }
+     return(1);
+   }
+#endif
+}
+
+static void csmon_show_clients(void)
+{
+  int i, nr, h, zy, siz;
+  for (i=nr=0; tptr[i][0]; i++)
+    if (csmon_chk_client(i)) nr++;
+  h=20;
+  if ((nr>18) || (smallfont==2))
+  {
+    zy=16;
+    siz=TINY;
+    logwy=h+17+(nr+1)*zy;
+  }
+  else if ((nr>10) || (smallfont))
+  {
+    zy=20;
+    siz=SMALL;
+    logwy=h+17+(nr+1)*zy;
+  }
+  else
+  {
+    zy=30;
+    siz=BIG;
+    logwy=h+20+(nr+1)*zy;
+  }
+  memset(lbb, 0, fbsize);
+  RenderBox(0, h, 619, h+12+(nr+1)*zy, FILL, BLUE1);
+  RenderBox(0, h, 619, h+12+(nr+1)*zy, GRID, BLUE2);
+  h+=(siz==BIG)?1:4;
+  csmon_show_client(-1, h+zy, siz);
+  csmon_show_nick();
+//  for (i=0, nr=1; (tptr[i][0]) && (nr<21); i++)
+  for (i=0, nr=1; (tptr[i][0]) && (nr<26); i++)
+    if (csmon_chk_client(i))
+    {
+      nr++;
+      csmon_show_client(i, h+nr*zy, siz);
+    }
+  csmon_show_log(1);
+}
+
+static void csmon_add_log(char *txt)
+{
+  strncpy(logbuf[lbidx], txt, 127);
+  lbidx=(lbidx+1) & 0x1f;
+}
+
+static void csmon_chk_receive(void)
+{
+  int rflog, rfclient;
+  char txt[512];
+
+  if (sfd)
+  {
+    rflog=rfclient=0;
+    while (csmon_gets(txt, 0))
+    {
+//printf("empfang: {%s}\n", txt);
+      if ((strlen(txt)<8)||(txt[0]!='[')||(txt[7]!=']')) continue;
+      switch (txt[1])
+      {
+        case 'L': csmon_add_log(txt+19);
+                  rflog=1;
+                  break;
+        case 'I': rfclient=csmon_add_client(txt);
+                  break;
+      }
+    }
+    if (rfclient) csmon_show_clients();
+    else if (rflog) csmon_show_log(0);
+  }
+}
+
+static int csmon_chk_rc(long rccode)
+{
+  static int new_server=0;
+  int ok;
+
+  switch(rccode)
+  {
+    case RC_HOME:
+      if (px1)	// active popup
+        csmon_popup_close();	// close popup
+      else
+	return(1);		// exit flag
+      break;
+
+    case RC_HELP:
+      if (px1)	// active popup
+        csmon_popup_close();
+      else
+        csmon_helpscreen();
+      break;
+
+    case RC_STANDBY:
+      csmon_send("shutdown");
+      break;
+
+    case RC_UP:
+    case RC_DOWN:
+      if (num_server<2) return(0);
+      for (ok=0; !ok;)
+      {
+        new_server+=(rccode==RC_UP) ? 1 : num_server-1;
+        new_server%=num_server;
+        ok=((server[new_server].name) && (server[new_server].port));
+        if (new_server==cur_server) ok=1;
+      }
+      if (new_server==cur_server) return(1);
+      cur_server=new_server;
+      logsent=0;
+      csmon_disconnect();
+      break;
+
+    case RC_LEFT:
+    case RC_RIGHT:
+      mode2^=1;
+      logsent=0;
+      break;
+    case RC_MUTE:
+      hidemonitor^=1;
+      logsent=0;
+      break;
+    case RC_RED:
+      syspage=0;
+      logsent=0;
+      break;
+    case RC_GREEN:
+      syspage=1;
+      logsent=0;
+      break;
+    case RC_MINUS:
+      if (smallfont<2)
+      {
+        smallfont++;
+        logsent=0;
+      }
+      break;
+    case RC_PLUS:
+      if (smallfont)
+      {
+        smallfont--;
+        logsent=0;
+      }
+      break;
+//    case RC_OK:
+//    case RC_YELLOW:
+//    case RC_BLUE:
+//    case RC_0: case RC_1: case RC_2: case RC_3: case RC_4:
+//    case RC_5: case RC_6: case RC_7: case RC_8: case RC_9:
+//      break;
+
+  }
+  return(0);
+}
+
+/******************************************************************************
+ * init
+ ******************************************************************************/
+
+#ifdef MPCSMON_DREAM_7025
+static int csmon_init()
+#else
+static int csmon_init(PluginParam *par)
+#endif
+{
+  int sx, ex, sy, ey;
+  FT_Error error;
+  struct stat chkstat;
+
+  //show versioninfo
+  csmon_log("version %s\n", monver);
+
+  //check hardware
+#ifdef MPCSMON_DREAM_7025 
+  csmon_log("hardware dreambox 7025\n");
+#else
+# ifdef MPCSMON_DREAM_PPC 
+  csmon_log("hardware dreambox ppc\n");
+# else
+  if (!stat("/dev/dvb/adapter0", &chkstat)) is_dbox=1;
+  csmon_log("hardware %s\n", is_dbox ? "dbox2" : "dreambox ppc");
+  icon_esc=(is_dbox) ? icon_home : icon_lame;
+# endif
+#endif
+
+  //get params
+  fb = rc = lcd = sx = ex = sy = ey = -1;
+
+#ifdef MPCSMON_DREAM_7025
+  // open Framebuffer
+  fb=open("/dev/fb/0", O_RDWR);
+ 
+  // open Remote Control
+  int cnt=0;
+  
+  while(1)
+  {
+    struct stat s;
+    char tmp[128];
+    sprintf(tmp, "/dev/input/event%d", cnt);
+    if (stat(tmp, &s))
+      break;
+    /* open Remote Control */
+    if ((rc=open(tmp, O_RDONLY)) == -1)
+    {
+      csmon_log("error open remote control\n");
+      return(1);
+    }
+    if (ioctl(rc, EVIOCGNAME(128), tmp) < 0)
+      csmon_log("EVIOCGNAME failed\n");
+    if (strstr(tmp, "remote control"))
+      break;
+    close(rc);
+    rc=-1;
+    ++cnt;
+  }
+  sx = 50;
+  ex = 670;
+  sy = 50;
+  ey = 526;
+#else
+  for(; par; par = par->next)
+  {
+    if      (!strcmp(par->id, P_ID_FBUFFER)) fb = atoi(par->val);
+    else if (!strcmp(par->id, P_ID_RCINPUT)) rc = atoi(par->val);
+    else if (!strcmp(par->id, P_ID_LCD    )) lcd= atoi(par->val);
+    else if (!strcmp(par->id, P_ID_OFF_X  )) sx = atoi(par->val);
+    else if (!strcmp(par->id, P_ID_END_X  )) ex = atoi(par->val);
+    else if (!strcmp(par->id, P_ID_OFF_Y  )) sy = atoi(par->val);
+    else if (!strcmp(par->id, P_ID_END_Y  )) ey = atoi(par->val);
+  }
+#endif
+
+//  if (fb == -1 || rc == -1 || lcd == -1 || sx == -1 || ex == -1 || sy == -1 || ey == -1)
+  if (fb == -1 || rc == -1 || sx == -1 || ex == -1 || sy == -1 || ey == -1)
+  {
+    csmon_log("<missing Param(s)>\n");
+    return(1);
+  }
+
+  //init framebuffer
+
+  if (ioctl(fb, FBIOGET_FSCREENINFO, &fix_screeninfo) == -1)
+  {
+    csmon_log("<FBIOGET_FSCREENINFO failed>\n");
+    return(1);
+  }
+
+  if (ioctl(fb, FBIOGET_VSCREENINFO, &var_screeninfo) == -1)
+  {
+    csmon_log("<FBIOGET_VSCREENINFO failed>\n");
+    return(1);
+  }
+
+  fbsize=fix_screeninfo.line_length*var_screeninfo.yres;
+
+#ifndef MPCSMON_FB_32BPP
+  if (ioctl(fb, FBIOPUTCMAP, &colormap) == -1)
+  {
+    csmon_log("<FBIOPUTCMAP failed>\n");
+    return(1);
+  }
+#endif
+
+  if (!(lfb = (unsigned char*)mmap(0, fix_screeninfo.smem_len, PROT_READ | PROT_WRITE, MAP_SHARED, fb, 0)))
+  {
+    csmon_log("<mapping of Framebuffer failed>\n");
+    return(1);
+  }
+
+  //init fontlibrary
+
+  if ((error = FT_Init_FreeType(&library)))
+  {
+    csmon_log("<FT_Init_FreeType failed with Errorcode 0x%.2X>", error);
+    munmap(lfb, fix_screeninfo.smem_len);
+    return(1);
+  }
+
+  if ((error = FTC_Manager_New(library, 1, 2, 0, &MyFaceRequester, NULL, &manager)))
+  {
+    csmon_log("<FTC_Manager_New failed with Errorcode 0x%.2X>\n", error);
+    FT_Done_FreeType(library);
+    munmap(lfb, fix_screeninfo.smem_len);
+    return(1);
+  }
+
+  if ((error = FTC_SBitCache_New(manager, &cache)))
+  {
+    csmon_log("<FTC_SBitCache_New failed with Errorcode 0x%.2X>\n", error);
+    FTC_Manager_Done(manager);
+    FT_Done_FreeType(library);
+    munmap(lfb, fix_screeninfo.smem_len);
+    return(1);
+  }
+
+  if((error = FTC_Manager_Lookup_Face(manager, fontpath, &face)))
+  {
+    csmon_log("<FTC_Manager_Lookup_Face failed with Errorcode 0x%.2X>\n", error);
+    FTC_Manager_Done(manager);
+    FT_Done_FreeType(library);
+    munmap(lfb, fix_screeninfo.smem_len);
+    return(1);
+  }
+
+  use_kerning = FT_HAS_KERNING(face);
+
+  desc.font.face_id = fontpath;
+#ifdef OLDFT
+  desc.type = ftc_image_mono;
+#else
+  desc.flags = FT_LOAD_MONOCHROME;
+#endif
+
+  //init backbuffer
+  lbb = malloc(3*fbsize);
+  if (!lbb)
+  {
+    csmon_log("<memory allocating failed>\n");
+    FTC_Manager_Done(manager);
+    FT_Done_FreeType(library);
+    munmap(lfb, fix_screeninfo.smem_len);
+    return(1);
+  }
+  lbb0 = lbb;
+  lbb1 = lbb+fbsize;
+  lbb2 = lbb+(fbsize<<1);
+
+  memset(lbb, 0, 3*fbsize);
+
+  startx = sx + (((ex-sx) - 620)/2);
+  starty = sy + (((ey-sy) - 505)/2);
+  return(0);
+}
+
+/******************************************************************************
+ * plugin_exec
+ ******************************************************************************/
+
+#ifdef MPCSMON_DREAM_7025
+int main()
+#else
+void plugin_exec(PluginParam *par)
+#endif
+{
+  long rccode=(-1);
+
+  csmon_read_config();
+#ifdef MPCSMON_DREAM_7025
+  if (csmon_init()) return;
+#else
+  if (csmon_init(par)) return;
+#endif
+  csmon_disconnect();
+
+  if (!num_server)
+    csmon_message(1, "Konfiguration", "Kein Server definiert");
+  else if (csmon_getpin(pin)) while (1)
+  {
+    struct timeval tv;
+    fd_set fds;
+
+    if (csmon_chkcon(cur_server)>0)
+    {
+      time_t timenow;
+      if ((timenow=time(NULL))>logsent+3)
+      {
+        csmon_send("status");
+        csmon_send("log on");
+        logsent=timenow;
+      }
+    }
+
+    tv.tv_sec = 3;
+    tv.tv_usec = 0;
+    FD_ZERO(&fds);
+    if (sfd) FD_SET(sfd, &fds);
+    FD_SET(rc, &fds);
+    select(((sfd>rc) ? sfd : rc)+1, &fds, 0, 0, &tv);
+
+    if ((FD_ISSET(rc, &fds)) && ((rccode=csmon_getrc())>=0))
+      if (csmon_chk_rc(rccode))
+        break;
+
+    if (sfd && FD_ISSET(sfd, &fds))
+      csmon_chk_receive();
+  }
+
+  csmon_disconnect();
+#ifdef MPCSMON_DREAM_7025
+  close(fb);
+  close(rc);
+#endif
+  FTC_Manager_Done(manager);
+  FT_Done_FreeType(library);
+  free(lbb);
+  munmap(lfb, fix_screeninfo.smem_len);
+  return;
+}
diff -ruN oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/mpcsmon.cfg oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/mpcsmon.cfg
--- oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/mpcsmon.cfg	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/mpcsmon.cfg	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,7 @@
+type=2
+name=MPCS-Monitor
+desc=MPCS-Monitor
+needfb=1
+needlcd=0
+needrc=1
+needoffsets=1
diff -ruN oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/mpcsmon.conf oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/mpcsmon.conf
--- oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/mpcsmon.conf	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/mpcsmon.conf	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,8 @@
+smallfont=1
+#tinyfont=1
+startwithip=0
+hidemonitor=1
+#font=/var/share/fonts/pakenham.ttf
+#pin=1234
+server=mpcsmon://itsme:getin@192.168.1.1:988?label=MyServer
+server=mpcsmon://friend:itsok@remote.host.tld:12345?label=MyFriend
diff -ruN oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/mpcsmon.h oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/mpcsmon.h
--- oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon/mpcsmon.h	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon/mpcsmon.h	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,544 @@
+/******************************************************************************
+ * <<< MPCSMon - Monitor for MPCS >>>                        (w) by dukat 2006
+ ******************************************************************************/
+
+#ifdef DM7025
+#  define MPCSMON_DREAM_7025
+#endif
+
+#ifdef MPCSMON_DREAM_7025
+#  ifndef OLDFT
+#    define OLDFT
+#  endif
+#  ifndef HAVE_DVB_API_VERSION
+#    define HAVE_DVB_API_VERSION 3
+#  endif
+#  define MPCSMON_FB_32BPP
+#  define CFGFILE  "/var/tuxbox/mpcsmon.conf"
+#else
+#  include "config.h"
+#  ifdef HAVE_DREAMBOX_HARDWARE
+#    define MPCSMON_DREAM_PPC
+#    ifndef OLDFT
+#      define OLDFT
+#    endif
+#  endif
+#  if !defined(HAVE_DVB_API_VERSION) && defined(HAVE_OST_DMX_H)
+#    define HAVE_DVB_API_VERSION 1
+#  endif
+#  define CFGFILE  "/var/tuxbox/config/mpcsmon.conf"
+#endif
+
+#include <errno.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <time.h>
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#include FT_CACHE_H
+#include FT_CACHE_SMALL_BITMAPS_H
+
+#if HAVE_DVB_API_VERSION == 3
+#include <linux/input.h>
+struct input_event ev;
+#endif
+
+#ifdef MPCSMON_DREAM_7025
+
+#define	RC_0			'0'
+#define	RC_1			'1'
+#define	RC_2			'2'
+#define	RC_3			'3'
+#define	RC_4			'4'
+#define	RC_5			'5'
+#define	RC_6			'6'
+#define	RC_7			'7'
+#define	RC_8			'8'
+#define	RC_9			'9'
+
+#define	RC_RIGHT	0x0191
+#define	RC_LEFT		0x0192
+#define	RC_UP			0x0193
+#define	RC_DOWN		0x0194
+#define	RC_PLUS		0x0195
+#define	RC_MINUS	0x0196
+
+#define	RC_OK				0x0D
+#define	RC_STANDBY	0x1C
+#define RC_ESC			RC_HOME
+
+#define	RC_HOME			0x01B1
+#define	RC_MUTE			0x01B2
+#define	RC_HELP			0x01B3
+#define	RC_DBOX			0x01B4
+
+#define	RC_GREEN	0x01A1
+#define	RC_YELLOW	0x01A2
+#define	RC_RED		0x01A3
+#define	RC_BLUE		0x01A4
+
+#define RC_PAUSE	RC_HELP
+#define RC_ALTGR	0x12
+#define RC_BS			0x7F
+#define RC_POS1		RC_HOME
+#define RC_END		0x13
+#define RC_INS		0x10
+#define RC_ENTF		0x11
+#define RC_STRG		0x00
+#define RC_LSHIFT	0x0E
+#define RC_RSHIFT	0x0E
+#define RC_ALT		0x0F
+#define RC_NUM		RC_DBOX
+#define RC_ROLLEN	0x00
+#define RC_F5			RC_DBOX
+#define RC_F6			RC_HELP
+#define RC_F7			RC_MUTE
+#define RC_F8			0x01C8
+#define RC_F9			0x01C9
+#define RC_F10		0x01CA
+#define RC_RET		0x0D
+#define RC_RET1		0x01CC
+#define RC_CAPSLOCK	0x01CD
+#define RC_ON			0x01CE
+
+#define RC_F1		RC_RED
+#define RC_F2		RC_GREEN
+#define RC_F3		RC_YELLOW
+#define RC_F4		RC_BLUE
+#define RC_PAGEUP	RC_PLUS
+#define RC_PAGEDOWN	RC_MINUS
+
+#else	// MPCSMON_DREAM_7025
+
+#include <plugin.h>
+
+//rc codes
+
+// #if HAVE_DVB_API_VERSION == 1
+
+#define	RC1_0		0x5C00
+#define	RC1_1		0x5C01
+#define	RC1_2		0x5C02
+#define	RC1_3		0x5C03
+#define	RC1_4		0x5C04
+#define	RC1_5		0x5C05
+#define	RC1_6		0x5C06
+#define	RC1_7		0x5C07
+#define	RC1_8		0x5C08
+#define	RC1_9		0x5C09
+#define	RC1_STANDBY	0x5C0C
+#define	RC1_UP		0x5C0E
+#define	RC1_DOWN	0x5C0F
+#define	RC1_PLUS	0x5C16
+#define	RC1_MINUS	0x5C17
+#define	RC1_HOME	0x5C20
+#define	RC1_DBOX	0x5C27
+#define	RC1_MUTE	0x5C28
+#define	RC1_RED		0x5C2D
+#define	RC1_RIGHT	0x5C2E
+#define	RC1_LEFT	0x5C2F
+#define	RC1_OK		0x5C30
+#define	RC1_BLUE	0x5C3B
+#define	RC1_YELLOW	0x5C52
+#define	RC1_GREEN	0x5C55
+#define	RC1_HELP	0x5C82
+
+// #endif
+
+#define	RC_0		0x00
+#define	RC_1		0x01
+#define	RC_2		0x02
+#define	RC_3		0x03
+#define	RC_4		0x04
+#define	RC_5		0x05
+#define	RC_6		0x06
+#define	RC_7		0x07
+#define	RC_8		0x08
+#define	RC_9		0x09
+#define	RC_RIGHT	0x0A
+#define	RC_LEFT		0x0B
+#define	RC_UP		0x0C
+#define	RC_DOWN		0x0D
+#define	RC_OK		0x0E
+#define	RC_MUTE		0x0F
+#define	RC_STANDBY	0x10
+#define	RC_GREEN	0x11
+#define	RC_YELLOW	0x12
+#define	RC_RED		0x13
+#define	RC_BLUE		0x14
+#define	RC_PLUS		0x15
+#define	RC_MINUS	0x16
+#define	RC_HELP		0x17
+#define	RC_DBOX		0x18
+#define	RC_HOME		0x1F
+
+#endif	// MPCSMON_DREAM_7025
+
+//freetype stuff
+
+#define FONT FONTDIR "/pakenham.ttf"
+
+enum {LEFT, CENTER, RIGHT};
+enum {TINY, SMALL, BIG};
+
+//framebuffer stuff
+static struct fb_fix_screeninfo fix_screeninfo;
+static struct fb_var_screeninfo var_screeninfo;
+
+enum {FILL, GRID};
+enum {TRANSP,
+      BLACK, RED  , GREEN  , BROWN , BLUE  , MAGENTA  , CYAN  , B_GRAY,
+      GRAY , B_RED, B_GREEN, YELLOW, B_BLUE, B_MAGENTA, B_CYAN, WHITE ,
+      BLUE0, BLUE1, BLUE2, BLUE3, ORANGE};
+
+#ifdef MPCSMON_FB_32BPP
+
+static unsigned char bgra[][4] = {
+	"\x00\x00\x00\x00","\x00\x00\x00\xFF","\x00\x00\x80\xFF","\x00\x80\x00\xFF",
+	"\x00\x48\xA0\xFF","\x80\x00\x00\xFF","\x80\x00\x80\xFF","\x80\x80\x00\xFF",
+	"\xA0\xA0\xA0\xFF","\x50\x50\x50\xFF","\x00\x00\xFF\xFF","\x00\xFF\x00\xFF",
+	"\x00\xFF\xFF\xFF","\xFF\x00\x00\xFF","\xFF\x00\xFF\xFF","\xFF\xFF\x00\xFF",
+	"\xFF\xFF\xFF\xFF","\xFF\x80\x00\xF0","\x80\x00\x00\xF0","\xFF\x80\x00\xFF",
+	"\x40\x20\x00\xFF","\x00\xC0\xFF\xFF"
+};
+
+#else	// MPCSMON_FB_32BPP
+
+static unsigned short rd[] = {
+	0x01<<8, 0x80<<8, 0x00<<8, 0xA0<<8, 0x00<<8, 0x80<<8, 0x00<<8, 0xA0<<8,
+	0x50<<8, 0xFF<<8, 0x00<<8, 0xFF<<8, 0x00<<8, 0xFF<<8, 0x00<<8, 0xFF<<8,
+	0x00<<8, 0x00<<8, 0x00<<8, 0x00<<8, 0xFF<<8
+};
+static unsigned short gn[] = {
+	0x01<<8, 0x00<<8, 0x80<<8, 0x48<<8, 0x00<<8, 0x00<<8, 0x80<<8, 0xA0<<8,
+	0x50<<8, 0x00<<8, 0xFF<<8, 0xFF<<8, 0x00<<8, 0x00<<8, 0xFF<<8, 0xFF<<8,
+	0x80<<8, 0x00<<8, 0x80<<8, 0x20<<8, 0xC0<<8
+};
+static unsigned short bl[] = {
+	0x01<<8, 0x00<<8, 0x00<<8, 0x00<<8, 0x80<<8, 0x80<<8, 0x80<<8, 0xA0<<8,
+	0x50<<8, 0x00<<8, 0x00<<8, 0x00<<8, 0xFF<<8, 0xFF<<8, 0xFF<<8, 0xFF<<8,
+	0xFF<<8, 0x80<<8, 0xFF<<8, 0x40<<8, 0x00<<8
+};
+static unsigned short tr[] = {
+	0x00<<8, 0x00<<8, 0x00<<8, 0x00<<8, 0x00<<8, 0x00<<8, 0x00<<8, 0x00<<8,
+	0x00<<8, 0x00<<8, 0x00<<8, 0x00<<8, 0x00<<8, 0x00<<8, 0x00<<8, 0x00<<8,
+	0x0A<<8, 0x0A<<8, 0x00<<8, 0x00<<8, 0x00<<8
+};
+
+static struct fb_cmap colormap = {1, 21, rd, gn, bl, tr};
+
+#endif	// MPCSMON_FB_32BPP
+
+char circle[] =
+{
+	0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,
+	0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,
+	0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,
+	0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
+	0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
+	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+	0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
+	0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
+	0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,
+	0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,
+	0,0,0,0,0,1,1,1,1,1,0,0,0,0,0
+};
+
+#ifdef NOT_USED_YET
+char scroll_up[] =
+{
+	BLUE1, BLUE1, BLUE1, BLUE1, BLUE1, BLUE1, WHITE, WHITE, BLUE1, BLUE1, BLUE1, BLUE1, BLUE1, BLUE1,
+	BLUE1, BLUE1, BLUE1, BLUE1, BLUE1, BLUE1, WHITE, WHITE, BLUE1, BLUE1, BLUE1, BLUE1, BLUE1, BLUE1,
+	BLUE1, BLUE1, BLUE1, BLUE1, BLUE1, WHITE, WHITE, WHITE, WHITE, BLUE1, BLUE1, BLUE1, BLUE1, BLUE1,
+	BLUE1, BLUE1, BLUE1, BLUE1, BLUE1, WHITE, WHITE, WHITE, WHITE, BLUE1, BLUE1, BLUE1, BLUE1, BLUE1,
+	BLUE1, BLUE1, BLUE1, BLUE1, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, BLUE1, BLUE1, BLUE1, BLUE1,
+	BLUE1, BLUE1, BLUE1, BLUE1, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, BLUE1, BLUE1, BLUE1, BLUE1,
+	BLUE1, BLUE1, BLUE1, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, BLUE1, BLUE1, BLUE1,
+	BLUE1, BLUE1, BLUE1, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, BLUE1, BLUE1, BLUE1,
+	BLUE1, BLUE1, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, BLUE1, BLUE1,
+	BLUE1, BLUE1, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, BLUE1, BLUE1,
+	BLUE1, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, BLUE1,
+	BLUE1, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, BLUE1,
+	WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE,
+	WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE
+};
+
+char scroll_dn[] =
+{
+	WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE,
+	WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE,
+	BLUE1, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, BLUE1,
+	BLUE1, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, BLUE1,
+	BLUE1, BLUE1, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, BLUE1, BLUE1,
+	BLUE1, BLUE1, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, BLUE1, BLUE1,
+	BLUE1, BLUE1, BLUE1, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, BLUE1, BLUE1, BLUE1,
+	BLUE1, BLUE1, BLUE1, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, BLUE1, BLUE1, BLUE1,
+	BLUE1, BLUE1, BLUE1, BLUE1, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, BLUE1, BLUE1, BLUE1, BLUE1,
+	BLUE1, BLUE1, BLUE1, BLUE1, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, BLUE1, BLUE1, BLUE1, BLUE1,
+	BLUE1, BLUE1, BLUE1, BLUE1, BLUE1, WHITE, WHITE, WHITE, WHITE, BLUE1, BLUE1, BLUE1, BLUE1, BLUE1,
+	BLUE1, BLUE1, BLUE1, BLUE1, BLUE1, WHITE, WHITE, WHITE, WHITE, BLUE1, BLUE1, BLUE1, BLUE1, BLUE1,
+	BLUE1, BLUE1, BLUE1, BLUE1, BLUE1, BLUE1, WHITE, WHITE, BLUE1, BLUE1, BLUE1, BLUE1, BLUE1, BLUE1,
+	BLUE1, BLUE1, BLUE1, BLUE1, BLUE1, BLUE1, WHITE, WHITE, BLUE1, BLUE1, BLUE1, BLUE1, BLUE1, BLUE1
+};
+
+//lcd stuff
+
+unsigned char lcd_buffer[] =
+{
+	0xE0, 0xF8, 0xFC, 0xFE, 0xFE, 0xFF, 0x7F, 0x7F, 0x7F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0xFF, 0xFF, 0xFF, 0xC7, 0xBB, 0x3B, 0xFB, 0xFB, 0x3B, 0xBB, 0xC7, 0xFF, 0x07, 0xFB, 0xFB, 0x07, 0xFB, 0xFB, 0xFB, 0x07, 0xFF, 0x87, 0x7B, 0xFB, 0xC7, 0xFB, 0x7B, 0x7B, 0x87, 0xFF, 0x07, 0xFB, 0xFB, 0x3B, 0xFB, 0xFB, 0xFB, 0x3B, 0xFB, 0xFB, 0x07, 0xFF, 0x07, 0xFB, 0xFB, 0xBB, 0xFB, 0xFB, 0xFB, 0x07, 0xFF, 0x27, 0xDB, 0xDB, 0x27, 0xFF, 0x07, 0xFB, 0xFB, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x7F, 0x7F, 0x7F, 0xFF, 0xFE, 0xFE, 0xFC, 0xF8, 0xE0,
+	0xFF, 0x7F, 0x7F, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x70, 0x6F, 0x6F, 0x70, 0x7F, 0x7F, 0x7F, 0x70, 0x6F, 0x6F, 0x6C, 0x6F, 0x6F, 0x6F, 0x70, 0x7F, 0x70, 0x6F, 0x6F, 0x71, 0x6F, 0x6F, 0x6F, 0x70, 0x7F, 0x70, 0x6F, 0x6F, 0x70, 0x6F, 0x6F, 0x6F, 0x70, 0x6F, 0x6F, 0x70, 0x7F, 0x70, 0x6F, 0x6F, 0x71, 0x6F, 0x6F, 0x6F, 0x70, 0x7F, 0x70, 0x6F, 0x6F, 0x70, 0x7F, 0x70, 0x6F, 0x6F, 0x6C, 0x6D, 0x6D, 0x6D, 0x73, 0x7F, 0x7F, 0x7F, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7F, 0x7F, 0xFF,
+	0xFF, 0x00, 0x00, 0x00, 0xF8, 0xFC, 0x04, 0xFC, 0xF8, 0x00, 0xFC, 0xFC, 0x30, 0x60, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x40, 0xC0, 0x00, 0xC0, 0x40, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x30, 0xE0, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0xE0, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x30, 0xE0, 0x00, 0x00, 0x00, 0xE0, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x30, 0xE0, 0x00, 0x00, 0x00, 0xC0, 0x20, 0x20, 0x20, 0x20, 0xC0, 0x00, 0x00, 0x00, 0xE0, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x30, 0xE0, 0x00, 0x00, 0x00, 0xE0, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x30, 0xE0, 0x00, 0x00, 0x00, 0xFF,
+	0xFF, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x80, 0xC0, 0xE1, 0x31, 0x18, 0x09, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x77, 0x55, 0xDD, 0x00, 0xDD, 0x55, 0xDD, 0x00, 0xDD, 0x55, 0x77, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xE3, 0x14, 0x14, 0x14, 0x14, 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF,
+	0xFF, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x81, 0x83, 0x9F, 0x9E, 0x8F, 0x87, 0x81, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x81, 0x81, 0x81, 0x80, 0x81, 0x81, 0x81, 0x80, 0x80, 0x80, 0x80, 0x83, 0x86, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x86, 0x83, 0x80, 0x80, 0x80, 0xFF, 0x80, 0x80, 0x80, 0x83, 0x86, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x86, 0x83, 0x80, 0x80, 0x80, 0x83, 0x86, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x86, 0x83, 0x80, 0x80, 0x80, 0x81, 0x82, 0x82, 0x82, 0x82, 0x81, 0x80, 0x80, 0x80, 0x83, 0x86, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x86, 0x83, 0x80, 0x80, 0x80, 0x83, 0x86, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x86, 0x83, 0x80, 0x00, 0x00, 0xFF,
+	0xFF, 0x00, 0x00, 0x00, 0xE0, 0x60, 0x60, 0xA0, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xA0, 0x60, 0x60, 0xE0, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x30, 0xE0, 0x00, 0x00, 0x00, 0xE0, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x30, 0xE0, 0x00, 0x00, 0x00, 0xE0, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x30, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x10, 0x10, 0x10, 0x10, 0xE0, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x30, 0xE0, 0x00, 0x00, 0x00, 0xE0, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x30, 0xE0, 0x00, 0x00, 0x00, 0xE0, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x30, 0xE0, 0x00, 0x00, 0x00, 0xFF,
+	0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x80, 0x40, 0x21, 0x11, 0x0A, 0x06, 0x04, 0x08, 0x08, 0x04, 0x06, 0x0A, 0x11, 0x21, 0x40, 0x80, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x3E, 0x01, 0x00, 0x00, 0xC0, 0x3E, 0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF,
+	0x07, 0x18, 0x20, 0x40, 0x43, 0x83, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x83, 0x83, 0x80, 0x80, 0x80, 0x80, 0x83, 0x86, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x86, 0x83, 0x80, 0x80, 0x80, 0x83, 0x86, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x86, 0x83, 0x80, 0x80, 0x80, 0x83, 0x86, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x86, 0x83, 0x80, 0x80, 0x80, 0x80, 0x83, 0x84, 0x84, 0x84, 0x84, 0x83, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x83, 0x86, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x86, 0x83, 0x80, 0x80, 0x80, 0x83, 0x86, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x86, 0x83, 0x80, 0x80, 0x80, 0x83, 0x86, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x86, 0x43, 0x40, 0x20, 0x18, 0x07
+};
+
+char lcd_status[] =
+{
+	1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,	/* PAU */
+	1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,
+	1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,
+	1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,
+	1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,1,1,
+	1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,1,1,
+	1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,1,
+	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,
+	0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,
+	0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,
+	0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,
+	0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,
+	0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,
+	0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,0,
+	0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,
+	0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,
+
+	0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,0,0,	/* ONL */
+	1,1,0,1,1,0,1,1,0,0,1,1,0,1,1,0,0,
+	1,1,0,1,1,0,1,1,1,0,1,1,0,1,1,0,0,
+	1,1,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,
+	1,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,0,
+	1,1,0,1,1,0,1,1,0,0,1,1,0,1,1,0,0,
+	0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,
+	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,
+	0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,
+	0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,
+
+	0,1,1,1,0,0,1,1,1,1,1,1,0,1,1,0,0,	/* OFL */
+	1,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,
+	1,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,
+	1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,
+	1,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,
+	1,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,
+	0,1,1,1,0,0,0,1,1,0,0,0,0,1,1,1,1,
+	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,
+	0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,0,0,
+	0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,
+	0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,
+	0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,
+	0,0,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+};
+
+char lcd_digits[] =
+{
+	0,1,1,1,1,1,1,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,1,1,0,0,0,1,
+	1,0,0,0,1,1,0,0,0,1,
+	1,0,0,0,1,1,0,0,0,1,
+	1,0,0,0,1,1,0,0,0,1,
+	1,0,0,0,1,1,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,1,1,
+	0,1,1,1,1,1,1,1,1,0,
+
+	0,0,0,1,1,1,1,0,0,0,
+	0,0,1,1,0,0,1,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,1,0,0,1,1,0,0,
+	0,0,0,1,1,1,1,0,0,0,
+
+	0,1,1,1,1,1,1,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	0,1,1,1,1,1,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,1,1,1,1,0,
+	1,0,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,1,1,
+	0,1,1,1,1,1,1,1,1,0,
+
+	0,1,1,1,1,1,1,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	0,1,1,1,1,1,0,0,0,1,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	0,1,1,1,1,1,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,1,1,
+	0,1,1,1,1,1,1,1,1,0,
+
+	0,1,1,1,0,1,1,1,1,0,
+	1,1,0,1,1,1,0,0,1,1,
+	1,0,0,0,1,0,0,0,0,1,
+	1,0,0,0,1,0,0,0,0,1,
+	1,0,0,0,1,0,0,0,0,1,
+	1,0,0,0,1,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	0,1,1,1,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,1,0,0,1,1,
+	0,0,0,0,0,1,1,1,1,0,
+
+	0,1,1,1,1,1,1,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,1,1,1,1,0,
+	1,0,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	0,1,1,1,1,1,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,1,1,
+	0,1,1,1,1,1,1,1,1,0,
+
+	0,1,1,1,1,1,1,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,1,1,1,1,0,
+	1,0,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,1,1,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,1,1,
+	0,1,1,1,1,1,1,1,1,0,
+
+	0,1,1,1,1,1,1,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	0,1,1,1,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,1,0,0,1,1,
+	0,0,0,0,0,1,1,1,1,0,
+
+	0,1,1,1,1,1,1,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,1,1,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,1,1,
+	0,1,1,0,0,0,0,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,1,1,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,1,1,
+	0,1,1,1,1,1,1,1,1,0,
+
+	0,1,1,1,1,1,1,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,1,1,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	0,1,1,1,1,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,1,1,
+	0,1,1,1,1,1,1,1,1,0,
+};
+
+#endif
diff -ruN oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon.sh oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon.sh
--- oscam-emu-2015-12-03-11142.orig/Distribution/monitor/mpcsmon.sh	2012-07-15 00:46:06.000000000 +0400
+++ oscam-emu-2015-12-03-11142/Distribution/monitor/mpcsmon.sh	2015-12-04 00:43:30.000000000 +0300
@@ -1,10 +1,10 @@
 #!/bin/bash
 
-CSHOST="localhost"
+CSHOST="192.168.1.40"
 CSPORT="988"
-USR="user"
-PWD="passwd"
-NETCAT="nc"
+USR="monitor"
+PWD="monitor"
+NETCAT="nc.traditional"
 DELAY=5
 
 get_geo()
diff -ruN oscam-emu-2015-12-03-11142.orig/ffdecsa/CMakeLists.txt oscam-emu-2015-12-03-11142/ffdecsa/CMakeLists.txt
--- oscam-emu-2015-12-03-11142.orig/ffdecsa/CMakeLists.txt	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/ffdecsa/CMakeLists.txt	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,8 @@
+project (ffdecsa)
+
+file (GLOB ffdecsa_srcs "ffdecsa.c")
+file (GLOB ffdecsa_hdrs "*.h")
+
+set (lib_name "ffdecsa")
+
+add_library (${lib_name} STATIC ${ffdecsa_srcs} ${ffdecsa_hdrs})
diff -ruN oscam-emu-2015-12-03-11142.orig/ffdecsa/COPYING oscam-emu-2015-12-03-11142/ffdecsa/COPYING
--- oscam-emu-2015-12-03-11142.orig/ffdecsa/COPYING	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/ffdecsa/COPYING	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,339 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                          675 Mass Ave, Cambridge, MA 02139, USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	Appendix: How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -ruN oscam-emu-2015-12-03-11142.orig/ffdecsa/ffdecsa.c oscam-emu-2015-12-03-11142/ffdecsa/ffdecsa.c
--- oscam-emu-2015-12-03-11142.orig/ffdecsa/ffdecsa.c	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/ffdecsa/ffdecsa.c	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,880 @@
+/* ffdecsa -- fast decsa algorithm
+ *
+ * Copyright (C) 2003-2004  fatih89r
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#include <sys/types.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "ffdecsa.h"
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+//#define DEBUG
+#ifdef DEBUG
+#define DBG(a) a
+#else
+#define DBG(a)
+#endif
+
+//// parallelization stuff, large speed differences are possible
+// possible choices
+#define PARALLEL_32_4CHAR     320
+#define PARALLEL_32_4CHARA    321
+#define PARALLEL_32_INT       322
+#define PARALLEL_64_8CHAR     640
+#define PARALLEL_64_8CHARA    641
+#define PARALLEL_64_2INT      642
+#define PARALLEL_64_LONG      643
+#define PARALLEL_64_MMX       644
+#define PARALLEL_128_16CHAR  1280
+#define PARALLEL_128_16CHARA 1281
+#define PARALLEL_128_4INT    1282
+#define PARALLEL_128_2LONG   1283
+#define PARALLEL_128_2MMX    1284
+#define PARALLEL_128_SSE     1285
+#define PARALLEL_128_SSE2    1286
+
+//////// our choice //////////////// our choice //////////////// our choice //////////////// our choice ////////
+#ifndef PARALLEL_MODE
+#define PARALLEL_MODE PARALLEL_32_INT
+#endif
+//////// our choice //////////////// our choice //////////////// our choice //////////////// our choice ////////
+
+#include "parallel_generic.h"
+//// conditionals
+#if PARALLEL_MODE==PARALLEL_32_4CHAR
+#include "parallel_032_4char.h"
+#elif PARALLEL_MODE==PARALLEL_32_4CHARA
+#include "parallel_032_4charA.h"
+#elif PARALLEL_MODE==PARALLEL_32_INT
+#include "parallel_032_int.h"
+#elif PARALLEL_MODE==PARALLEL_64_8CHAR
+#include "parallel_064_8char.h"
+#elif PARALLEL_MODE==PARALLEL_64_8CHARA
+#include "parallel_064_8charA.h"
+#elif PARALLEL_MODE==PARALLEL_64_2INT
+#include "parallel_064_2int.h"
+#elif PARALLEL_MODE==PARALLEL_64_LONG
+#include "parallel_064_long.h"
+#elif PARALLEL_MODE==PARALLEL_64_MMX
+#include "parallel_064_mmx.h"
+#elif PARALLEL_MODE==PARALLEL_128_16CHAR
+#include "parallel_128_16char.h"
+#elif PARALLEL_MODE==PARALLEL_128_16CHARA
+#include "parallel_128_16charA.h"
+#elif PARALLEL_MODE==PARALLEL_128_4INT
+#include "parallel_128_4int.h"
+#elif PARALLEL_MODE==PARALLEL_128_2LONG
+#include "parallel_128_2long.h"
+#elif PARALLEL_MODE==PARALLEL_128_2MMX
+#include "parallel_128_2mmx.h"
+#elif PARALLEL_MODE==PARALLEL_128_SSE
+#include "parallel_128_sse.h"
+#elif PARALLEL_MODE==PARALLEL_128_SSE2
+#include "parallel_128_sse2.h"
+#else
+#error "unknown/undefined parallel mode"
+#endif
+
+// stuff depending on conditionals
+
+#define BYTES_PER_GROUP (GROUP_PARALLELISM/8)
+#define BYPG BYTES_PER_GROUP
+#define BITS_PER_GROUP GROUP_PARALLELISM
+#define BIPG BITS_PER_GROUP
+
+#ifndef MALLOC
+#define MALLOC(X) malloc(X)
+#endif
+#ifndef FREE
+#define FREE(X) free(X)
+#endif
+#ifndef MEMALIGN
+#define MEMALIGN
+#endif
+
+//// debug tool
+
+#ifdef DEBUG
+static void dump_mem(const char *string, const unsigned char *p, int len, int linelen){
+  int i;
+  for(i=0;i<len;i++){
+    if(i%linelen==0&&i) fprintf(stderr,"\n");
+    if(i%linelen==0) fprintf(stderr,"%s %08x:",string,i);
+    else{
+      if(i%8==0) fprintf(stderr," ");
+      if(i%4==0) fprintf(stderr," ");
+    }
+    fprintf(stderr," %02x",p[i]);
+  }
+  if(i%linelen==0) fprintf(stderr,"\n");
+}
+#endif
+
+//////////////////////////////////////////////////////////////////////////////////
+
+struct csa_key_t{
+	unsigned char ck[8];
+// used by stream
+        int iA[8];  // iA[0] is for A1, iA[7] is for A8
+        int iB[8];  // iB[0] is for B1, iB[7] is for B8
+// used by stream (group)
+        MEMALIGN group ck_g[8][8]; // [byte][bit:0=LSB,7=MSB]
+        MEMALIGN group iA_g[8][4]; // [0 for A1][0 for LSB]
+        MEMALIGN group iB_g[8][4]; // [0 for B1][0 for LSB]
+// used by block
+	unsigned char kk[56];
+// used by block (group)
+	MEMALIGN batch kkmulti[56]; // many times the same byte in every batch
+};
+
+struct csa_keys_t{
+  struct csa_key_t even;
+  struct csa_key_t odd;
+};
+
+//-----stream cypher
+
+//-----key schedule for stream decypher
+static void key_schedule_stream(
+  unsigned char *ck,    // [In]  ck[0]-ck[7]   8 bytes   | Key.
+  int *iA,              // [Out] iA[0]-iA[7]   8 nibbles | Key schedule.
+  int *iB)              // [Out] iB[0]-iB[7]   8 nibbles | Key schedule.
+{
+    iA[0]=(ck[0]>>4)&0xf;
+    iA[1]=(ck[0]   )&0xf;
+    iA[2]=(ck[1]>>4)&0xf;
+    iA[3]=(ck[1]   )&0xf;
+    iA[4]=(ck[2]>>4)&0xf;
+    iA[5]=(ck[2]   )&0xf;
+    iA[6]=(ck[3]>>4)&0xf;
+    iA[7]=(ck[3]   )&0xf;
+    iB[0]=(ck[4]>>4)&0xf;
+    iB[1]=(ck[4]   )&0xf;
+    iB[2]=(ck[5]>>4)&0xf;
+    iB[3]=(ck[5]   )&0xf;
+    iB[4]=(ck[6]>>4)&0xf;
+    iB[5]=(ck[6]   )&0xf;
+    iB[6]=(ck[7]>>4)&0xf;
+    iB[7]=(ck[7]   )&0xf;
+}
+
+//----- stream main function
+
+#define STREAM_INIT
+#include "stream.c"
+#undef STREAM_INIT
+
+#define STREAM_NORMAL
+#include "stream.c"
+#undef STREAM_NORMAL
+
+
+//-----block decypher
+
+//-----key schedule for block decypher
+
+static void key_schedule_block(
+  unsigned char *ck,    // [In]  ck[0]-ck[7]   8 bytes | Key.
+  unsigned char *kk)    // [Out] kk[0]-kk[55] 56 bytes | Key schedule.
+{
+  static const unsigned char key_perm[0x40] = {
+    0x12,0x24,0x09,0x07,0x2A,0x31,0x1D,0x15, 0x1C,0x36,0x3E,0x32,0x13,0x21,0x3B,0x40,
+    0x18,0x14,0x25,0x27,0x02,0x35,0x1B,0x01, 0x22,0x04,0x0D,0x0E,0x39,0x28,0x1A,0x29,
+    0x33,0x23,0x34,0x0C,0x16,0x30,0x1E,0x3A, 0x2D,0x1F,0x08,0x19,0x17,0x2F,0x3D,0x11,
+    0x3C,0x05,0x38,0x2B,0x0B,0x06,0x0A,0x2C, 0x20,0x3F,0x2E,0x0F,0x03,0x26,0x10,0x37,
+  };
+
+  int i,j,k;
+  int bit[64];
+  int newbit[64];
+  int kb[7][8];
+
+  // 56 steps
+  // 56 key bytes kk(55)..kk(0) by key schedule from ck
+
+  // kb(6,0) .. kb(6,7) = ck(0) .. ck(7)
+  kb[6][0] = ck[0];
+  kb[6][1] = ck[1];
+  kb[6][2] = ck[2];
+  kb[6][3] = ck[3];
+  kb[6][4] = ck[4];
+  kb[6][5] = ck[5];
+  kb[6][6] = ck[6];
+  kb[6][7] = ck[7];
+
+  // calculate kb[5] .. kb[0]
+  for(i=5; i>=0; i--){
+    // 64 bit perm on kb
+    for(j=0; j<8; j++){
+      for(k=0; k<8; k++){
+        bit[j*8+k] = (kb[i+1][j] >> (7-k)) & 1;
+        newbit[key_perm[j*8+k]-1] = bit[j*8+k];
+      }
+    }
+    for(j=0; j<8; j++){
+      kb[i][j] = 0;
+      for(k=0; k<8; k++){
+        kb[i][j] |= newbit[j*8+k] << (7-k);
+      }
+    }
+  }
+
+  // xor to give kk
+  for(i=0; i<7; i++){
+    for(j=0; j<8; j++){
+      kk[i*8+j] = kb[i][j] ^ i;
+    }
+  }
+
+}
+
+//-----block utils
+
+static inline __attribute__((always_inline)) void trasp_N_8 (unsigned char *in,unsigned char* out,int count){
+  int *ri=(int *)in;
+  int *ibi=(int *)out;
+  int j,i,k,g;
+  // copy and first step
+  for(g=0;g<count;g++){
+    ri[g]=ibi[2*g];
+    ri[GROUP_PARALLELISM+g]=ibi[2*g+1];
+  }
+//dump_mem("NE1 r[roff]",&r[roff],GROUP_PARALLELISM*8,GROUP_PARALLELISM);
+// now 01230123
+#define INTS_PER_ROW (GROUP_PARALLELISM/8*2)
+  for(j=0;j<8;j+=4){
+    for(i=0;i<2;i++){
+      for(k=0;k<INTS_PER_ROW;k++){
+        unsigned int t,b;
+        t=ri[INTS_PER_ROW*(j+i)+k];
+        b=ri[INTS_PER_ROW*(j+i+2)+k];
+        ri[INTS_PER_ROW*(j+i)+k]=     (t&0x0000ffff)      | ((b           )<<16);
+        ri[INTS_PER_ROW*(j+i+2)+k]=  ((t           )>>16) |  (b&0xffff0000) ;
+      }
+    }
+  }
+//dump_mem("NE2 r[roff]",&r[roff],GROUP_PARALLELISM*8,GROUP_PARALLELISM);
+// now 01010101
+  for(j=0;j<8;j+=2){
+    for(i=0;i<1;i++){
+      for(k=0;k<INTS_PER_ROW;k++){
+        unsigned int t,b;
+        t=ri[INTS_PER_ROW*(j+i)+k];
+        b=ri[INTS_PER_ROW*(j+i+1)+k];
+        ri[INTS_PER_ROW*(j+i)+k]=     (t&0x00ff00ff)     | ((b&0x00ff00ff)<<8);
+        ri[INTS_PER_ROW*(j+i+1)+k]=  ((t&0xff00ff00)>>8) |  (b&0xff00ff00);
+      }
+    }
+  }
+//dump_mem("NE3 r[roff]",&r[roff],GROUP_PARALLELISM*8,GROUP_PARALLELISM);
+// now 00000000
+}
+
+static inline __attribute__((always_inline)) void trasp_8_N (unsigned char *in,unsigned char* out,int count){
+  int *ri=(int *)in;
+  int *bdi=(int *)out;
+  int j,i,k,g;
+#define INTS_PER_ROW (GROUP_PARALLELISM/8*2)
+//dump_mem("NE1 r[roff]",&r[roff],GROUP_PARALLELISM*8,GROUP_PARALLELISM);
+// now 00000000
+  for(j=0;j<8;j+=2){
+    for(i=0;i<1;i++){
+      for(k=0;k<INTS_PER_ROW;k++){
+        unsigned int t,b;
+        t=ri[INTS_PER_ROW*(j+i)+k];
+        b=ri[INTS_PER_ROW*(j+i+1)+k];
+        ri[INTS_PER_ROW*(j+i)+k]=     (t&0x00ff00ff)     | ((b&0x00ff00ff)<<8);
+        ri[INTS_PER_ROW*(j+i+1)+k]=  ((t&0xff00ff00)>>8) |  (b&0xff00ff00);
+      }
+    }
+  }
+//dump_mem("NE2 r[roff]",&r[roff],GROUP_PARALLELISM*8,GROUP_PARALLELISM);
+// now 01010101
+  for(j=0;j<8;j+=4){
+    for(i=0;i<2;i++){
+      for(k=0;k<INTS_PER_ROW;k++){
+        unsigned int t,b;
+        t=ri[INTS_PER_ROW*(j+i)+k];
+        b=ri[INTS_PER_ROW*(j+i+2)+k];
+        ri[INTS_PER_ROW*(j+i)+k]=     (t&0x0000ffff)      | ((b           )<<16);
+        ri[INTS_PER_ROW*(j+i+2)+k]=  ((t           )>>16) |  (b&0xffff0000) ;
+      }
+    }
+  }
+//dump_mem("NE3 r[roff]",&r[roff],GROUP_PARALLELISM*8,GROUP_PARALLELISM);
+// now 01230123
+  for(g=0;g<count;g++){
+    bdi[2*g]=ri[g];
+    bdi[2*g+1]=ri[GROUP_PARALLELISM+g];
+  }
+}
+
+//-----block main function
+
+// block group
+static void block_decypher_group(
+  batch *kkmulti,       // [In]  kkmulti[0]-kkmulti[55] 56 batches | Key schedule (each batch has repeated equal bytes).
+  unsigned char *ib,    // [In]  (ib0,ib1,...ib7)...x32 32*8 bytes | Initialization vector.
+  unsigned char *bd,    // [Out] (bd0,bd1,...bd7)...x32 32*8 bytes | Block decipher.
+  int count)
+{
+  // int is faster than unsigned char. apparently not
+  static const unsigned char block_sbox[0x100] = {
+    0x3A,0xEA,0x68,0xFE,0x33,0xE9,0x88,0x1A, 0x83,0xCF,0xE1,0x7F,0xBA,0xE2,0x38,0x12,
+    0xE8,0x27,0x61,0x95,0x0C,0x36,0xE5,0x70, 0xA2,0x06,0x82,0x7C,0x17,0xA3,0x26,0x49,
+    0xBE,0x7A,0x6D,0x47,0xC1,0x51,0x8F,0xF3, 0xCC,0x5B,0x67,0xBD,0xCD,0x18,0x08,0xC9,
+    0xFF,0x69,0xEF,0x03,0x4E,0x48,0x4A,0x84, 0x3F,0xB4,0x10,0x04,0xDC,0xF5,0x5C,0xC6,
+    0x16,0xAB,0xAC,0x4C,0xF1,0x6A,0x2F,0x3C, 0x3B,0xD4,0xD5,0x94,0xD0,0xC4,0x63,0x62,
+    0x71,0xA1,0xF9,0x4F,0x2E,0xAA,0xC5,0x56, 0xE3,0x39,0x93,0xCE,0x65,0x64,0xE4,0x58,
+    0x6C,0x19,0x42,0x79,0xDD,0xEE,0x96,0xF6, 0x8A,0xEC,0x1E,0x85,0x53,0x45,0xDE,0xBB,
+    0x7E,0x0A,0x9A,0x13,0x2A,0x9D,0xC2,0x5E, 0x5A,0x1F,0x32,0x35,0x9C,0xA8,0x73,0x30,
+
+    0x29,0x3D,0xE7,0x92,0x87,0x1B,0x2B,0x4B, 0xA5,0x57,0x97,0x40,0x15,0xE6,0xBC,0x0E,
+    0xEB,0xC3,0x34,0x2D,0xB8,0x44,0x25,0xA4, 0x1C,0xC7,0x23,0xED,0x90,0x6E,0x50,0x00,
+    0x99,0x9E,0x4D,0xD9,0xDA,0x8D,0x6F,0x5F, 0x3E,0xD7,0x21,0x74,0x86,0xDF,0x6B,0x05,
+    0x8E,0x5D,0x37,0x11,0xD2,0x28,0x75,0xD6, 0xA7,0x77,0x24,0xBF,0xF0,0xB0,0x02,0xB7,
+    0xF8,0xFC,0x81,0x09,0xB1,0x01,0x76,0x91, 0x7D,0x0F,0xC8,0xA0,0xF2,0xCB,0x78,0x60,
+    0xD1,0xF7,0xE0,0xB5,0x98,0x22,0xB3,0x20, 0x1D,0xA6,0xDB,0x7B,0x59,0x9F,0xAE,0x31,
+    0xFB,0xD3,0xB6,0xCA,0x43,0x72,0x07,0xF4, 0xD8,0x41,0x14,0x55,0x0D,0x54,0x8B,0xB9,
+    0xAD,0x46,0x0B,0xAF,0x80,0x52,0x2C,0xFA, 0x8C,0x89,0x66,0xFD,0xB2,0xA9,0x9B,0xC0,
+  };
+  MEMALIGN unsigned char r[GROUP_PARALLELISM*(8+56)];  /* 56 because we will move back in memory while looping */
+  MEMALIGN unsigned char sbox_in[GROUP_PARALLELISM],sbox_out[GROUP_PARALLELISM],perm_out[GROUP_PARALLELISM];
+  int roff;
+  int i,g,count_all=GROUP_PARALLELISM;
+
+  roff=GROUP_PARALLELISM*56;
+
+#define FASTTRASP1
+#ifndef FASTTRASP1
+  for(g=0;g<count;g++){
+    // Init registers 
+    int j;
+    for(j=0;j<8;j++){
+      r[roff+GROUP_PARALLELISM*j+g]=ib[8*g+j];
+    }
+  }
+#else
+  trasp_N_8((unsigned char *)&r[roff],(unsigned char *)ib,count);
+#endif
+//dump_mem("OLD r[roff]",&r[roff],GROUP_PARALLELISM*8,GROUP_PARALLELISM);
+
+  // loop over kk[55]..kk[0]
+  for(i=55;i>=0;i--){
+    {
+      MEMALIGN batch tkkmulti=kkmulti[i];
+      batch *si=(batch *)sbox_in;
+      batch *r6_N=(batch *)(r+roff+GROUP_PARALLELISM*6);
+      for(g=0;g<count_all/BYTES_PER_BATCH;g++){
+        si[g]=B_FFXOR(tkkmulti,r6_N[g]);              //FIXME: introduce FASTBATCH?
+      }
+    }
+
+    // table lookup, this works on only one byte at a time
+    // most difficult part of all
+    // - can't be parallelized
+    // - can't be synthetized through boolean terms (8 input bits are too many)
+    for(g=0;g<count_all;g++){
+      sbox_out[g]=block_sbox[sbox_in[g]];
+    }
+
+    // bit permutation
+    {
+      unsigned char *po=(unsigned char *)perm_out;
+      unsigned char *so=(unsigned char *)sbox_out;
+//dump_mem("pre perm ",(unsigned char *)so,GROUP_PARALLELISM,GROUP_PARALLELISM);
+      for(g=0;g<count_all;g+=BYTES_PER_BATCH){
+        MEMALIGN batch in,out;
+        in=*(batch *)&so[g];
+
+        out=B_FFOR(
+	    B_FFOR(
+	    B_FFOR(
+	    B_FFOR(
+	    B_FFOR(
+	           B_FFSH8L(B_FFAND(in,B_FFN_ALL_29()),1),
+	           B_FFSH8L(B_FFAND(in,B_FFN_ALL_02()),6)),
+	           B_FFSH8L(B_FFAND(in,B_FFN_ALL_04()),3)),
+	           B_FFSH8R(B_FFAND(in,B_FFN_ALL_10()),2)),
+	           B_FFSH8R(B_FFAND(in,B_FFN_ALL_40()),6)),
+	           B_FFSH8R(B_FFAND(in,B_FFN_ALL_80()),4));
+
+        *(batch *)&po[g]=out;
+      }
+//dump_mem("post perm",(unsigned char *)po,GROUP_PARALLELISM,GROUP_PARALLELISM);
+    }
+
+    roff-=GROUP_PARALLELISM; /* virtual shift of registers */
+
+#if 0
+/* one by one */
+    for(g=0;g<count_all;g++){
+      r[roff+GROUP_PARALLELISM*0+g]=r[roff+GROUP_PARALLELISM*8+g]^sbox_out[g];
+      r[roff+GROUP_PARALLELISM*6+g]^=perm_out[g];
+      r[roff+GROUP_PARALLELISM*4+g]^=r[roff+GROUP_PARALLELISM*0+g];
+      r[roff+GROUP_PARALLELISM*3+g]^=r[roff+GROUP_PARALLELISM*0+g];
+      r[roff+GROUP_PARALLELISM*2+g]^=r[roff+GROUP_PARALLELISM*0+g];
+    }
+#else
+    for(g=0;g<count_all;g+=BEST_SPAN){
+      XOR_BEST_BY(&r[roff+GROUP_PARALLELISM*0+g],&r[roff+GROUP_PARALLELISM*8+g],&sbox_out[g]);
+      XOREQ_BEST_BY(&r[roff+GROUP_PARALLELISM*6+g],&perm_out[g]);
+      XOREQ_BEST_BY(&r[roff+GROUP_PARALLELISM*4+g],&r[roff+GROUP_PARALLELISM*0+g]);
+      XOREQ_BEST_BY(&r[roff+GROUP_PARALLELISM*3+g],&r[roff+GROUP_PARALLELISM*0+g]);
+      XOREQ_BEST_BY(&r[roff+GROUP_PARALLELISM*2+g],&r[roff+GROUP_PARALLELISM*0+g]);
+    }
+#endif
+  }
+
+#define FASTTRASP2
+#ifndef FASTTRASP2
+  for(g=0;g<count;g++){
+    // Copy results
+    int j;
+    for(j=0;j<8;j++){
+      bd[8*g+j]=r[roff+GROUP_PARALLELISM*j+g];
+    }
+  }
+#else
+  trasp_8_N((unsigned char *)&r[roff],(unsigned char *)bd,count);
+#endif
+}
+
+//-----------------------------------EXTERNAL INTERFACE
+
+//-----get internal parallelism
+
+int get_internal_parallelism(void){
+  return GROUP_PARALLELISM;
+}
+
+//-----get suggested cluster size
+
+int get_suggested_cluster_size(void){
+  int r;
+  r=GROUP_PARALLELISM+GROUP_PARALLELISM/10;
+  if(r<GROUP_PARALLELISM+5) r=GROUP_PARALLELISM+5;
+  return r;
+}
+
+//-----key structure
+
+void *get_key_struct(void){
+  struct csa_keys_t *keys=(struct csa_keys_t *)MALLOC(sizeof(struct csa_keys_t));
+  if(keys) {
+    static const unsigned char pk[8] = { 0,0,0,0,0,0,0,0 };
+    set_control_words(keys,pk,pk);
+    }
+  return keys;
+}
+
+void free_key_struct(void *keys){
+  return FREE(keys);
+}
+
+//-----set control words
+
+static void schedule_key(struct csa_key_t *key, const unsigned char *pk){
+  // could be made faster, but is not run often
+  int bi,by;
+  int i,j;
+// key
+  memcpy(key->ck,pk,8);
+// precalculations for stream
+  key_schedule_stream(key->ck,key->iA,key->iB);
+  for(by=0;by<8;by++){
+    for(bi=0;bi<8;bi++){
+      key->ck_g[by][bi]=(key->ck[by]&(1<<bi))?FFDECSA_FF1():FFDECSA_FF0();
+    }
+  }
+  for(by=0;by<8;by++){
+    for(bi=0;bi<4;bi++){
+      key->iA_g[by][bi]=(key->iA[by]&(1<<bi))?FFDECSA_FF1():FFDECSA_FF0();
+      key->iB_g[by][bi]=(key->iB[by]&(1<<bi))?FFDECSA_FF1():FFDECSA_FF0();
+    }
+  }
+// precalculations for block
+  key_schedule_block(key->ck,key->kk);
+  for(i=0;i<56;i++){
+    for(j=0;j<BYTES_PER_BATCH;j++){
+      *(((unsigned char *)&key->kkmulti[i])+j)=key->kk[i];
+    }
+  }
+}
+
+void set_control_words(void *keys, const unsigned char *ev, const unsigned char *od){
+  schedule_key(&((struct csa_keys_t *)keys)->even,ev);
+  schedule_key(&((struct csa_keys_t *)keys)->odd,od);
+}
+
+void set_even_control_word(void *keys, const unsigned char *pk){
+  schedule_key(&((struct csa_keys_t *)keys)->even,pk);
+}
+
+void set_odd_control_word(void *keys, const unsigned char *pk){
+  schedule_key(&((struct csa_keys_t *)keys)->odd,pk);
+}
+
+//-----get control words
+
+void get_control_words(void *keys, unsigned char *even, unsigned char *odd){
+  memcpy(even,&((struct csa_keys_t *)keys)->even.ck,8);
+  memcpy(odd,&((struct csa_keys_t *)keys)->odd.ck,8);
+}
+
+//----- decrypt
+
+int decrypt_packets(void *keys, unsigned char **cluster){
+  // statistics, currently unused
+  int stat_no_scramble=0;
+  int stat_reserved=0;
+  int stat_decrypted[2]={0,0};
+  int stat_decrypted_mini=0;
+  unsigned char **clst;
+  unsigned char **clst2;
+  int grouped;
+  int group_ev_od;
+  int advanced;
+  int can_advance;
+  unsigned char *g_pkt[GROUP_PARALLELISM];
+  int g_len[GROUP_PARALLELISM];
+  int g_offset[GROUP_PARALLELISM];
+  int g_n[GROUP_PARALLELISM];
+  int g_residue[GROUP_PARALLELISM];
+  unsigned char *pkt;
+  int xc0,ev_od,len,offset,n,residue;
+  struct csa_key_t* k;
+  int i,j,iter,g;
+  int t23,tsmall;
+  int alive[24];
+//icc craziness  int pad1=0; //////////align! FIXME
+  unsigned char *encp[GROUP_PARALLELISM];
+  MEMALIGN unsigned char stream_in[GROUP_PARALLELISM*8];
+  MEMALIGN unsigned char stream_out[GROUP_PARALLELISM*8];
+  MEMALIGN unsigned char ib[GROUP_PARALLELISM*8];
+  MEMALIGN unsigned char block_out[GROUP_PARALLELISM*8];
+  struct stream_regs regs;
+
+//icc craziness  i=(int)&pad1;//////////align!!! FIXME
+
+  // build a list of packets to be processed
+  clst=cluster;
+  grouped=0;
+  advanced=0;
+  can_advance=1;
+  group_ev_od=-1; // silence incorrect compiler warning
+  pkt=*clst;
+  do{ // find a new packet
+    if(grouped==GROUP_PARALLELISM){
+      // full
+      break;
+    }
+    if(pkt==NULL){
+      // no more ranges
+      break;
+    }
+    if(pkt>=*(clst+1)){
+      // out of this range, try next
+      clst++;clst++;
+      pkt=*clst;
+      continue;
+    }
+
+    do{ // handle this packet
+      xc0=pkt[3]&0xc0;
+      DBG(fprintf(stderr,"   exam pkt=%p, xc0=%02x, can_adv=%i\n",pkt,xc0,can_advance));
+      if(xc0==0x00){
+        DBG(fprintf(stderr,"skip clear pkt %p (can_advance is %i)\n",pkt,can_advance));
+        advanced+=can_advance;
+        stat_no_scramble++;
+        break;
+      }
+      if(xc0==0x40){
+        DBG(fprintf(stderr,"skip reserved pkt %p (can_advance is %i)\n",pkt,can_advance));
+        advanced+=can_advance;
+        stat_reserved++;
+        break;
+      }
+      if(xc0==0x80||xc0==0xc0){ // encrypted
+        ev_od=(xc0&0x40)>>6; // 0 even, 1 odd
+        if(grouped==0) group_ev_od=ev_od; // this group will be all even (or odd)
+        if(group_ev_od==ev_od){ // could be added to group
+          pkt[3]&=0x3f;  // consider it decrypted now
+          if(pkt[3]&0x20){ // incomplete packet
+            offset=4+pkt[4]+1;
+            len=188-offset;
+            n=len>>3;
+            residue=len-(n<<3);
+            if(n==0){ // decrypted==encrypted!
+              DBG(fprintf(stderr,"DECRYPTED MINI! (can_advance is %i)\n",can_advance));
+              advanced+=can_advance;
+              stat_decrypted_mini++;
+              break; // this doesn't need more processing
+            }
+          }else{
+            len=184;
+            offset=4;
+            n=23;
+            residue=0;
+          }
+          g_pkt[grouped]=pkt;
+          g_len[grouped]=len;
+          g_offset[grouped]=offset;
+          g_n[grouped]=n;
+          g_residue[grouped]=residue;
+          DBG(fprintf(stderr,"%2i: eo=%i pkt=%p len=%03i n=%2i residue=%i\n",grouped,ev_od,pkt,len,n,residue));
+          grouped++;
+          advanced+=can_advance;
+          stat_decrypted[ev_od]++;
+        }
+        else{
+          can_advance=0;
+          DBG(fprintf(stderr,"skip pkt %p and can_advance set to 0\n",pkt));
+          break; // skip and go on
+        }
+      }
+    } while(0);
+
+    if(can_advance){
+      // move range start forward
+      *clst+=188;
+    }
+    // next packet, if there is one
+    pkt+=188;
+  } while(1);
+  DBG(fprintf(stderr,"-- result: grouped %i pkts, advanced %i pkts\n",grouped,advanced));
+
+  // delete empty ranges and compact list
+  clst2=cluster;
+  for(clst=cluster;*clst!=NULL;clst+=2){
+    // if not empty
+    if(*clst<*(clst+1)){
+      // it will remain 
+      *clst2=*clst;
+      *(clst2+1)=*(clst+1);
+      clst2+=2;
+    }
+  }
+  *clst2=NULL;
+
+  if(grouped==0){
+    // no processing needed
+    return advanced;
+  }
+
+  //  sort them, longest payload first
+  //  we expect many n=23 packets and a few n<23
+  DBG(fprintf(stderr,"PRESORTING\n"));
+  for(i=0;i<grouped;i++){
+    DBG(fprintf(stderr,"%2i of %2i: pkt=%p len=%03i n=%2i residue=%i\n",i,grouped,g_pkt[i],g_len[i],g_n[i],g_residue[i]));
+    }
+  // grouped is always <= GROUP_PARALLELISM
+
+#define g_swap(a,b) \
+    pkt=g_pkt[a]; \
+    g_pkt[a]=g_pkt[b]; \
+    g_pkt[b]=pkt; \
+\
+    len=g_len[a]; \
+    g_len[a]=g_len[b]; \
+    g_len[b]=len; \
+\
+    offset=g_offset[a]; \
+    g_offset[a]=g_offset[b]; \
+    g_offset[b]=offset; \
+\
+    n=g_n[a]; \
+    g_n[a]=g_n[b]; \
+    g_n[b]=n; \
+\
+    residue=g_residue[a]; \
+    g_residue[a]=g_residue[b]; \
+    g_residue[b]=residue;
+
+  // step 1: move n=23 packets before small packets
+  t23=0;
+  tsmall=grouped-1;
+  for(;;){
+    for(;t23<grouped;t23++){
+      if(g_n[t23]!=23) break;
+    }
+DBG(fprintf(stderr,"t23 after for =%i\n",t23));
+    
+    for(;tsmall>=0;tsmall--){
+      if(g_n[tsmall]==23) break;
+    }
+DBG(fprintf(stderr,"tsmall after for =%i\n",tsmall));
+    
+    if(tsmall-t23<1) break;
+    
+DBG(fprintf(stderr,"swap t23=%i,tsmall=%i\n",t23,tsmall));
+
+    g_swap(t23,tsmall);
+
+    t23++;
+    tsmall--;
+DBG(fprintf(stderr,"new t23=%i,tsmall=%i\n\n",t23,tsmall));
+  }
+  DBG(fprintf(stderr,"packets with n=23, t23=%i   grouped=%i\n",t23,grouped));
+  DBG(fprintf(stderr,"MIDSORTING\n"));
+  for(i=0;i<grouped;i++){
+    DBG(fprintf(stderr,"%2i of %2i: pkt=%p len=%03i n=%2i residue=%i\n",i,grouped,g_pkt[i],g_len[i],g_n[i],g_residue[i]));
+    }
+
+  // step 2: sort small packets in decreasing order of n (bubble sort is enough)
+  for(i=t23;i<grouped;i++){
+    for(j=i+1;j<grouped;j++){
+      if(g_n[j]>g_n[i]){
+        g_swap(i,j);
+      }
+    }
+  }
+  DBG(fprintf(stderr,"POSTSORTING\n"));
+  for(i=0;i<grouped;i++){
+    DBG(fprintf(stderr,"%2i of %2i: pkt=%p len=%03i n=%2i residue=%i\n",i,grouped,g_pkt[i],g_len[i],g_n[i],g_residue[i]));
+    }
+
+  // we need to know how many packets need 23 iterations, how many 22...
+  for(i=0;i<=23;i++){
+    alive[i]=0;
+  }
+  // count
+  alive[23-1]=t23;
+  for(i=t23;i<grouped;i++){
+    alive[g_n[i]-1]++;
+  }
+  // integrate
+  for(i=22;i>=0;i--){
+    alive[i]+=alive[i+1];
+  }
+  DBG(fprintf(stderr,"ALIVE\n"));
+  for(i=0;i<=23;i++){
+    DBG(fprintf(stderr,"alive%2i=%i\n",i,alive[i]));
+    }
+
+  // choose key
+  if(group_ev_od==0){
+    k=&((struct csa_keys_t *)keys)->even;
+  }
+  else{
+    k=&((struct csa_keys_t *)keys)->odd;
+  }
+
+  //INIT
+//#define INITIALIZE_UNUSED_INPUT
+#ifdef INITIALIZE_UNUSED_INPUT
+// unnecessary zeroing.
+// without this, we operate on uninitialized memory
+// when grouped<GROUP_PARALLELISM, but it's not a problem,
+// as final results will be discarded.
+// random data makes debugging sessions difficult.
+  for(j=0;j<GROUP_PARALLELISM*8;j++) stream_in[j]=0;
+DBG(fprintf(stderr,"--- WARNING: you could gain speed by not initializing unused memory ---\n"));
+#else
+DBG(fprintf(stderr,"--- WARNING: DEBUGGING IS MORE DIFFICULT WHEN PROCESSING RANDOM DATA CHANGING AT EVERY RUN! ---\n"));
+#endif
+
+  for(g=0;g<grouped;g++){
+    encp[g]=g_pkt[g];
+    DBG(fprintf(stderr,"header[%i]=%p (%02x)\n",g,encp[g],*(encp[g])));
+    encp[g]+=g_offset[g]; // skip header
+    FFTABLEIN(stream_in,g,encp[g]);
+  }
+//dump_mem("stream_in",stream_in,GROUP_PARALLELISM*8,BYPG);
+
+
+  // ITER 0
+DBG(fprintf(stderr,">>>>>ITER 0\n"));
+  iter=0;
+  stream_cypher_group_init(&regs,k->iA_g,k->iB_g,stream_in);
+  // fill first ib
+  for(g=0;g<alive[iter];g++){
+    COPY_8_BY(ib+8*g,encp[g]);
+  }
+DBG(dump_mem("IB ",ib,8*alive[iter],8));
+  // ITER 1..N-1
+  for (iter=1;iter<23&&alive[iter-1]>0;iter++){
+DBG(fprintf(stderr,">>>>>ITER %i\n",iter));
+    // alive and just dead packets: calc block
+    block_decypher_group(k->kkmulti,ib,block_out,alive[iter-1]);
+DBG(dump_mem("BLO_ib ",block_out,8*alive[iter-1],8));
+    // all packets (dead too): calc stream
+    stream_cypher_group_normal(&regs,stream_out);
+//dump_mem("stream_out",stream_out,GROUP_PARALLELISM*8,BYPG);
+
+    // alive packets: calc ib
+    for(g=0;g<alive[iter];g++){
+      FFTABLEOUT(ib+8*g,stream_out,g);
+DBG(dump_mem("stream_out_ib ",ib+8*g,8,8));
+// XOREQ8BY gcc bug? 2x4 ok, 8 ko    UPDATE: result ok but speed 1-2% slower (!!!???)
+#if 1
+      XOREQ_4_BY(ib+8*g,encp[g]+8);
+      XOREQ_4_BY(ib+8*g+4,encp[g]+8+4);
+#else
+      XOREQ_8_BY(ib+8*g,encp[g]+8);
+#endif
+DBG(dump_mem("after_stream_xor_ib ",ib+8*g,8,8));
+    }
+    // alive packets: decrypt data
+    for(g=0;g<alive[iter];g++){
+DBG(dump_mem("before_ib_decrypt_data ",encp[g],8,8));
+      XOR_8_BY(encp[g],ib+8*g,block_out+8*g);
+DBG(dump_mem("after_ib_decrypt_data ",encp[g],8,8));
+    }
+    // just dead packets: write decrypted data
+    for(g=alive[iter];g<alive[iter-1];g++){
+DBG(dump_mem("jd_before_ib_decrypt_data ",encp[g],8,8));
+      COPY_8_BY(encp[g],block_out+8*g);
+DBG(dump_mem("jd_after_ib_decrypt_data ",encp[g],8,8));
+    }
+    // just dead packets: decrypt residue
+    for(g=alive[iter];g<alive[iter-1];g++){
+DBG(dump_mem("jd_before_decrypt_residue ",encp[g]+8,g_residue[g],g_residue[g]));
+      FFTABLEOUTXORNBY(g_residue[g],encp[g]+8,stream_out,g);
+DBG(dump_mem("jd_after_decrypt_residue ",encp[g]+8,g_residue[g],g_residue[g]));
+    }
+    // alive packets: pointers++
+    for(g=0;g<alive[iter];g++) encp[g]+=8;
+  };
+  // ITER N
+DBG(fprintf(stderr,">>>>>ITER 23\n"));
+  iter=23;
+  // calc block
+  block_decypher_group(k->kkmulti,ib,block_out,alive[iter-1]);
+DBG(dump_mem("23BLO_ib ",block_out,8*alive[iter-1],8));
+  // just dead packets: write decrypted data
+  for(g=alive[iter];g<alive[iter-1];g++){
+DBG(dump_mem("23jd_before_ib_decrypt_data ",encp[g],8,8));
+    COPY_8_BY(encp[g],block_out+8*g);
+DBG(dump_mem("23jd_after_ib_decrypt_data ",encp[g],8,8));
+  }
+  // no residue possible
+  // so do nothing
+
+  DBG(fprintf(stderr,"returning advanced=%i\n",advanced));
+
+  M_EMPTY(); // restore CPU multimedia state
+
+  return advanced;
+}
diff -ruN oscam-emu-2015-12-03-11142.orig/ffdecsa/ffdecsa.h oscam-emu-2015-12-03-11142/ffdecsa/ffdecsa.h
--- oscam-emu-2015-12-03-11142.orig/ffdecsa/ffdecsa.h	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/ffdecsa/ffdecsa.h	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,62 @@
+/* ffdecsa -- fast decsa algorithm
+ *
+ * Copyright (C) 2003-2004  fatih89r
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef FFDECSA_H
+#define FFDECSA_H
+
+//----- public interface
+
+// -- how many packets can be decrypted at the same time
+// This is an info about internal decryption parallelism.
+// You should try to call decrypt_packets with more packets than the number
+// returned here for performance reasons (use get_suggested_cluster_size to know
+// how many).
+int get_internal_parallelism(void);
+
+// -- how many packets you should have in a cluster when calling decrypt_packets
+// This is a suggestion to achieve optimal performance; typically a little
+// higher than what get_internal_parallelism returns.
+// Passing less packets could slow down the decryption.
+// Passing more packets is never bad (if you don't spend a lot of time building
+// the list).
+int get_suggested_cluster_size(void);
+
+// -- alloc & free the key structure
+void *get_key_struct(void);
+void free_key_struct(void *keys);
+
+// -- set control words, 8 bytes each
+void set_control_words(void *keys, const unsigned char *even, const unsigned char *odd);
+
+// -- set even control word, 8 bytes
+void set_even_control_word(void *keys, const unsigned char *even);
+
+// -- set odd control word, 8 bytes
+void set_odd_control_word(void *keys, const unsigned char *odd);
+
+// -- get control words, 8 bytes each
+//void get_control_words(void *keys, unsigned char *even, unsigned char *odd);
+
+// -- decrypt many TS packets
+// This interface is a bit complicated because it is designed for maximum speed.
+// Please read doc/how_to_use.txt.
+int decrypt_packets(void *keys, unsigned char **cluster);
+
+#endif
diff -ruN oscam-emu-2015-12-03-11142.orig/ffdecsa/fftable.h oscam-emu-2015-12-03-11142/ffdecsa/fftable.h
--- oscam-emu-2015-12-03-11142.orig/ffdecsa/fftable.h	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/ffdecsa/fftable.h	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,56 @@
+/* ffdecsa -- fast decsa algorithm
+ *
+ * Copyright (C) 2007 Dark Avenger
+ *               2003-2004  fatih89r
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef FFTABLE_H
+#define FFTABLE_H
+
+void static inline FFTABLEIN(unsigned char *tab, int g, unsigned char *data)
+{
+#if 0
+  *(((int *)tab)+2*g)=*((int *)data);
+  *(((int *)tab)+2*g+1)=*(((int *)data)+1);
+#else
+  *(((long long *)tab)+g)=*((long long *)data);
+#endif
+}
+
+void static inline FFTABLEOUT(unsigned char *data, unsigned char *tab, int g)
+{
+#if 1
+  *((int *)data)=*(((int *)tab)+2*g);
+  *(((int *)data)+1)=*(((int *)tab)+2*g+1);
+#else
+  *((long long *)data)=*(((long long *)tab)+g);
+#endif
+}
+
+void static inline FFTABLEOUTXORNBY(int n, unsigned char *data, unsigned char *tab, int g)
+{
+  int j;
+  for(j=0;j<n;j++) *(data+j)^=*(tab+8*g+j);
+}
+
+#undef XOREQ_BEST_BY
+static inline void XOREQ_BEST_BY(unsigned char *d, unsigned char *s)
+{
+	XOR_BEST_BY(d, d, s);
+}
+
+#endif //FFTABLE_H 
diff -ruN oscam-emu-2015-12-03-11142.orig/ffdecsa/Makefile oscam-emu-2015-12-03-11142/ffdecsa/Makefile
--- oscam-emu-2015-12-03-11142.orig/ffdecsa/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/ffdecsa/Makefile	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,2 @@
+parent:
+	@$(MAKE) --no-print-directory -C ..
diff -ruN oscam-emu-2015-12-03-11142.orig/ffdecsa/parallel_032_int.h oscam-emu-2015-12-03-11142/ffdecsa/parallel_032_int.h
--- oscam-emu-2015-12-03-11142.orig/ffdecsa/parallel_032_int.h	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/ffdecsa/parallel_032_int.h	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,55 @@
+/* ffdecsa -- fast decsa algorithm
+ *
+ * Copyright (C) 2003-2004  fatih89r
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "parallel_std_def.h"
+
+typedef unsigned int group;
+#define GROUP_PARALLELISM 32
+#define FFDECSA_FF0()     0x0
+#define FFDECSA_FF1()     0xffffffff
+
+/* 64 rows of 32 bits */
+
+static inline void FFTABLEIN(unsigned char *tab, int g, unsigned char *data){
+  *(((int *)tab)+g)=*((int *)data);
+  *(((int *)tab)+32+g)=*(((int *)data)+1);
+}
+
+static inline void FFTABLEOUT(unsigned char *data, unsigned char *tab, int g){
+  *((int *)data)=*(((int *)tab)+g);
+  *(((int *)data)+1)=*(((int *)tab)+32+g);
+}
+
+static inline void FFTABLEOUTXORNBY(int n, unsigned char *data, unsigned char *tab, int g){
+  int j;
+  for(j=0;j<n;j++){
+    *(data+j)^=*(tab+4*(g+(j>=4?32-1:0))+j);
+  }
+}
+
+typedef unsigned int batch;
+#define BYTES_PER_BATCH 4
+#define B_FFN_ALL_29() 0x29292929
+#define B_FFN_ALL_02() 0x02020202
+#define B_FFN_ALL_04() 0x04040404
+#define B_FFN_ALL_10() 0x10101010
+#define B_FFN_ALL_40() 0x40404040
+#define B_FFN_ALL_80() 0x80808080
+
+#define M_EMPTY()
diff -ruN oscam-emu-2015-12-03-11142.orig/ffdecsa/parallel_generic.h oscam-emu-2015-12-03-11142/ffdecsa/parallel_generic.h
--- oscam-emu-2015-12-03-11142.orig/ffdecsa/parallel_generic.h	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/ffdecsa/parallel_generic.h	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,102 @@
+/* ffdecsa -- fast decsa algorithm
+ *
+ * Copyright (C) 2003-2004  fatih89r
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+
+#if 0
+//// generics
+#define COPY4BY(d,s)     do{ int *pd=(int *)(d), *ps=(int *)(s); \
+                             *pd = *ps; }while(0)
+#define COPY8BY(d,s)     do{ long long int *pd=(long long int *)(d), *ps=(long long int *)(s); \
+                             *pd = *ps; }while(0)
+#define COPY16BY(d,s)    do{ long long int *pd=(long long int *)(d), *ps=(long long int *)(s); \
+                             *pd = *ps; \
+			     *(pd+1) = *(ps+1); }while(0)
+#define COPY32BY(d,s)    do{ long long int *pd=(long long int *)(d), *ps=(long long int *)(s); \
+                             *pd = *ps; \
+			     *(pd+1) = *(ps+1) \
+			     *(pd+2) = *(ps+2) \
+			     *(pd+3) = *(ps+3); }while(0)
+#define XOR4BY(d,s1,s2)  do{ int *pd=(int *)(d), *ps1=(int *)(s1), *ps2=(int *)(s2); \
+                             *pd = *ps1  ^ *ps2; }while(0)
+#define XOR8BY(d,s1,s2)  do{ long long int *pd=(long long int *)(d), *ps1=(long long int *)(s1), *ps2=(long long int *)(s2); \
+                             *pd = *ps1  ^ *ps2; }while(0)
+#define XOR16BY(d,s1,s2) do{ long long int *pd=(long long int *)(d), *ps1=(long long int *)(s1), *ps2=(long long int *)(s2); \
+                             *pd = *ps1  ^ *ps2; \
+                             *(pd+8) = *(ps1+8)  ^ *(ps2+8); }while(0)
+#define XOR32BY(d,s1,s2) do{ long long int *pd=(long long int *)(d), *ps1=(long long int *)(s1), *ps2=(long long int *)(s2); \
+                             *pd = *ps1  ^ *ps2; \
+                             *(pd+1) = *(ps1+1)  ^ *(ps2+1); \
+                             *(pd+2) = *(ps1+2)  ^ *(ps2+2); \
+                             *(pd+3) = *(ps1+3)  ^ *(ps2+3); }while(0)
+#define XOR32BV(d,s1,s2) do{ int *const pd=(int *const)(d), *ps1=(const int *const)(s1), *ps2=(const int *const)(s2); \
+                             int z; \
+			     for(z=0;z<8;z++){ \
+                               pd[z]=ps1[z]^ps2[z]; \
+			     } \
+                           }while(0)
+#define XOREQ4BY(d,s)    do{ int *pd=(int *)(d), *ps=(int *)(s); \
+                             *pd ^= *ps; }while(0)
+#define XOREQ8BY(d,s)    do{ long long int *pd=(long long int *)(d), *ps=(long long int *)(s); \
+                             *pd ^= *ps; }while(0)
+#define XOREQ16BY(d,s)   do{ long long int *pd=(long long int *)(d), *ps=(long long int *)(s); \
+                             *pd ^= *ps; \
+			     *(pd+1) ^=*(ps+1); }while(0)
+#define XOREQ32BY(d,s)   do{ long long int *pd=(long long int *)(d), *ps=(long long int *)(s); \
+                             *pd ^= *ps; \
+			     *(pd+1) ^=*(ps+1); \
+			     *(pd+2) ^=*(ps+2); \
+			     *(pd+3) ^=*(ps+3); }while(0)
+#define XOREQ32BY4(d,s)  do{ int *pd=(int *)(d), *ps=(int *)(s); \
+                             *pd ^= *ps; \
+			     *(pd+1) ^=*(ps+1); \
+			     *(pd+2) ^=*(ps+2); \
+			     *(pd+3) ^=*(ps+3); \
+			     *(pd+4) ^=*(ps+4); \
+			     *(pd+5) ^=*(ps+5); \
+			     *(pd+6) ^=*(ps+6); \
+			     *(pd+7) ^=*(ps+7); }while(0)
+#define XOREQ32BV(d,s)   do{ unsigned char *pd=(unsigned char *)(d), *ps=(unsigned char *)(s); \
+                             int z; \
+			     for(z=0;z<32;z++){ \
+                               pd[z]^=ps[z]; \
+			     } \
+                           }while(0)
+
+#else
+#define XOR_4_BY(d,s1,s2)    do{ int *pd=(int *)(d), *ps1=(int *)(s1), *ps2=(int *)(s2); \
+                               *pd = *ps1  ^ *ps2; }while(0)
+#define XOR_8_BY(d,s1,s2)    do{ long long int *pd=(long long int *)(d), *ps1=(long long int *)(s1), *ps2=(long long int *)(s2); \
+                               *pd = *ps1  ^ *ps2; }while(0)
+#define XOREQ_4_BY(d,s)      do{ int *pd=(int *)(d), *ps=(int *)(s); \
+                               *pd ^= *ps; }while(0)
+#define XOREQ_8_BY(d,s)      do{ long long int *pd=(long long int *)(d), *ps=(long long int *)(s); \
+                               *pd ^= *ps; }while(0)
+#define COPY_4_BY(d,s)       do{ int *pd=(int *)(d), *ps=(int *)(s); \
+                               *pd = *ps; }while(0)
+#define COPY_8_BY(d,s)       do{ long long int *pd=(long long int *)(d), *ps=(long long int *)(s); \
+                               *pd = *ps; }while(0)
+
+#define BEST_SPAN            8
+#define XOR_BEST_BY(d,s1,s2) do{ XOR_8_BY(d,s1,s2); }while(0);
+#define XOREQ_BEST_BY(d,s)   do{ XOREQ_8_BY(d,s); }while(0);
+#define COPY_BEST_BY(d,s)    do{ COPY_8_BY(d,s); }while(0);
+
+#define END_MM             do{ }while(0);
+#endif
diff -ruN oscam-emu-2015-12-03-11142.orig/ffdecsa/parallel_std_def.h oscam-emu-2015-12-03-11142/ffdecsa/parallel_std_def.h
--- oscam-emu-2015-12-03-11142.orig/ffdecsa/parallel_std_def.h	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/ffdecsa/parallel_std_def.h	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,29 @@
+/* ffdecsa -- fast decsa algorithm
+ *
+ * Copyright (C) 2003-2004  fatih89r
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define FFXOR(a,b) ((a)^(b))
+#define FFAND(a,b) ((a)&(b))
+#define FFOR(a,b)  ((a)|(b))
+#define FFNOT(a)   (~(a))
+
+#define B_FFAND(a,b) ((a)&(b))
+#define B_FFOR(a,b)  ((a)|(b))
+#define B_FFXOR(a,b) ((a)^(b))
+#define B_FFSH8L(a,n) ((a)<<(n))
+#define B_FFSH8R(a,n) ((a)>>(n))
diff -ruN oscam-emu-2015-12-03-11142.orig/ffdecsa/stream.c oscam-emu-2015-12-03-11142/ffdecsa/stream.c
--- oscam-emu-2015-12-03-11142.orig/ffdecsa/stream.c	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/ffdecsa/stream.c	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,906 @@
+/* ffdecsa -- fast decsa algorithm
+ *
+ * Copyright (C) 2003-2004  fatih89r
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+
+// define statics only once, when STREAM_INIT
+#ifdef STREAM_INIT
+struct stream_regs {
+  group A[32+10][4]; // 32 because we will move back (virtual shift register)
+  group B[32+10][4]; // 32 because we will move back (virtual shift register)
+  group X[4];
+  group Y[4];
+  group Z[4];
+  group D[4];
+  group E[4];
+  group F[4];
+  group p;
+  group q;
+  group r;
+  };
+
+static inline void trasp64_32_88ccw(unsigned char *data){
+/* 64 rows of 32 bits transposition (bytes transp. - 8x8 rotate counterclockwise)*/
+#define row ((unsigned int *)data)
+  int i,j;
+  for(j=0;j<64;j+=32){
+    unsigned int t,b;
+    for(i=0;i<16;i++){
+      t=row[j+i];
+      b=row[j+16+i];
+      row[j+i]   = (t&0x0000ffff)      | ((b           )<<16);
+      row[j+16+i]=((t           )>>16) |  (b&0xffff0000) ;
+    }
+  }
+  for(j=0;j<64;j+=16){
+    unsigned int t,b;
+    for(i=0;i<8;i++){
+      t=row[j+i];
+      b=row[j+8+i];
+      row[j+i]   = (t&0x00ff00ff)     | ((b&0x00ff00ff)<<8);
+      row[j+8+i] =((t&0xff00ff00)>>8) |  (b&0xff00ff00);
+    }
+  }
+  for(j=0;j<64;j+=8){
+    unsigned int t,b;
+    for(i=0;i<4;i++){
+      t=row[j+i];
+      b=row[j+4+i];
+      row[j+i]   =((t&0x0f0f0f0f)<<4) |  (b&0x0f0f0f0f);
+      row[j+4+i] = (t&0xf0f0f0f0)     | ((b&0xf0f0f0f0)>>4);
+    }
+  }
+  for(j=0;j<64;j+=4){
+    unsigned int t,b;
+    for(i=0;i<2;i++){
+      t=row[j+i];
+      b=row[j+2+i];
+      row[j+i]   =((t&0x33333333)<<2) |  (b&0x33333333);
+      row[j+2+i] = (t&0xcccccccc)     | ((b&0xcccccccc)>>2);
+    }
+  }
+  for(j=0;j<64;j+=2){
+    unsigned int t,b;
+    for(i=0;i<1;i++){
+      t=row[j+i];
+      b=row[j+1+i];
+      row[j+i]   =((t&0x55555555)<<1) |  (b&0x55555555);
+      row[j+1+i] = (t&0xaaaaaaaa)     | ((b&0xaaaaaaaa)>>1);
+    }
+  }
+#undef row
+}
+
+static inline void trasp64_32_88cw(unsigned char *data){
+/* 64 rows of 32 bits transposition (bytes transp. - 8x8 rotate clockwise)*/
+#define row ((unsigned int *)data)
+  int i,j;
+  for(j=0;j<64;j+=32){
+    unsigned int t,b;
+    for(i=0;i<16;i++){
+      t=row[j+i];
+      b=row[j+16+i];
+      row[j+i]   = (t&0x0000ffff)      | ((b           )<<16);
+      row[j+16+i]=((t           )>>16) |  (b&0xffff0000) ;
+    }
+  }
+  for(j=0;j<64;j+=16){
+    unsigned int t,b;
+    for(i=0;i<8;i++){
+      t=row[j+i];
+      b=row[j+8+i];
+      row[j+i]   = (t&0x00ff00ff)     | ((b&0x00ff00ff)<<8);
+      row[j+8+i] =((t&0xff00ff00)>>8) |  (b&0xff00ff00);
+    }
+  }
+  for(j=0;j<64;j+=8){
+    unsigned int t,b;
+    for(i=0;i<4;i++){
+      t=row[j+i];
+      b=row[j+4+i];
+      row[j+i]  =((t&0xf0f0f0f0)>>4) |   (b&0xf0f0f0f0);
+      row[j+4+i]= (t&0x0f0f0f0f)     |  ((b&0x0f0f0f0f)<<4);
+    }
+  }
+  for(j=0;j<64;j+=4){
+    unsigned int t,b;
+    for(i=0;i<2;i++){
+      t=row[j+i];
+      b=row[j+2+i];
+      row[j+i]  =((t&0xcccccccc)>>2) |  (b&0xcccccccc);
+      row[j+2+i]= (t&0x33333333)     | ((b&0x33333333)<<2);
+    }
+  }
+  for(j=0;j<64;j+=2){
+    unsigned int t,b;
+    for(i=0;i<1;i++){
+      t=row[j+i];
+      b=row[j+1+i];
+      row[j+i]  =((t&0xaaaaaaaa)>>1) |  (b&0xaaaaaaaa);
+      row[j+1+i]= (t&0x55555555)     | ((b&0x55555555)<<1);
+    }
+  }
+#undef row
+}
+
+//64-64----------------------------------------------------------
+static inline void trasp64_64_88ccw(unsigned char *data){
+/* 64 rows of 64 bits transposition (bytes transp. - 8x8 rotate counterclockwise)*/
+#define row ((unsigned long long int *)data)
+  int i,j;
+  for(j=0;j<64;j+=64){
+    unsigned long long int t,b;
+    for(i=0;i<32;i++){
+      t=row[j+i];
+      b=row[j+32+i];
+      row[j+i]   = (t&0x00000000ffffffffULL)      | ((b                      )<<32);
+      row[j+32+i]=((t                      )>>32) |  (b&0xffffffff00000000ULL) ;
+    }
+  }
+  for(j=0;j<64;j+=32){
+    unsigned long long int t,b;
+    for(i=0;i<16;i++){
+      t=row[j+i];
+      b=row[j+16+i];
+      row[j+i]   = (t&0x0000ffff0000ffffULL)      | ((b&0x0000ffff0000ffffULL)<<16);
+      row[j+16+i]=((t&0xffff0000ffff0000ULL)>>16) |  (b&0xffff0000ffff0000ULL) ;
+    }
+  }
+  for(j=0;j<64;j+=16){
+    unsigned long long int t,b;
+    for(i=0;i<8;i++){
+      t=row[j+i];
+      b=row[j+8+i];
+      row[j+i]   = (t&0x00ff00ff00ff00ffULL)     | ((b&0x00ff00ff00ff00ffULL)<<8);
+      row[j+8+i] =((t&0xff00ff00ff00ff00ULL)>>8) |  (b&0xff00ff00ff00ff00ULL);
+    }
+  }
+  for(j=0;j<64;j+=8){
+    unsigned long long int t,b;
+    for(i=0;i<4;i++){
+      t=row[j+i];
+      b=row[j+4+i];
+      row[j+i]   =((t&0x0f0f0f0f0f0f0f0fULL)<<4) |  (b&0x0f0f0f0f0f0f0f0fULL);
+      row[j+4+i] = (t&0xf0f0f0f0f0f0f0f0ULL)     | ((b&0xf0f0f0f0f0f0f0f0ULL)>>4);
+    }
+  }
+  for(j=0;j<64;j+=4){
+    unsigned long long int t,b;
+    for(i=0;i<2;i++){
+      t=row[j+i];
+      b=row[j+2+i];
+      row[j+i]   =((t&0x3333333333333333ULL)<<2) |  (b&0x3333333333333333ULL);
+      row[j+2+i] = (t&0xccccccccccccccccULL)     | ((b&0xccccccccccccccccULL)>>2);
+    }
+  }
+  for(j=0;j<64;j+=2){
+    unsigned long long int t,b;
+    for(i=0;i<1;i++){
+      t=row[j+i];
+      b=row[j+1+i];
+      row[j+i]   =((t&0x5555555555555555ULL)<<1) |  (b&0x5555555555555555ULL);
+      row[j+1+i] = (t&0xaaaaaaaaaaaaaaaaULL)     | ((b&0xaaaaaaaaaaaaaaaaULL)>>1);
+    }
+  }
+#undef row
+}
+
+static inline void trasp64_64_88cw(unsigned char *data){
+/* 64 rows of 64 bits transposition (bytes transp. - 8x8 rotate clockwise)*/
+#define row ((unsigned long long int *)data)
+  int i,j;
+  for(j=0;j<64;j+=64){
+    unsigned long long int t,b;
+    for(i=0;i<32;i++){
+      t=row[j+i];
+      b=row[j+32+i];
+      row[j+i]   = (t&0x00000000ffffffffULL)      | ((b                      )<<32);
+      row[j+32+i]=((t                      )>>32) |  (b&0xffffffff00000000ULL) ;
+    }
+  }
+  for(j=0;j<64;j+=32){
+    unsigned long long int t,b;
+    for(i=0;i<16;i++){
+      t=row[j+i];
+      b=row[j+16+i];
+      row[j+i]   = (t&0x0000ffff0000ffffULL)      | ((b&0x0000ffff0000ffffULL)<<16);
+      row[j+16+i]=((t&0xffff0000ffff0000ULL)>>16) |  (b&0xffff0000ffff0000ULL) ;
+    }
+  }
+  for(j=0;j<64;j+=16){
+    unsigned long long int t,b;
+    for(i=0;i<8;i++){
+      t=row[j+i];
+      b=row[j+8+i];
+      row[j+i]   = (t&0x00ff00ff00ff00ffULL)     | ((b&0x00ff00ff00ff00ffULL)<<8);
+      row[j+8+i] =((t&0xff00ff00ff00ff00ULL)>>8) |  (b&0xff00ff00ff00ff00ULL);
+    }
+  }
+  for(j=0;j<64;j+=8){
+    unsigned long long int t,b;
+    for(i=0;i<4;i++){
+      t=row[j+i];
+      b=row[j+4+i];
+      row[j+i]   =((t&0xf0f0f0f0f0f0f0f0ULL)>>4) |   (b&0xf0f0f0f0f0f0f0f0ULL);
+      row[j+4+i] = (t&0x0f0f0f0f0f0f0f0fULL)     |  ((b&0x0f0f0f0f0f0f0f0fULL)<<4);
+    }
+  }
+  for(j=0;j<64;j+=4){
+    unsigned long long int t,b;
+    for(i=0;i<2;i++){
+      t=row[j+i];
+      b=row[j+2+i];
+      row[j+i]   =((t&0xccccccccccccccccULL)>>2) |  (b&0xccccccccccccccccULL);
+      row[j+2+i] = (t&0x3333333333333333ULL)     | ((b&0x3333333333333333ULL)<<2);
+    }
+  }
+  for(j=0;j<64;j+=2){
+    unsigned long long int t,b;
+    for(i=0;i<1;i++){
+      t=row[j+i];
+      b=row[j+1+i];
+      row[j+i]   =((t&0xaaaaaaaaaaaaaaaaULL)>>1) |  (b&0xaaaaaaaaaaaaaaaaULL);
+      row[j+1+i] = (t&0x5555555555555555ULL)     | ((b&0x5555555555555555ULL)<<1);
+    }
+  }
+#undef row
+}
+
+//64-128----------------------------------------------------------
+static inline void trasp64_128_88ccw(unsigned char *data){
+/* 64 rows of 128 bits transposition (bytes transp. - 8x8 rotate counterclockwise)*/
+#define halfrow ((unsigned long long int *)data)
+  int i,j;
+  for(j=0;j<64;j+=64){
+    unsigned long long int t,b;
+    for(i=0;i<32;i++){
+      t=halfrow[2*(j+i)];
+      b=halfrow[2*(j+32+i)];
+      halfrow[2*(j+i)]   = (t&0x00000000ffffffffULL)      | ((b                      )<<32);
+      halfrow[2*(j+32+i)]=((t                      )>>32) |  (b&0xffffffff00000000ULL) ;
+      t=halfrow[2*(j+i)+1];
+      b=halfrow[2*(j+32+i)+1];
+      halfrow[2*(j+i)+1]   = (t&0x00000000ffffffffULL)      | ((b                      )<<32);
+      halfrow[2*(j+32+i)+1]=((t                      )>>32) |  (b&0xffffffff00000000ULL) ;
+    }
+  }
+  for(j=0;j<64;j+=32){
+    unsigned long long int t,b;
+    for(i=0;i<16;i++){
+      t=halfrow[2*(j+i)];
+      b=halfrow[2*(j+16+i)];
+      halfrow[2*(j+i)]   = (t&0x0000ffff0000ffffULL)      | ((b&0x0000ffff0000ffffULL)<<16);
+      halfrow[2*(j+16+i)]=((t&0xffff0000ffff0000ULL)>>16) |  (b&0xffff0000ffff0000ULL) ;
+      t=halfrow[2*(j+i)+1];
+      b=halfrow[2*(j+16+i)+1];
+      halfrow[2*(j+i)+1]   = (t&0x0000ffff0000ffffULL)      | ((b&0x0000ffff0000ffffULL)<<16);
+      halfrow[2*(j+16+i)+1]=((t&0xffff0000ffff0000ULL)>>16) |  (b&0xffff0000ffff0000ULL) ;
+    }
+  }
+  for(j=0;j<64;j+=16){
+    unsigned long long int t,b;
+    for(i=0;i<8;i++){
+      t=halfrow[2*(j+i)];
+      b=halfrow[2*(j+8+i)];
+      halfrow[2*(j+i)]   = (t&0x00ff00ff00ff00ffULL)     | ((b&0x00ff00ff00ff00ffULL)<<8);
+      halfrow[2*(j+8+i)] =((t&0xff00ff00ff00ff00ULL)>>8) |  (b&0xff00ff00ff00ff00ULL);
+      t=halfrow[2*(j+i)+1];
+      b=halfrow[2*(j+8+i)+1];
+      halfrow[2*(j+i)+1]   = (t&0x00ff00ff00ff00ffULL)     | ((b&0x00ff00ff00ff00ffULL)<<8);
+      halfrow[2*(j+8+i)+1] =((t&0xff00ff00ff00ff00ULL)>>8) |  (b&0xff00ff00ff00ff00ULL);
+    }
+  }
+  for(j=0;j<64;j+=8){
+    unsigned long long int t,b;
+    for(i=0;i<4;i++){
+      t=halfrow[2*(j+i)];
+      b=halfrow[2*(j+4+i)];
+      halfrow[2*(j+i)]   =((t&0x0f0f0f0f0f0f0f0fULL)<<4) |  (b&0x0f0f0f0f0f0f0f0fULL);
+      halfrow[2*(j+4+i)] = (t&0xf0f0f0f0f0f0f0f0ULL)     | ((b&0xf0f0f0f0f0f0f0f0ULL)>>4);
+      t=halfrow[2*(j+i)+1];
+      b=halfrow[2*(j+4+i)+1];
+      halfrow[2*(j+i)+1]   =((t&0x0f0f0f0f0f0f0f0fULL)<<4) |  (b&0x0f0f0f0f0f0f0f0fULL);
+      halfrow[2*(j+4+i)+1] = (t&0xf0f0f0f0f0f0f0f0ULL)     | ((b&0xf0f0f0f0f0f0f0f0ULL)>>4);
+    }
+  }
+  for(j=0;j<64;j+=4){
+    unsigned long long int t,b;
+    for(i=0;i<2;i++){
+      t=halfrow[2*(j+i)];
+      b=halfrow[2*(j+2+i)];
+      halfrow[2*(j+i)]   =((t&0x3333333333333333ULL)<<2) |  (b&0x3333333333333333ULL);
+      halfrow[2*(j+2+i)] = (t&0xccccccccccccccccULL)     | ((b&0xccccccccccccccccULL)>>2);
+      t=halfrow[2*(j+i)+1];
+      b=halfrow[2*(j+2+i)+1];
+      halfrow[2*(j+i)+1]   =((t&0x3333333333333333ULL)<<2) |  (b&0x3333333333333333ULL);
+      halfrow[2*(j+2+i)+1] = (t&0xccccccccccccccccULL)     | ((b&0xccccccccccccccccULL)>>2);
+    }
+  }
+  for(j=0;j<64;j+=2){
+    unsigned long long int t,b;
+    for(i=0;i<1;i++){
+      t=halfrow[2*(j+i)];
+      b=halfrow[2*(j+1+i)];
+      halfrow[2*(j+i)]   =((t&0x5555555555555555ULL)<<1) |  (b&0x5555555555555555ULL);
+      halfrow[2*(j+1+i)] = (t&0xaaaaaaaaaaaaaaaaULL)     | ((b&0xaaaaaaaaaaaaaaaaULL)>>1);
+      t=halfrow[2*(j+i)+1];
+      b=halfrow[2*(j+1+i)+1];
+      halfrow[2*(j+i)+1]   =((t&0x5555555555555555ULL)<<1) |  (b&0x5555555555555555ULL);
+      halfrow[2*(j+1+i)+1] = (t&0xaaaaaaaaaaaaaaaaULL)     | ((b&0xaaaaaaaaaaaaaaaaULL)>>1);
+    }
+  }
+#undef halfrow
+}
+
+static inline void trasp64_128_88cw(unsigned char *data){
+/* 64 rows of 128 bits transposition (bytes transp. - 8x8 rotate clockwise)*/
+#define halfrow ((unsigned long long int *)data)
+  int i,j;
+  for(j=0;j<64;j+=64){
+    unsigned long long int t,b;
+    for(i=0;i<32;i++){
+      t=halfrow[2*(j+i)];
+      b=halfrow[2*(j+32+i)];
+      halfrow[2*(j+i)]   = (t&0x00000000ffffffffULL)      | ((b                      )<<32);
+      halfrow[2*(j+32+i)]=((t                      )>>32) |  (b&0xffffffff00000000ULL) ;
+      t=halfrow[2*(j+i)+1];
+      b=halfrow[2*(j+32+i)+1];
+      halfrow[2*(j+i)+1]   = (t&0x00000000ffffffffULL)      | ((b                      )<<32);
+      halfrow[2*(j+32+i)+1]=((t                      )>>32) |  (b&0xffffffff00000000ULL) ;
+    }
+  }
+  for(j=0;j<64;j+=32){
+    unsigned long long int t,b;
+    for(i=0;i<16;i++){
+      t=halfrow[2*(j+i)];
+      b=halfrow[2*(j+16+i)];
+      halfrow[2*(j+i)]   = (t&0x0000ffff0000ffffULL)      | ((b&0x0000ffff0000ffffULL)<<16);
+      halfrow[2*(j+16+i)]=((t&0xffff0000ffff0000ULL)>>16) |  (b&0xffff0000ffff0000ULL) ;
+      t=halfrow[2*(j+i)+1];
+      b=halfrow[2*(j+16+i)+1];
+      halfrow[2*(j+i)+1]   = (t&0x0000ffff0000ffffULL)      | ((b&0x0000ffff0000ffffULL)<<16);
+      halfrow[2*(j+16+i)+1]=((t&0xffff0000ffff0000ULL)>>16) |  (b&0xffff0000ffff0000ULL) ;
+    }
+  }
+  for(j=0;j<64;j+=16){
+    unsigned long long int t,b;
+    for(i=0;i<8;i++){
+      t=halfrow[2*(j+i)];
+      b=halfrow[2*(j+8+i)];
+      halfrow[2*(j+i)]   = (t&0x00ff00ff00ff00ffULL)     | ((b&0x00ff00ff00ff00ffULL)<<8);
+      halfrow[2*(j+8+i)] =((t&0xff00ff00ff00ff00ULL)>>8) |  (b&0xff00ff00ff00ff00ULL);
+      t=halfrow[2*(j+i)+1];
+      b=halfrow[2*(j+8+i)+1];
+      halfrow[2*(j+i)+1]   = (t&0x00ff00ff00ff00ffULL)     | ((b&0x00ff00ff00ff00ffULL)<<8);
+      halfrow[2*(j+8+i)+1] =((t&0xff00ff00ff00ff00ULL)>>8) |  (b&0xff00ff00ff00ff00ULL);
+    }
+  }
+  for(j=0;j<64;j+=8){
+    unsigned long long int t,b;
+    for(i=0;i<4;i++){
+      t=halfrow[2*(j+i)];
+      b=halfrow[2*(j+4+i)];
+      halfrow[2*(j+i)]   =((t&0xf0f0f0f0f0f0f0f0ULL)>>4) |   (b&0xf0f0f0f0f0f0f0f0ULL);
+      halfrow[2*(j+4+i)] = (t&0x0f0f0f0f0f0f0f0fULL)     |  ((b&0x0f0f0f0f0f0f0f0fULL)<<4);
+      t=halfrow[2*(j+i)+1];
+      b=halfrow[2*(j+4+i)+1];
+      halfrow[2*(j+i)+1]   =((t&0xf0f0f0f0f0f0f0f0ULL)>>4) |   (b&0xf0f0f0f0f0f0f0f0ULL);
+      halfrow[2*(j+4+i)+1] = (t&0x0f0f0f0f0f0f0f0fULL)     |  ((b&0x0f0f0f0f0f0f0f0fULL)<<4);
+    }
+  }
+  for(j=0;j<64;j+=4){
+    unsigned long long int t,b;
+    for(i=0;i<2;i++){
+      t=halfrow[2*(j+i)];
+      b=halfrow[2*(j+2+i)];
+      halfrow[2*(j+i)]   =((t&0xccccccccccccccccULL)>>2) |  (b&0xccccccccccccccccULL);
+      halfrow[2*(j+2+i)] = (t&0x3333333333333333ULL)     | ((b&0x3333333333333333ULL)<<2);
+      t=halfrow[2*(j+i)+1];
+      b=halfrow[2*(j+2+i)+1];
+      halfrow[2*(j+i)+1]   =((t&0xccccccccccccccccULL)>>2) |  (b&0xccccccccccccccccULL);
+      halfrow[2*(j+2+i)+1] = (t&0x3333333333333333ULL)     | ((b&0x3333333333333333ULL)<<2);
+    }
+  }
+  for(j=0;j<64;j+=2){
+    unsigned long long int t,b;
+    for(i=0;i<1;i++){
+      t=halfrow[2*(j+i)];
+      b=halfrow[2*(j+1+i)];
+      halfrow[2*(j+i)]   =((t&0xaaaaaaaaaaaaaaaaULL)>>1) |  (b&0xaaaaaaaaaaaaaaaaULL);
+      halfrow[2*(j+1+i)] = (t&0x5555555555555555ULL)     | ((b&0x5555555555555555ULL)<<1);
+      t=halfrow[2*(j+i)+1];
+      b=halfrow[2*(j+1+i)+1];
+      halfrow[2*(j+i)+1]   =((t&0xaaaaaaaaaaaaaaaaULL)>>1) |  (b&0xaaaaaaaaaaaaaaaaULL);
+      halfrow[2*(j+1+i)+1] = (t&0x5555555555555555ULL)     | ((b&0x5555555555555555ULL)<<1);
+    }
+  }
+#undef halfrow
+}
+#endif
+
+
+#ifdef STREAM_INIT
+void stream_cypher_group_init(
+  struct stream_regs *regs,
+  group         iA[8][4], // [In]  iA00,iA01,...iA73 32 groups  | Derived from key.
+  group         iB[8][4], // [In]  iB00,iB01,...iB73 32 groups  | Derived from key.
+  unsigned char *sb)      // [In]  (SB0,SB1,...SB7)...x32 32*8 bytes | Extra input.
+#endif
+#ifdef STREAM_NORMAL
+void stream_cypher_group_normal(
+  struct stream_regs *regs,
+  unsigned char *cb)    // [Out] (CB0,CB1,...CB7)...x32 32*8 bytes | Output.
+#endif
+{
+#ifdef STREAM_INIT
+  group in1[4];
+  group in2[4];
+#endif
+  group extra_B[4];
+  group fa,fb,fc,fd,fe;
+  group s1a,s1b,s2a,s2b,s3a,s3b,s4a,s4b,s5a,s5b,s6a,s6b,s7a,s7b;
+  group next_E[4];
+  group tmp0,tmp1,tmp2,tmp3,tmp4;
+#ifdef STREAM_INIT
+  group *sb_g=(group *)sb;
+#endif
+#ifdef STREAM_NORMAL
+  group *cb_g=(group *)cb;
+#endif
+  int aboff;
+  int i,j,k,b;
+  int dbg;
+
+#ifdef STREAM_INIT
+  DBG(fprintf(stderr,":::::::::: BEGIN STREAM INIT\n"));
+#endif
+#ifdef STREAM_NORMAL
+  DBG(fprintf(stderr,":::::::::: BEGIN STREAM NORMAL\n"));
+#endif
+#ifdef STREAM_INIT
+for(j=0;j<64;j++){
+  DBG(fprintf(stderr,"precall prerot stream_in[%2i]=",j));
+  DBG(dump_mem("",sb+BYPG*j,BYPG,BYPG));
+}
+
+DBG(dump_mem("stream_prerot ",sb,GROUP_PARALLELISM*8,BYPG));
+#if GROUP_PARALLELISM==32
+trasp64_32_88ccw(sb);
+#endif
+#if GROUP_PARALLELISM==64
+trasp64_64_88ccw(sb);
+#endif
+#if GROUP_PARALLELISM==128
+trasp64_128_88ccw(sb);
+#endif
+DBG(dump_mem("stream_postrot",sb,GROUP_PARALLELISM*8,BYPG));
+
+for(j=0;j<64;j++){
+  DBG(fprintf(stderr,"precall stream_in[%2i]=",j));
+  DBG(dump_mem("",sb+BYPG*j,BYPG,BYPG));
+}
+#endif
+
+  aboff=32;
+
+#ifdef STREAM_INIT
+  // load first 32 bits of ck into A[aboff+0]..A[aboff+7]
+  // load last  32 bits of ck into B[aboff+0]..B[aboff+7]
+  // all other regs = 0
+  for(i=0;i<8;i++){
+    for(b=0;b<4;b++){
+DBG(fprintf(stderr,"dbg from iA A[%i][%i]=",i,b));
+DBG(dump_mem("",(unsigned char *)&iA[i][b],BYPG,BYPG));
+DBG(fprintf(stderr,"                                       dbg from iB B[%i][%i]=",i,b));
+DBG(dump_mem("",(unsigned char *)&iB[i][b],BYPG,BYPG));
+      regs->A[aboff+i][b]=iA[i][b];
+      regs->B[aboff+i][b]=iB[i][b];
+    }
+  }
+  for(b=0;b<4;b++){
+    regs->A[aboff+8][b]=FFDECSA_FF0();
+    regs->A[aboff+9][b]=FFDECSA_FF0();
+    regs->B[aboff+8][b]=FFDECSA_FF0();
+    regs->B[aboff+9][b]=FFDECSA_FF0();
+  }
+  for(b=0;b<4;b++){
+    regs->X[b]=FFDECSA_FF0();
+    regs->Y[b]=FFDECSA_FF0();
+    regs->Z[b]=FFDECSA_FF0();
+    regs->D[b]=FFDECSA_FF0();
+    regs->E[b]=FFDECSA_FF0();
+    regs->F[b]=FFDECSA_FF0();
+  }
+  regs->p=FFDECSA_FF0();
+  regs->q=FFDECSA_FF0();
+  regs->r=FFDECSA_FF0();
+#endif
+
+for(dbg=0;dbg<4;dbg++){
+  DBG(fprintf(stderr,"dbg A0[%i]=",dbg));
+  DBG(dump_mem("",(unsigned char *)&regs->A[aboff+0][dbg],BYPG,BYPG));
+  DBG(fprintf(stderr,"dbg B0[%i]=",dbg));
+  DBG(dump_mem("",(unsigned char *)&regs->B[aboff+0][dbg],BYPG,BYPG));
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+  // EXTERNAL LOOP - 8 bytes per operation
+  for(i=0;i<8;i++){
+
+    DBG(fprintf(stderr,"--BEGIN EXTERNAL LOOP %i\n",i));
+
+#ifdef STREAM_INIT
+    for(b=0;b<4;b++){
+      in1[b]=sb_g[8*i+4+b];
+      in2[b]=sb_g[8*i+b];
+    }
+#endif
+
+    // INTERNAL LOOP - 2 bits per iteration
+    for(j=0; j<4; j++){
+
+      DBG(fprintf(stderr,"---BEGIN INTERNAL LOOP %i (EXT %i, INT %i)\n",j,i,j));
+
+      // from A0..A9, 35 bits are selected as inputs to 7 s-boxes
+      // 5 bits input per s-box, 2 bits output per s-box
+
+      // we can select bits with zero masking and shifting operations
+      // and synthetize s-boxes with optimized boolean functions.
+      // this is the actual reason we do all the crazy transposition
+      // stuff to switch between normal and bit slice representations.
+      // this code really flies.
+
+      fe=regs->A[aboff+3][0];fa=regs->A[aboff+0][2];fb=regs->A[aboff+5][1];fc=regs->A[aboff+6][3];fd=regs->A[aboff+8][0];
+/* 1000 1110  1110 0001   : lev  7: */ //tmp0=( fa^( fb^( ( ( ( fa|fb )^fc )|( fc^fd ) )^ALL_ONES ) ) );
+/* 1110 0010  0011 0011   : lev  6: */ //tmp1=( ( fa|fb )^( ( fc&( fa|( fb^fd ) ) )^ALL_ONES ) );
+/* 0011 0110  1000 1101   : lev  5: */ //tmp2=( fa^( ( fb&fd )^( ( fa&fd )|fc ) ) );
+/* 0101 0101  1001 0011   : lev  5: */ //tmp3=( ( fa&fc )^( fa^( ( fa&fb )|fd ) ) );
+/* 1000 1110  1110 0001   : lev  7: */ tmp0=FFXOR(fa,FFXOR(fb,FFXOR(FFOR(FFXOR(FFOR(fa,fb),fc),FFXOR(fc,fd)),FFDECSA_FF1())));
+/* 1110 0010  0011 0011   : lev  6: */ tmp1=FFXOR(FFOR(fa,fb),FFXOR(FFAND(fc,FFOR(fa,FFXOR(fb,fd))),FFDECSA_FF1()));
+/* 0011 0110  1000 1101   : lev  5: */ tmp2=FFXOR(fa,FFXOR(FFAND(fb,fd),FFOR(FFAND(fa,fd),fc)));
+/* 0101 0101  1001 0011   : lev  5: */ tmp3=FFXOR(FFAND(fa,fc),FFXOR(fa,FFOR(FFAND(fa,fb),fd)));
+      s1a=FFXOR(tmp0,FFAND(fe,tmp1));
+      s1b=FFXOR(tmp2,FFAND(fe,tmp3));
+//dump_mem("s1as1b-fe",&fe,BYPG,BYPG);
+//dump_mem("s1as1b-fa",&fa,BYPG,BYPG);
+//dump_mem("s1as1b-fb",&fb,BYPG,BYPG);
+//dump_mem("s1as1b-fc",&fc,BYPG,BYPG);
+//dump_mem("s1as1b-fd",&fd,BYPG,BYPG);
+
+      fe=regs->A[aboff+1][1];fa=regs->A[aboff+2][2];fb=regs->A[aboff+5][3];fc=regs->A[aboff+6][0];fd=regs->A[aboff+8][1];
+/* 1001 1110  0110 0001   : lev  6: */ //tmp0=( fa^( ( fb&( fc|fd ) )^( fc^( fd^ALL_ONES ) ) ) );
+/* 0000 0011  0111 1011   : lev  5: */ //tmp1=( ( fa&( fb^fd ) )|( ( fa|fb )&fc ) );
+/* 1100 0110  1101 0010   : lev  6: */ //tmp2=( ( fb&fd )^( ( fa&fd )|( fb^( fc^ALL_ONES ) ) ) );
+/* 0001 1110  1111 0101   : lev  5: */ //tmp3=( ( fa&fd )|( fa^( fb^( fc&fd ) ) ) );
+/* 1001 1110  0110 0001   : lev  6: */ tmp0=FFXOR(fa,FFXOR(FFAND(fb,FFOR(fc,fd)),FFXOR(fc,FFXOR(fd,FFDECSA_FF1()))));
+/* 0000 0011  0111 1011   : lev  5: */ tmp1=FFOR(FFAND(fa,FFXOR(fb,fd)),FFAND(FFOR(fa,fb),fc));
+/* 1100 0110  1101 0010   : lev  6: */ tmp2=FFXOR(FFAND(fb,fd),FFOR(FFAND(fa,fd),FFXOR(fb,FFXOR(fc,FFDECSA_FF1()))));
+/* 0001 1110  1111 0101   : lev  5: */ tmp3=FFOR(FFAND(fa,fd),FFXOR(fa,FFXOR(fb,FFAND(fc,fd))));
+      s2a=FFXOR(tmp0,FFAND(fe,tmp1));
+      s2b=FFXOR(tmp2,FFAND(fe,tmp3));
+
+      fe=regs->A[aboff+0][3];fa=regs->A[aboff+1][0];fb=regs->A[aboff+4][1];fc=regs->A[aboff+4][3];fd=regs->A[aboff+5][2];
+/* 0100 1011  1001 0110   : lev  5: */ //tmp0=( fa^( fb^( ( fc&( fa|fd ) )^fd ) ) );
+/* 1101 0101  1000 1100   : lev  7: */ //tmp1=( ( fa&fc )^( ( fa^fd )|( ( fb|fc )^( fd^ALL_ONES ) ) ) );
+/* 0010 0111  1101 1000   : lev  4: */ //tmp2=( fa^( ( ( fb^fc )&fd )^fc ) );
+/* 1111 1111  1111 1111   : lev  0: */ //tmp3=ALL_ONES;
+/* 0100 1011  1001 0110   : lev  5: */ tmp0=FFXOR(fa,FFXOR(fb,FFXOR(FFAND(fc,FFOR(fa,fd)),fd)));
+/* 1101 0101  1000 1100   : lev  7: */ tmp1=FFXOR(FFAND(fa,fc),FFOR(FFXOR(fa,fd),FFXOR(FFOR(fb,fc),FFXOR(fd,FFDECSA_FF1()))));
+/* 0010 0111  1101 1000   : lev  4: */ tmp2=FFXOR(fa,FFXOR(FFAND(FFXOR(fb,fc),fd),fc));
+/* 1111 1111  1111 1111   : lev  0: */ tmp3=FFDECSA_FF1();
+      s3a=FFXOR(tmp0,FFAND(FFNOT(fe),tmp1));
+      s3b=FFXOR(tmp2,FFAND(fe,tmp3));
+
+      fe=regs->A[aboff+2][3];fa=regs->A[aboff+0][1];fb=regs->A[aboff+1][3];fc=regs->A[aboff+3][2];fd=regs->A[aboff+7][0];
+/* 1011 0101  0100 1001   : lev  7: */ //tmp0=( fa^( ( fc&( fa^fd ) )|( fb^( fc|( fd^ALL_ONES ) ) ) ) );
+/* 0010 1101  0110 0110   : lev  6: */ //tmp1=( ( fa&fb )^( fb^( ( ( fa|fc )&fd )^fc ) ) );
+/* 0110 0111  1101 0000   : lev  7: */ //tmp2=( fa^( ( fb&fc )|( ( ( fa&( fb^fd ) )|fc )^fd ) ) );
+/* 1111 1111  1111 1111   : lev  0: */ //tmp3=ALL_ONES;
+/* 1011 0101  0100 1001   : lev  7: */ tmp0=FFXOR(fa,FFOR(FFAND(fc,FFXOR(fa,fd)),FFXOR(fb,FFOR(fc,FFXOR(fd,FFDECSA_FF1())))));
+/* 0010 1101  0110 0110   : lev  6: */ tmp1=FFXOR(FFAND(fa,fb),FFXOR(fb,FFXOR(FFAND(FFOR(fa,fc),fd),fc)));
+/* 0110 0111  1101 0000   : lev  7: */ tmp2=FFXOR(fa,FFOR(FFAND(fb,fc),FFXOR(FFOR(FFAND(fa,FFXOR(fb,fd)),fc),fd)));
+/* 1111 1111  1111 1111   : lev  0: */ tmp3=FFDECSA_FF1();
+      s4a=FFXOR(tmp0,FFAND(fe,FFXOR(tmp1,tmp0)));
+      s4b=FFXOR(FFXOR(s4a,tmp2),FFAND(fe,tmp3));
+
+      fe=regs->A[aboff+4][2];fa=regs->A[aboff+3][3];fb=regs->A[aboff+5][0];fc=regs->A[aboff+7][1];fd=regs->A[aboff+8][2];
+/* 1000 1111  0011 0010   : lev  7: */ //tmp0=( ( ( fa&( fb|fc ) )^fb )|( ( ( fa^fc )|fd )^ALL_ONES ) );
+/* 0110 1011  0000 1011   : lev  6: */ //tmp1=( fb^( ( fc^fd )&( fc^( fb|( fa^fd ) ) ) ) );
+/* 0001 1010  0111 1001   : lev  6: */ //tmp2=( ( fa&fc )^( fb^( ( fb|( fa^fc ) )&fd ) ) );
+/* 0101 1101  1101 0101   : lev  4: */ //tmp3=( ( ( fa^fb )&( fc^ALL_ONES ) )|fd );
+/* 1000 1111  0011 0010   : lev  7: */ tmp0=FFOR(FFXOR(FFAND(fa,FFOR(fb,fc)),fb),FFXOR(FFOR(FFXOR(fa,fc),fd),FFDECSA_FF1()));
+/* 0110 1011  0000 1011   : lev  6: */ tmp1=FFXOR(fb,FFAND(FFXOR(fc,fd),FFXOR(fc,FFOR(fb,FFXOR(fa,fd)))));
+/* 0001 1010  0111 1001   : lev  6: */ tmp2=FFXOR(FFAND(fa,fc),FFXOR(fb,FFAND(FFOR(fb,FFXOR(fa,fc)),fd)));
+/* 0101 1101  1101 0101   : lev  4: */ tmp3=FFOR(FFAND(FFXOR(fa,fb),FFXOR(fc,FFDECSA_FF1())),fd);
+      s5a=FFXOR(tmp0,FFAND(fe,tmp1));
+      s5b=FFXOR(tmp2,FFAND(fe,tmp3));
+
+      fe=regs->A[aboff+2][1];fa=regs->A[aboff+3][1];fb=regs->A[aboff+4][0];fc=regs->A[aboff+6][2];fd=regs->A[aboff+8][3];
+/* 0011 0110  0010 1101   : lev  6: */ //tmp0=( ( ( fa&fc )&fd )^( ( fb&( fa|fd ) )^fc ) );
+/* 1110 1110  1011 1011   : lev  3: */ //tmp1=( ( ( fa^fc )&fd )^ALL_ONES );
+/* 0101 1000  0110 0111   : lev  6: */ //tmp2=( ( fa&( fb|fc ) )^( fb^( ( fb&fc )|fd ) ) );
+/* 0001 0011  0000 0001   : lev  5: */ //tmp3=( fc&( ( fa&( fb^fd ) )^( fb|fd ) ) );
+/* 0011 0110  0010 1101   : lev  6: */ tmp0=FFXOR(FFAND(FFAND(fa,fc),fd),FFXOR(FFAND(fb,FFOR(fa,fd)),fc));
+/* 1110 1110  1011 1011   : lev  3: */ tmp1=FFXOR(FFAND(FFXOR(fa,fc),fd),FFDECSA_FF1());
+/* 0101 1000  0110 0111   : lev  6: */ tmp2=FFXOR(FFAND(fa,FFOR(fb,fc)),FFXOR(fb,FFOR(FFAND(fb,fc),fd)));
+/* 0001 0011  0000 0001   : lev  5: */ tmp3=FFAND(fc,FFXOR(FFAND(fa,FFXOR(fb,fd)),FFOR(fb,fd)));
+      s6a=FFXOR(tmp0,FFAND(fe,tmp1));
+      s6b=FFXOR(tmp2,FFAND(fe,tmp3));
+
+      fe=regs->A[aboff+1][2];fa=regs->A[aboff+2][0];fb=regs->A[aboff+6][1];fc=regs->A[aboff+7][2];fd=regs->A[aboff+7][3];
+/* 0111 1000  1001 0110   : lev  5: */ //tmp0=( fb^( ( fc&fd )|( fa^( fc^fd ) ) ) );
+/* 0100 1001  0101 1011   : lev  6: */ //tmp1=( ( fb|fd )&( ( fa&fc )|( fb^( fc^fd ) ) ) );
+/* 0100 1001  1011 1001   : lev  5: */ //tmp2=( ( fa|fb )^( ( fc&( fb|fd ) )^fd ) );
+/* 1111 1111  1101 1101   : lev  3: */ //tmp3=( fd|( ( fa&fc )^ALL_ONES ) );
+/* 0111 1000  1001 0110   : lev  5: */ tmp0=FFXOR(fb,FFOR(FFAND(fc,fd),FFXOR(fa,FFXOR(fc,fd))));
+/* 0100 1001  0101 1011   : lev  6: */ tmp1=FFAND(FFOR(fb,fd),FFOR(FFAND(fa,fc),FFXOR(fb,FFXOR(fc,fd))));
+/* 0100 1001  1011 1001   : lev  5: */ tmp2=FFXOR(FFOR(fa,fb),FFXOR(FFAND(fc,FFOR(fb,fd)),fd));
+/* 1111 1111  1101 1101   : lev  3: */ tmp3=FFOR(fd,FFXOR(FFAND(fa,fc),FFDECSA_FF1()));
+      s7a=FFXOR(tmp0,FFAND(fe,tmp1));
+      s7b=FFXOR(tmp2,FFAND(fe,tmp3));
+
+
+/*
+      we have just done this:
+      
+      int sbox1[0x20] = {2,0,1,1,2,3,3,0, 3,2,2,0,1,1,0,3, 0,3,3,0,2,2,1,1, 2,2,0,3,1,1,3,0};
+      int sbox2[0x20] = {3,1,0,2,2,3,3,0, 1,3,2,1,0,0,1,2, 3,1,0,3,3,2,0,2, 0,0,1,2,2,1,3,1};
+      int sbox3[0x20] = {2,0,1,2,2,3,3,1, 1,1,0,3,3,0,2,0, 1,3,0,1,3,0,2,2, 2,0,1,2,0,3,3,1};
+      int sbox4[0x20] = {3,1,2,3,0,2,1,2, 1,2,0,1,3,0,0,3, 1,0,3,1,2,3,0,3, 0,3,2,0,1,2,2,1};
+      int sbox5[0x20] = {2,0,0,1,3,2,3,2, 0,1,3,3,1,0,2,1, 2,3,2,0,0,3,1,1, 1,0,3,2,3,1,0,2};
+      int sbox6[0x20] = {0,1,2,3,1,2,2,0, 0,1,3,0,2,3,1,3, 2,3,0,2,3,0,1,1, 2,1,1,2,0,3,3,0};
+      int sbox7[0x20] = {0,3,2,2,3,0,0,1, 3,0,1,3,1,2,2,1, 1,0,3,3,0,1,1,2, 2,3,1,0,2,3,0,2};
+
+      s12 = sbox1[ (((A3>>0)&1)<<4) | (((A0>>2)&1)<<3) | (((A5>>1)&1)<<2) | (((A6>>3)&1)<<1) | (((A8>>0)&1)<<0) ]
+           |sbox2[ (((A1>>1)&1)<<4) | (((A2>>2)&1)<<3) | (((A5>>3)&1)<<2) | (((A6>>0)&1)<<1) | (((A8>>1)&1)<<0) ];
+      s34 = sbox3[ (((A0>>3)&1)<<4) | (((A1>>0)&1)<<3) | (((A4>>1)&1)<<2) | (((A4>>3)&1)<<1) | (((A5>>2)&1)<<0) ]
+           |sbox4[ (((A2>>3)&1)<<4) | (((A0>>1)&1)<<3) | (((A1>>3)&1)<<2) | (((A3>>2)&1)<<1) | (((A7>>0)&1)<<0) ];
+      s56 = sbox5[ (((A4>>2)&1)<<4) | (((A3>>3)&1)<<3) | (((A5>>0)&1)<<2) | (((A7>>1)&1)<<1) | (((A8>>2)&1)<<0) ]
+           |sbox6[ (((A2>>1)&1)<<4) | (((A3>>1)&1)<<3) | (((A4>>0)&1)<<2) | (((A6>>2)&1)<<1) | (((A8>>3)&1)<<0) ];
+      s7 =  sbox7[ (((A1>>2)&1)<<4) | (((A2>>0)&1)<<3) | (((A6>>1)&1)<<2) | (((A7>>2)&1)<<1) | (((A7>>3)&1)<<0) ];
+*/
+
+      // use 4x4 xor to produce extra nibble for T3
+
+      extra_B[3]=FFXOR(FFXOR(FFXOR(regs->B[aboff+2][0],regs->B[aboff+5][1]),regs->B[aboff+6][2]),regs->B[aboff+8][3]);
+      extra_B[2]=FFXOR(FFXOR(FFXOR(regs->B[aboff+5][0],regs->B[aboff+7][1]),regs->B[aboff+2][3]),regs->B[aboff+3][2]);
+      extra_B[1]=FFXOR(FFXOR(FFXOR(regs->B[aboff+4][3],regs->B[aboff+7][2]),regs->B[aboff+3][0]),regs->B[aboff+4][1]);
+      extra_B[0]=FFXOR(FFXOR(FFXOR(regs->B[aboff+8][2],regs->B[aboff+5][3]),regs->B[aboff+2][1]),regs->B[aboff+7][0]);
+for(dbg=0;dbg<4;dbg++){
+  DBG(fprintf(stderr,"extra_B[%i]=",dbg));
+  DBG(dump_mem("",(unsigned char *)&extra_B[dbg],BYPG,BYPG));
+}
+
+      // T1 = xor all inputs
+      // in1, in2, D are only used in T1 during initialisation, not generation
+      for(b=0;b<4;b++){
+        regs->A[aboff-1][b]=FFXOR(regs->A[aboff+9][b],regs->X[b]);
+      }
+
+#ifdef STREAM_INIT
+      for(b=0;b<4;b++){
+        regs->A[aboff-1][b]=FFXOR(FFXOR(regs->A[aboff-1][b],regs->D[b]),((j % 2) ? in2[b] : in1[b]));
+      }
+#endif
+
+for(dbg=0;dbg<4;dbg++){
+  DBG(fprintf(stderr,"next_A0[%i]=",dbg));
+  DBG(dump_mem("",(unsigned char *)&regs->A[aboff-1][dbg],BYPG,BYPG));
+}
+
+      // T2 =  xor all inputs
+      // in1, in2 are only used in T1 during initialisation, not generation
+      // if p=0, use this, if p=1, rotate the result left
+      for(b=0;b<4;b++){
+        regs->B[aboff-1][b]=FFXOR(FFXOR(regs->B[aboff+6][b],regs->B[aboff+9][b]),regs->Y[b]);
+      }
+
+#ifdef STREAM_INIT
+      for(b=0;b<4;b++){
+        regs->B[aboff-1][b]=FFXOR(regs->B[aboff-1][b],((j % 2) ? in1[b] : in2[b]));
+      }
+#endif
+
+for(dbg=0;dbg<4;dbg++){
+  DBG(fprintf(stderr,"next_B0[%i]=",dbg));
+  DBG(dump_mem("",(unsigned char *)&regs->B[aboff-1][dbg],BYPG,BYPG));
+}
+
+      // if p=1, rotate left (yes, this is what we're doing)
+      tmp3=regs->B[aboff-1][3];
+      regs->B[aboff-1][3]=FFXOR(regs->B[aboff-1][3],FFAND(FFXOR(regs->B[aboff-1][3],regs->B[aboff-1][2]),regs->p));
+      regs->B[aboff-1][2]=FFXOR(regs->B[aboff-1][2],FFAND(FFXOR(regs->B[aboff-1][2],regs->B[aboff-1][1]),regs->p));
+      regs->B[aboff-1][1]=FFXOR(regs->B[aboff-1][1],FFAND(FFXOR(regs->B[aboff-1][1],regs->B[aboff-1][0]),regs->p));
+      regs->B[aboff-1][0]=FFXOR(regs->B[aboff-1][0],FFAND(FFXOR(regs->B[aboff-1][0],tmp3),regs->p));
+
+for(dbg=0;dbg<4;dbg++){
+  DBG(fprintf(stderr,"next_B0[%i]=",dbg));
+  DBG(dump_mem("",(unsigned char *)&regs->B[aboff-1][dbg],BYPG,BYPG));
+}
+
+      // T3 = xor all inputs
+      for(b=0;b<4;b++){
+        regs->D[b]=FFXOR(FFXOR(regs->E[b],regs->Z[b]),extra_B[b]);
+      }
+
+for(dbg=0;dbg<4;dbg++){
+  DBG(fprintf(stderr,"D[%i]=",dbg));
+  DBG(dump_mem("",(unsigned char *)&regs->D[dbg],BYPG,BYPG));
+}
+
+      // T4 = sum, carry of Z + E + r
+      for(b=0;b<4;b++){
+        next_E[b]=regs->F[b];
+      }
+
+      tmp0=FFXOR(regs->Z[0],regs->E[0]);
+      tmp1=FFAND(regs->Z[0],regs->E[0]);
+      regs->F[0]=FFXOR(regs->E[0],FFAND(regs->q,FFXOR(regs->Z[0],regs->r)));
+      tmp3=FFAND(tmp0,regs->r);
+      tmp4=FFOR(tmp1,tmp3);
+
+      tmp0=FFXOR(regs->Z[1],regs->E[1]);
+      tmp1=FFAND(regs->Z[1],regs->E[1]);
+      regs->F[1]=FFXOR(regs->E[1],FFAND(regs->q,FFXOR(regs->Z[1],tmp4)));
+      tmp3=FFAND(tmp0,tmp4);
+      tmp4=FFOR(tmp1,tmp3);
+
+      tmp0=FFXOR(regs->Z[2],regs->E[2]);
+      tmp1=FFAND(regs->Z[2],regs->E[2]);
+      regs->F[2]=FFXOR(regs->E[2],FFAND(regs->q,FFXOR(regs->Z[2],tmp4)));
+      tmp3=FFAND(tmp0,tmp4);
+      tmp4=FFOR(tmp1,tmp3);
+
+      tmp0=FFXOR(regs->Z[3],regs->E[3]);
+      tmp1=FFAND(regs->Z[3],regs->E[3]);
+      regs->F[3]=FFXOR(regs->E[3],FFAND(regs->q,FFXOR(regs->Z[3],tmp4)));
+      tmp3=FFAND(tmp0,tmp4);
+      regs->r=FFXOR(regs->r,FFAND(regs->q,FFXOR(FFOR(tmp1,tmp3),regs->r))); // ultimate carry
+
+/*
+      we have just done this: (believe it or not)
+      
+      if (q) {
+        F = Z + E + r;
+        r = (F >> 4) & 1;
+        F = F & 0x0f;
+      }
+      else {
+          F = E;
+      }
+*/
+      for(b=0;b<4;b++){
+        regs->E[b]=next_E[b];
+      }
+for(dbg=0;dbg<4;dbg++){
+  DBG(fprintf(stderr,"F[%i]=",dbg));
+  DBG(dump_mem("",(unsigned char *)&regs->F[dbg],BYPG,BYPG));
+}
+DBG(fprintf(stderr,"r="));
+DBG(dump_mem("",(unsigned char *)&regs->r,BYPG,BYPG));
+for(dbg=0;dbg<4;dbg++){
+  DBG(fprintf(stderr,"E[%i]=",dbg));
+  DBG(dump_mem("",(unsigned char *)&regs->E[dbg],BYPG,BYPG));
+}
+
+      // this simple instruction is virtually shifting all the shift registers
+      aboff--;
+
+/*
+      we've just done this:
+
+      A9=A8;A8=A7;A7=A6;A6=A5;A5=A4;A4=A3;A3=A2;A2=A1;A1=A0;A0=next_A0;
+      B9=B8;B8=B7;B7=B6;B6=B5;B5=B4;B4=B3;B3=B2;B2=B1;B1=B0;B0=next_B0;
+*/
+
+      regs->X[0]=s1a;
+      regs->X[1]=s2a;
+      regs->X[2]=s3b;
+      regs->X[3]=s4b;
+      regs->Y[0]=s3a;
+      regs->Y[1]=s4a;
+      regs->Y[2]=s5b;
+      regs->Y[3]=s6b;
+      regs->Z[0]=s5a;
+      regs->Z[1]=s6a;
+      regs->Z[2]=s1b;
+      regs->Z[3]=s2b;
+      regs->p=s7a;
+      regs->q=s7b;
+for(dbg=0;dbg<4;dbg++){
+  DBG(fprintf(stderr,"X[%i]=",dbg));
+  DBG(dump_mem("",(unsigned char *)&regs->X[dbg],BYPG,BYPG));
+}
+for(dbg=0;dbg<4;dbg++){
+  DBG(fprintf(stderr,"Y[%i]=",dbg));
+  DBG(dump_mem("",(unsigned char *)&regs->Y[dbg],BYPG,BYPG));
+}
+for(dbg=0;dbg<4;dbg++){
+  DBG(fprintf(stderr,"Z[%i]=",dbg));
+  DBG(dump_mem("",(unsigned char *)&regs->Z[dbg],BYPG,BYPG));
+}
+DBG(fprintf(stderr,"p="));
+DBG(dump_mem("",(unsigned char *)&regs->p,BYPG,BYPG));
+DBG(fprintf(stderr,"q="));
+DBG(dump_mem("",(unsigned char *)&regs->q,BYPG,BYPG));
+
+#ifdef STREAM_NORMAL
+      // require 4 loops per output byte
+      // 2 output bits are a function of the 4 bits of D
+      // xor 2 by 2
+      cb_g[8*i+7-2*j]=FFXOR(regs->D[2],regs->D[3]);
+      cb_g[8*i+6-2*j]=FFXOR(regs->D[0],regs->D[1]);
+for(dbg=0;dbg<8;dbg++){
+  DBG(fprintf(stderr,"op[%i]=",dbg));
+  DBG(dump_mem("",(unsigned char *)&cb_g[8*i+dbg],BYPG,BYPG));
+}
+#endif
+
+DBG(fprintf(stderr,"---END INTERNAL LOOP\n"));
+
+    } // INTERNAL LOOP
+
+DBG(fprintf(stderr,"--END EXTERNAL LOOP\n"));
+
+  } // EXTERNAL LOOP
+
+  // move 32 steps forward, ready for next call
+  for(k=0;k<10;k++){
+    for(b=0;b<4;b++){
+DBG(fprintf(stderr,"moving forward AB k=%i b=%i\n",k,b));
+      regs->A[32+k][b]=regs->A[k][b];
+      regs->B[32+k][b]=regs->B[k][b];
+    }
+  }
+
+
+////////////////////////////////////////////////////////////////////////////////
+
+#ifdef STREAM_NORMAL
+for(j=0;j<64;j++){
+  DBG(fprintf(stderr,"postcall prerot cb[%2i]=",j));
+  DBG(dump_mem("",(unsigned char *)(cb+BYPG*j),BYPG,BYPG));
+}
+
+#if GROUP_PARALLELISM==32
+trasp64_32_88cw(cb);
+#endif
+#if GROUP_PARALLELISM==64
+trasp64_64_88cw(cb);
+#endif
+#if GROUP_PARALLELISM==128
+trasp64_128_88cw(cb);
+#endif
+
+for(j=0;j<64;j++){
+  DBG(fprintf(stderr,"postcall postrot cb[%2i]=",j));
+  DBG(dump_mem("",(unsigned char *)(cb+BYPG*j),BYPG,BYPG));
+}
+#endif
+
+#ifdef STREAM_INIT
+  DBG(fprintf(stderr,":::::::::: END STREAM INIT\n"));
+#endif
+#ifdef STREAM_NORMAL
+  DBG(fprintf(stderr,":::::::::: END STREAM NORMAL\n"));
+#endif
+
+}
+
diff -ruN oscam-emu-2015-12-03-11142.orig/globals.h oscam-emu-2015-12-03-11142/globals.h
--- oscam-emu-2015-12-03-11142.orig/globals.h	2015-12-12 00:38:27.890433337 +0300
+++ oscam-emu-2015-12-03-11142/globals.h	2015-12-04 00:43:30.000000000 +0300
@@ -376,7 +376,7 @@
 #define CS_MAXPROV    32
 #define CS_MAXPORTS   32  // max server ports
 #define CS_CLIENT_HASHBUCKETS 32
-#define CS_SERVICENAME_SIZE 32
+#define CS_SERVICENAME_SIZE 64
 
 #define CS_ECMSTORESIZE   16  // use MD5()
 #define CS_EMMSTORESIZE   16  // use MD5()
@@ -386,13 +386,10 @@
 #define CS_DELAY          0
 #define CS_ECM_RINGBUFFER_MAX 0x10 // max size for ECM last responsetimes ringbuffer. Keep this set to power of 2 values!
 
-// Support for multiple CWs per channel and other encryption algos
-//#define WITH_EXTENDED_CW 1
-
 #define MAX_ECM_SIZE 596
-#define MAX_EMM_SIZE 512
+#define MAX_EMM_SIZE 1024
 
-#define CS_EMMCACHESIZE  512 //nr of EMMs that each reader will cache
+#define CS_EMMCACHESIZE  1024 //nr of EMMs that each reader will cache
 #define MSGLOGSIZE 64   //size of string buffer for a ecm to return messages
 
 #define D_TRACE     0x0001  // Generate very detailed error/trace messages per routine
@@ -423,6 +420,7 @@
 /////////////////// readers that do not reed baudrate setting and timings are guarded by reader itself (large buffer built in): AFTER R_SMART
 #define R_SMART     0x7 // Smartreader+
 #define R_PCSC      0x8 // PCSC
+#define R_EMU       0x17  // Reader emu
 /////////////////// proxy readers after R_CS378X
 #define R_CAMD35    0x20  // Reader cascading camd 3.5x
 #define R_CAMD33    0x21  // Reader cascading camd 3.3x
@@ -585,17 +583,6 @@
 #define REQUEST_SENT            0x10
 #define REQUEST_ANSWERED        0x20
 
-#define CW_MODE_ONE_CW 0
-#define CW_MODE_MULTIPLE_CW 1
-#define CW_TYPE_VIDEO 0
-#define CW_TYPE_AUDIO 1
-#define CW_TYPE_DATA 2
-#define CW_ALGO_CSA 0
-#define CW_ALGO_DES 1
-#define CW_ALGO_AES128 2
-#define CW_ALGO_MODE_ECB 0
-#define CW_ALGO_MODE_CBC 1
-
 /* ===========================
  *      Default Values
  * =========================== */
@@ -685,6 +672,14 @@
 	uchar           *bclass;
 } CLASSTAB;
 
+typedef struct s_sid_list_tab
+{
+	uchar           an;
+	uchar           bn;
+	uint16_t           *asid;
+	uint16_t           *bsid;
+} SID_LIST_TAB;
+
 typedef struct s_caidtab_data
 {
 	uint16_t		caid;
@@ -847,6 +842,13 @@
 	uint32_t        class;              // the class needed for some systems
 	time_t          start;              // startdate
 	time_t          end;                // enddate
+#ifdef WITH_EMU	
+	bool            isKey;
+	bool            isData;
+	char            name[8];
+	uint8_t         *key;
+	uint32_t        keyLength;
+#endif
 } S_ENTITLEMENT;
 
 struct s_client ;
@@ -970,6 +972,7 @@
 	void (*post_process)(struct s_reader *);
 	int32_t (*get_emm_type)(struct emm_packet_t *, struct s_reader *);
 	int32_t (*get_emm_filter)(struct s_reader *, struct s_csystem_emm_filter **, unsigned int *);
+	int32_t (*get_emm_filter_adv)(struct s_reader *, struct s_csystem_emm_filter **, unsigned int *, uint16_t, uint32_t);
 	int32_t (*get_tunemm_filter)(struct s_reader *, struct s_csystem_emm_filter **, unsigned int *);
 };
 
@@ -985,7 +988,7 @@
 #else
 typedef struct cw_extendted_t
 {
-	uchar			disabled;
+	uchar           disabled;
 } EXTENDED_CW;
 #endif
 
@@ -1148,7 +1151,7 @@
 {
 	int16_t         emmlen;
 	int32_t			provid;
-	uint8_t         emm[MAX_EMM_SIZE];
+	uint8_t         emm[512];
 };
 
 struct s_client
@@ -1439,10 +1442,18 @@
 	int16_t max;
 };
 
+#ifdef WITH_EMU
+typedef struct opkeys
+{
+	uint8_t key3b[32][32]; 
+	uint8_t key56[32][32]; 
+} opkeys_t;
+#endif
+
 struct s_reader                                     //contains device info, reader info and card info
 {
 	uint8_t         keepalive;
-	uint8_t     changes_since_shareupdate;
+	uint8_t			changes_since_shareupdate;
 	int32_t         resetcycle;                     // ECM until reset
 	int32_t         resetcounter;                   // actual count
 	uint32_t        auprovid;                       // AU only for this provid
@@ -1561,6 +1572,7 @@
 	FTAB            fchid;
 	FTAB            ftab;
 	CLASSTAB        cltab;
+	SID_LIST_TAB	sidlisttab; //megavolt
 	ECM_WHITELIST   ecm_whitelist;
 	ECM_HDR_WHITELIST   ecm_hdr_whitelist;
 	int32_t         brk_pos;
@@ -1674,6 +1686,13 @@
 #ifdef MODULE_GHTTP
 	uint8_t         ghttp_use_ssl;
 #endif
+#ifdef WITH_EMU
+	FTAB            emu_auproviders;
+	char            *extee36;
+	char            *extee56;
+	opkeys_t 		*ee36;
+	opkeys_t		*ee56;
+#endif
 	uint8_t cnxlastecm; // == 0 - las ecm has not been paired ecm, > 0 last ecm has been paired ecm
 	LLIST           *emmstat; //emm stats
 	CS_MUTEX_LOCK   emmstat_lock;
@@ -2141,6 +2160,13 @@
 	IN_ADDR_T   scam_srvip;
 	struct s_ip *scam_allowed;
 #endif
+
+#ifdef WITH_EMU
+	int32_t     emu_stream_source_port;
+	int32_t     emu_stream_relay_port;
+	uint32_t    emu_stream_ecm_delay;
+#endif
+
 	int32_t    max_cache_time;  //seconds ecms are stored in ecmcwcache
 	int32_t    max_hitcache_time;  //seconds hits are stored in cspec_hitcache (to detect dyn wait_time)
 
@@ -2310,7 +2336,9 @@
 static inline bool caid_is_betacrypt(uint16_t caid) { return caid >> 8 == 0x17; }
 static inline bool caid_is_nagra(uint16_t caid) { return caid >> 8 == 0x18; }
 static inline bool caid_is_bulcrypt(uint16_t caid) { return caid == 0x5581 || caid == 0x4AEE; }
-static inline bool caid_is_dre(uint16_t caid) { return caid == 0x4AE0 || caid == 0x4AE1;}
+static inline bool caid_is_dre(uint16_t caid) { return caid == 0x4AE0 || caid == 0x4AE1 || caid == 0x2710; }
 const char *get_cardsystem_desc_by_caid(uint16_t caid);
 
+FILTER* get_emu_prids_for_caid(struct s_reader *rdr, uint16_t caid);
+
 #endif
diff -ruN oscam-emu-2015-12-03-11142.orig/Makefile oscam-emu-2015-12-03-11142/Makefile
--- oscam-emu-2015-12-03-11142.orig/Makefile	2015-12-12 00:38:47.766878468 +0300
+++ oscam-emu-2015-12-03-11142/Makefile	2015-12-04 00:43:30.000000000 +0300
@@ -267,6 +267,23 @@
 SRC-$(CONFIG_MODULE_CCCAM) += module-cccam.c
 SRC-$(CONFIG_MODULE_CCCSHARE) += module-cccshare.c
 SRC-$(CONFIG_MODULE_CONSTCW) += module-constcw.c
+SRC-$(CONFIG_WITH_EMU) += module-emulator.c
+SRC-$(CONFIG_WITH_EMU) += module-emulator-osemu.c
+SRC-$(CONFIG_WITH_EMU) += module-emulator-stream.c
+SRC-$(CONFIG_WITH_EMU) += module-emulator-st20.c
+SRC-$(CONFIG_WITH_EMU) += module-emulator-dre2overcrypt.c
+SRC-$(CONFIG_WITH_EMU) += ffdecsa/ffdecsa.c
+UNAME := $(shell uname -s)
+ifneq ($(UNAME),Darwin)
+ifndef ANDROID_NDK
+ifndef ANDROID_STANDALONE_TOOLCHAIN
+ifeq "$(CONFIG_WITH_EMU)" "y"
+TOUCH_SK := $(shell touch SoftCam.Key)
+override LDFLAGS += -Wl,--format=binary -Wl,SoftCam.Key -Wl,--format=default
+endif
+endif
+endif
+endif
 SRC-$(CONFIG_CS_CACHEEX) += module-csp.c
 SRC-$(CONFIG_CW_CYCLE_CHECK) += module-cw-cycle-check.c
 SRC-$(CONFIG_WITH_AZBOX) += module-dvbapi-azbox.c
@@ -359,7 +376,7 @@
 # starts the compilation.
 all:
 	@./config.sh --use-flags "$(USE_FLAGS)" --objdir "$(OBJDIR)" --make-config.mak
-	@-mkdir -p $(OBJDIR)/cscrypt $(OBJDIR)/csctapi $(OBJDIR)/minilzo $(OBJDIR)/webif
+	@-mkdir -p $(OBJDIR)/cscrypt $(OBJDIR)/csctapi $(OBJDIR)/minilzo $(OBJDIR)/ffdecsa $(OBJDIR)/webif
 	@-printf "\
 +-------------------------------------------------------------------------------\n\
 | OSCam ver: $(VER) rev: $(SVN_REV) target: $(TARGET)\n\
diff -ruN oscam-emu-2015-12-03-11142.orig/module-cccam.c oscam-emu-2015-12-03-11142/module-cccam.c
--- oscam-emu-2015-12-03-11142.orig/module-cccam.c	2015-11-05 21:21:45.000000000 +0300
+++ oscam-emu-2015-12-03-11142/module-cccam.c	2015-12-04 00:43:30.000000000 +0300
@@ -1713,7 +1713,7 @@
  cs_log("aborting idx:%d caid:%04x client:%d timedelta:%d",ecmtask[i].idx,ecmtask[i].caid,ecmtask[i].cidx,td);
  ecmtask[i].rc=0;
  ecmtask[i].rcEx=7;
- write_ecm_answer(rdr, fd_c2m, &ecmtask[i], 0, NULL);
+ write_ecm_answer(rdr, fd_c2m, &ecmtask[i], 0);
  }
  }
  return n;
diff -ruN oscam-emu-2015-12-03-11142.orig/module-dvbapi.c oscam-emu-2015-12-03-11142/module-dvbapi.c
--- oscam-emu-2015-12-03-11142.orig/module-dvbapi.c	2015-12-12 00:38:27.894433427 +0300
+++ oscam-emu-2015-12-03-11142/module-dvbapi.c	2015-12-04 00:43:30.000000000 +0300
@@ -38,46 +38,46 @@
 #endif
 
 const char *streamtxt_00_to_1B[] = {
-								"Reserved",			 																		// 00
-								"Videostream (MPEG-1)",																		// 01
-								"Videostream (MPEG-2)",																		// 02
-								"Audiostream (MPEG-1)",																		// 03
-								"Audiostream (MPEG-2)",																		// 04
-								"Datastream (MPEG-2 tabled data)",															// 05
-								"Data-/Audiostream (Subtitles/VBI and AC-3)",												// 06
-								"Datastream (MHEG)",																		// 07
-								"Datastream (DSM CC)",																		// 08
+								"Reserved",                                                                                 // 00
+								"Videostream (MPEG-1)",                                                                     // 01
+								"Videostream (MPEG-2)",                                                                     // 02
+								"Audiostream (MPEG-1)",                                                                     // 03
+								"Audiostream (MPEG-2)",                                                                     // 04
+								"Datastream (MPEG-2 tabled data)",                                                          // 05
+								"Data-/Audiostream (Subtitles/VBI and AC-3)",                                               // 06
+								"Datastream (MHEG)",                                                                        // 07
+								"Datastream (DSM CC)",                                                                      // 08
 								"Conditional Access ",																		// 09
-								"Datastream (DSM CC)",																		// 0A
-								"Datastream (DSM CC)",																		// 0B
-								"Datastream (DSM CC)",																		// 0C
-								"Datastream (DSM CC)",																		// 0D
-								"Datastream (Auxiliary)",																	// 0E
-								"Audiostream (MPEG-2)",																		// 0F
-								"Videostream (MPEG-4 H.263)",																// 10
-								"Audiostream (MPEG-4)",																		// 11
-								"Datastream (MPEG-4 FlexMux)",																// 12
-								"Datastream (MPEG-4 FlexMux)",																// 13
-								"Datastream (DSM CC)",																		// 14
-								"Datastream (Metadata)",																	// 15
-								"Datastream (Metadata)",																	// 16
-								"Datastream (DSM CC)",																		// 17
-								"Datastream (DSM CC)",																		// 18
-								"Datastream (Metadata)",																	// 19
-								"Datastream (IPMP)",																		// 1A
-								"Videostream (MPEG-4)",																		// 1B
-							};
+								"Datastream (DSM CC)",                                                                      // 0A
+								"Datastream (DSM CC)",                                                                      // 0B
+								"Datastream (DSM CC)",                                                                      // 0C
+								"Datastream (DSM CC)",                                                                      // 0D
+								"Datastream (Auxiliary)",                                                                   // 0E
+								"Audiostream (MPEG-2)",                                                                     // 0F
+								"Videostream (MPEG-4 H.263)",                                                               // 10
+								"Audiostream (MPEG-4)",                                                                     // 11
+								"Datastream (MPEG-4 FlexMux)",                                                              // 12
+								"Datastream (MPEG-4 FlexMux)",                                                              // 13
+								"Datastream (DSM CC)",                                                                      // 14
+								"Datastream (Metadata)",                                                                    // 15
+								"Datastream (Metadata)",                                                                    // 16
+								"Datastream (DSM CC)",                                                                      // 17
+								"Datastream (DSM CC)",                                                                      // 18
+								"Datastream (Metadata)",                                                                    // 19
+								"Datastream (IPMP)",                                                                        // 1A
+								"Videostream (MPEG-4)",                                                                     // 1B
+};
 
 const char *streamtxt_80_to_87[] = {
-								"Video-/Audiostream (H.262/PCM)",															// 80
-								"Audiostream (Dolby Digital)",																// 81
-								"Data-/Audiostream (Subtitles/DTS6)",														// 82
-								"Audiostream (Dolby TrueHD)",																// 83
-								"Audiostream (Dolby Digital Plus)",															// 84
-								"Audiostream (DTS 8)",																		// 85
-								"Audiostream (DTS 8 losless)",																// 86
-								"Audiostream (Dolby Digital Plus)",															// 87
-							};
+								"Video-/Audiostream (H.262/PCM)",                                                           // 80
+								"Audiostream (Dolby Digital)",                                                              // 81
+								"Data-/Audiostream (Subtitles/DTS6)",                                                       // 82
+								"Audiostream (Dolby TrueHD)",                                                               // 83
+								"Audiostream (Dolby Digital Plus)",                                                         // 84
+								"Audiostream (DTS 8)",                                                                      // 85
+								"Audiostream (DTS 8 losless)",                                                              // 86
+								"Audiostream (Dolby Digital Plus)",                                                         // 87
+};
 
 const char *get_streamtxt(uint8_t id)
 {
@@ -87,47 +87,46 @@
 	}
 	else if(id == 0x24)
 	{
-		return 	"Videostream (H.265 Ultra HD video)";
+		return  "Videostream (H.265 Ultra HD video)";
 	}
 	else if(id == 0x42)
 	{
-		return 	"Videostream (Chinese Video Standard)";
+		return  "Videostream (Chinese Video Standard)";
 	}
 	else if(id >= 0x80 && id <= 0x87)
 	{
-		return 	streamtxt_80_to_87[id - 0x80];
+		return  streamtxt_80_to_87[id - 0x80];
 	}
 	else if(id == 0x90)
 	{
-		return 	"Datastream (Blu-ray subtitling)";
+		return  "Datastream (Blu-ray subtitling)";
 	}
 	else if(id == 0x95)
 	{
-		return 	"Datastream (DSM CC)";
+		return  "Datastream (DSM CC)";
 	}
 	else if(id == 0xC0)
 	{
-		return 	"Datastream (DigiCipher II text)";
+		return  "Datastream (DigiCipher II text)";
 	}
 	else if(id == 0xC2)
 	{
-		return 	"Datastream (DSM CC)";
+		return  "Datastream (DSM CC)";
 	}
 	else if(id == 0xD1)
 	{
-		return 	"Videostream (BBC Dirac Ultra HD video)";
+		return  "Videostream (BBC Dirac Ultra HD video)";
 	}
 	else if(id == 0xEA)
 	{
-		return 	"Videostream (WMV9 lower bit-rate)";
+		return  "Videostream (WMV9 lower bit-rate)";
 	}
 	else
 	{
-		return "Reserved";	
+		return "Reserved"; 
 	}
 }
 
-
 void flush_read_fd(int32_t demux_index, int32_t num, int fd)
 {
 	if(!cfg.dvbapi_listenport && cfg.dvbapi_boxtype != BOXTYPE_PC_NODMX)
@@ -624,7 +623,7 @@
 		case DVBAPI_CA_SET_DESCR_MODE:
 		{
 			int sct_cadescr_mode_size = sizeof(ca_descr_mode_t);
-
+			
 			if (client_proto_version >= 1)
 			{
 				ca_descr_mode_t *cadesc_mode = (ca_descr_mode_t *) data;
@@ -633,7 +632,7 @@
 				cadesc_mode->cipher_mode = htonl(cadesc_mode->cipher_mode);
 			}
 			memcpy(&packet[size], data, sct_cadescr_mode_size);
-
+			
 			size += sct_cadescr_mode_size;
 			break;
 		}
@@ -840,7 +839,6 @@
 		demux[demux_id].demux_fd[n].type     = type;
 		memcpy(demux[demux_id].demux_fd[n].filter, filt, 16); // copy filter to check later on if receiver delivered accordingly
 		memcpy(demux[demux_id].demux_fd[n].mask, mask, 16); // copy mask to check later on if receiver delivered accordingly
-		cs_log_dbg(D_DVBAPI, "Demuxer %d Filter %d started successfully (caid %04X provid %06X pid %04X)", demux_id, n + 1, caid, provid, pid);
 		if(type == TYPE_EMM && add_to_emm_list){ 
 			add_emmfilter_to_list(demux_id, filt, caid, provid, pid, n + 1, true);
 		}
@@ -892,17 +890,18 @@
 	
 	int32_t i = 0, n = 0, devnum = -1, dmx_fd = 0, filtercount = 0;
 	char device_path[128], device_path2[128];
-	static LLIST *ll_max_fd; 
+
+	static LLIST *ll_max_fd;
 	ll_max_fd = ll_create("ll_max_fd");
 	LL_ITER itr;
 	
 	struct s_open_fd
 	{
 		uint32_t fd;
-	}; 
- 
+	};
+	
 	struct s_open_fd *open_fd;
-
+	
 	while (i < BOX_COUNT)
 	{
 		do
@@ -922,7 +921,7 @@
 				open_fd->fd = dmx_fd;
 				ll_append(ll_max_fd, open_fd);
 			}
-		
+	
 			if(filtercount > 0)
 			{
 				itr = ll_iter_create(ll_max_fd);
@@ -952,10 +951,10 @@
 #endif
 				maxfilter = filtercount;
 				cs_log("Detected %s Api: %d, userconfig boxtype: %d maximum amount of possible filters is %d (oscam limit is %d)",
-					device_path, selected_api, cfg.dvbapi_boxtype, filtercount, MAX_FILTER);
+				device_path, selected_api, cfg.dvbapi_boxtype, filtercount, MAX_FILTER);
 			}
-		
-			/* try at least 8 adapters */
+			
+				/* try at least 8 adapters */
 			if ((strchr(devices[i].path, '%') != NULL) && (n < 8)) n++; else { n = 0; i++; }
 		}while(n != 0); // n is set to 0 again if 8 adapters are tried!
 		
@@ -965,7 +964,6 @@
 	ll_destroy(&ll_max_fd);
 
 	if(devnum == -1) { return 0; }
-	
 #endif
 	return 1;
 }
@@ -1132,9 +1130,9 @@
 		if(demux[demux_index].demux_fd[g].type == type)
 		{
 			if(dvbapi_stop_filternum(demux_index, g) == -1)
-			{ 
+			{
 				error = 1;
-			}  
+			} 
 		}
 	}
 	return !error; // on error return 0, all ok 1
@@ -1162,44 +1160,45 @@
 			cs_log_dbg(D_DVBAPI, "Demuxer %d stop filter %d try %d (fd: %d api: %d, caid: %04X, provid: %06X, %spid: %04X)", demux_index, num + 1, try,
 						fd, selected_api, demux[demux_index].demux_fd[num].caid, demux[demux_index].demux_fd[num].provid,
 						(demux[demux_index].demux_fd[num].type == TYPE_ECM ? "ecm" : "emm"), demux[demux_index].demux_fd[num].pid);
-
+	
 			switch(selected_api)
 			{
-			case DVBAPI_3:
-				if (cfg.dvbapi_listenport || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX)
-					retfilter = dvbapi_net_send(DVBAPI_DMX_STOP, demux[demux_index].socket_fd, demux_index, num, NULL, NULL, NULL);
-				else
+				case DVBAPI_3:
+					if (cfg.dvbapi_listenport || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX)
+						retfilter = dvbapi_net_send(DVBAPI_DMX_STOP, demux[demux_index].socket_fd, demux_index, num, NULL, NULL, NULL);
+					else
+						retfilter = dvbapi_ioctl(fd, DMX_STOP, NULL);
+					break;
+	
+				case DVBAPI_1:
 					retfilter = dvbapi_ioctl(fd, DMX_STOP, NULL);
-				break;
-
-			case DVBAPI_1:
-				retfilter = dvbapi_ioctl(fd, DMX_STOP, NULL);
-				break;
+					break;
 
 #if defined(WITH_STAPI) || defined(WITH_STAPI5)
-			case STAPI:
-				retfilter = stapi_remove_filter(demux_index, num, demux[demux_index].pmt_file);
-				if(retfilter != 1)   // stapi returns 0 for error, 1 for all ok
-				{
-					retfilter = -1;
-				}
-				break;
+				case STAPI:
+					retfilter = stapi_remove_filter(demux_index, num, demux[demux_index].pmt_file);
+					if(retfilter != 1)   // stapi returns 0 for error, 1 for all ok
+					{
+						retfilter = -1;
+					}
+					break;
 #endif
 #if defined WITH_COOLAPI || defined WITH_COOLAPI2
-			case COOLAPI:
-				retfilter = coolapi_remove_filter(fd, num);
-				if(retfilter >=0 )
-				{
-					retfd = coolapi_close_device(fd);
-				}
-				break;
+				case COOLAPI:
+					retfilter = coolapi_remove_filter(fd, num);
+					if(retfilter >=0 )
+					{
+						retfd = coolapi_close_device(fd);
+					}
+					break;
 #endif
-			default:
-				break;
+				default:
+					break;
 			}
 		} while (retfilter < 0 && try < 10);
 		
 #if !defined WITH_COOLAPI && !defined WITH_COOLAPI2 // no fd close for coolapi and stapi, all others do close fd!
+		
 		try = 0;
 		do
 		{
@@ -1211,19 +1210,19 @@
 			if (!cfg.dvbapi_listenport && cfg.dvbapi_boxtype != BOXTYPE_PC_NODMX)
 			{
 				if(selected_api == STAPI)
-				{ 
-					retfd = 0;	// stapi closes its own filter fd!
-				}  
+				{
+					retfd = 0;  // stapi closes its own filter fd!
+				} 
 				else
 				{
 					flush_read_fd(demux_index, num, fd); // flush filter input buffer in attempt to avoid overflow receivers internal buffer
 					retfd = close(fd);
 					if(errno == 9) { retfd = 0; }  // no error on bad file descriptor
 				}
-			}
+			}  
 			else
-				retfd = 0;
-			
+			retfd = 0;
+		
 		} while (retfd < 0 && try < 10);
 #endif
 	}
@@ -1241,7 +1240,7 @@
 	if(retfd < 0) // error on close filter fd
 	{ 
 		cs_log("ERROR: Demuxer %d could not close fd of Filter %d (fd=%d api:%d errno=%d %s)", demux_index, num + 1, fd,
-			selected_api, errno, strerror(errno));
+			   selected_api, errno, strerror(errno));
 		return retfd;
 	}
 	
@@ -1251,8 +1250,8 @@
 	{
 		int32_t oldpid = demux[demux_index].demux_fd[num].pidindex;
 		int32_t curpid = demux[demux_index].pidindex;
-		
-		// workaround: below dont run on stapi since it handles it own pids.... stapi need to be better integrated in oscam dvbapi.		
+	
+			// workaround: below dont run on stapi since it handles it own pids.... stapi need to be better integrated in oscam dvbapi.     
 		if(selected_api != STAPI)
 		{
 			int32_t z;
@@ -1260,17 +1259,17 @@
 			{
 				ca_index_t idx = demux[demux_index].ECMpids[oldpid].index[z];
 				demux[demux_index].ECMpids[oldpid].index[z] = INDEX_INVALID;
-		
+				
 				if(idx != INDEX_INVALID) // if in use
 				{
 					int32_t i;
 					for(i = 0; i < demux[demux_index].STREAMpidcount; i++)
 					{
 						int8_t match = 0;
-						// check streams of old disabled ecmpid
+							// check streams of old disabled ecmpid
 						if(!demux[demux_index].ECMpids[oldpid].streams || ((demux[demux_index].ECMpids[oldpid].streams & (1 << i)) == (uint) (1 << i)))
 						{
-							// check if new ecmpid is using same streams
+								// check if new ecmpid is using same streams
 							if(curpid != -1 && (!demux[demux_index].ECMpids[curpid].streams || ((demux[demux_index].ECMpids[curpid].streams & (1 << i)) == (uint) (1 << i))))
 							{
 								continue; // found same stream on old and new ecmpid -> skip! (and leave it enabled!)
@@ -1279,22 +1278,22 @@
 							int32_t pidtobestopped = demux[demux_index].STREAMpids[i];
 							int32_t j, k, otherdemuxpid;
 							ca_index_t otherdemuxidx;
-							
+	
 							for(j = 0; j < MAX_DEMUX; j++) // check other demuxers for same streampid with same index
 							{
-								if(demux[j].program_number == 0) { continue; }  					// skip empty demuxers
-								if(demux_index == j) { continue; } 									// skip same demuxer
-								if(demux[j].ca_mask != demux[demux_index].ca_mask) { continue;}		// skip streampid running on other ca device
-								
+								if(demux[j].program_number == 0) { continue; }                      // skip empty demuxers
+								if(demux_index == j) { continue; }                                  // skip same demuxer
+								if(demux[j].ca_mask != demux[demux_index].ca_mask) { continue;}     // skip streampid running on other ca device
+	
 								otherdemuxpid = demux[j].pidindex;
-								if(otherdemuxpid == -1) { continue; }          						// Other demuxer not descrambling yet
-												
+								if(otherdemuxpid == -1) { continue; }                               // Other demuxer not descrambling yet
+	
 								int32_t y;
 								for(y = 0; y < MAX_STREAM_INDICES; y++)
 								{
 									otherdemuxidx = demux[j].ECMpids[otherdemuxpid].index[y];
-									if(otherdemuxidx == INDEX_INVALID || otherdemuxidx != idx) { continue; } 			// Other demuxer has no index yet, or index is different
-										
+									if(otherdemuxidx == INDEX_INVALID || otherdemuxidx != idx) { continue; }            // Other demuxer has no index yet, or index is different
+	
 									for(k = 0; k < demux[j].STREAMpidcount; k++)
 									{
 										if(!demux[j].ECMpids[otherdemuxpid].streams || ((demux[j].ECMpids[otherdemuxpid].streams & (1 << k)) == (uint) (1 << k)))
@@ -1308,10 +1307,9 @@
 									}
 								}
 							}
-								
 							if(!match)
 							{
-								dvbapi_set_pid(demux_index, i, idx, false, false); // disable streampid since its not used by this pid (or by the new ecmpid or any other demuxer!) 
+								dvbapi_set_pid(demux_index, i, idx, false, false); // disable streampid since its not used by this pid (or by the new ecmpid or any other demuxer!)
 							}
 						}
 					}
@@ -1370,7 +1368,7 @@
 	uchar filter[16], mask[16];
 	memset(filter, 0, 16);
 	memset(mask, 0, 16);
-
+	
 	filter[0] = 0x02;
 	i2b_buf(2, demux[demux_index].program_number, filter + 1); // add srvid to filter since the pid can deliver pmt for multiple srvid
 	mask[0] = 0xFF;
@@ -1430,7 +1428,15 @@
 			}
 			if(match)
 			{
-				csystem = get_cardsystem_by_caid(caid);
+				if(rdr->typ == R_EMU)
+				{
+					csystem = rdr->csystem;
+				}
+				else
+				{
+					csystem = get_cardsystem_by_caid(caid);	
+				}
+				
 				if(csystem)
 				{
 					if(caid != ncaid)
@@ -1449,7 +1455,14 @@
 					}
 					else if (csystem->get_emm_filter)
 					{
-						csystem->get_emm_filter(rdr, &dmx_filter, &filter_count);
+						if(rdr->typ == R_EMU)
+						{
+							csystem->get_emm_filter_adv(rdr, &dmx_filter, &filter_count, caid, provid);
+						}
+						else
+						{
+							csystem->get_emm_filter(rdr, &dmx_filter, &filter_count);
+						}
 					}
 				}
 				else
@@ -1507,7 +1520,7 @@
 	cs_log_dbg(D_DVBAPI, "Demuxer %d handles %i emm filters", demux_index, demux[demux_index].emm_filter);
 }
 
-void dvbapi_add_ecmpid_int(int32_t demux_id, uint16_t caid, uint16_t ecmpid, uint32_t provid, char *txt) 
+void dvbapi_add_ecmpid_int(int32_t demux_id, uint16_t caid, uint16_t ecmpid, uint32_t provid, uint32_t privdata, char *txt) 
 {
 	int32_t n, added = 0;
 	
@@ -1550,6 +1563,7 @@
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].irdeto_maxindex = 0; // reset
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].irdeto_cycle = 0xFE; // reset
 	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].table = 0;
+	demux[demux_id].ECMpids[demux[demux_id].ECMpidcount].privdata = privdata;
 
 	cs_log("Demuxer %d ecmpid %d CAID: %04X ECM_PID: %04X PROVID: %06X %s", demux_id, demux[demux_id].ECMpidcount, caid, ecmpid, provid, txt);
 	if(caid_is_irdeto(caid)) { demux[demux_id].emmstart.time = 1; }  // marker to fetch emms early irdeto needs them!
@@ -1557,9 +1571,9 @@
 	demux[demux_id].ECMpidcount++;
 }
 
-void dvbapi_add_ecmpid(int32_t demux_id, uint16_t caid, uint16_t ecmpid, uint32_t provid, char *txt)
+void dvbapi_add_ecmpid(int32_t demux_id, uint16_t caid, uint16_t ecmpid, uint32_t provid, uint32_t privdata, char *txt)
 {
-	dvbapi_add_ecmpid_int(demux_id, caid, ecmpid, provid, txt);
+	dvbapi_add_ecmpid_int(demux_id, caid, ecmpid, provid, privdata, txt);
 	struct s_dvbapi_priority *joinentry;
 
 	for(joinentry = dvbapi_priority; joinentry != NULL; joinentry = joinentry->next)
@@ -1572,24 +1586,29 @@
 			{ continue; }
 		cs_log_dbg(D_DVBAPI, "Join ecmpid %04X@%06X:%04X to %04X@%06X:%04X",
 					  caid, provid, ecmpid, joinentry->mapcaid, joinentry->mapprovid, joinentry->mapecmpid);
-		dvbapi_add_ecmpid_int(demux_id, joinentry->mapcaid, joinentry->mapecmpid, joinentry->mapprovid, txt);
+		dvbapi_add_ecmpid_int(demux_id, joinentry->mapcaid, joinentry->mapecmpid, joinentry->mapprovid, 0, txt);
 	}
 }
 
-void dvbapi_add_emmpid(int32_t demux_id, uint16_t caid, uint16_t emmpid, uint32_t provid, uint8_t type)
+void dvbapi_add_emmpid(int32_t demux_id, uint16_t caid, uint16_t emmpid, uint32_t provid, uint32_t privdata, uint8_t type)
 {
 	char typetext[40];
+	char privdatatext[40];
 	cs_strncpy(typetext, ":", sizeof(typetext));
 
 	if(type & 0x01) { strcat(typetext, "UNIQUE:"); }
 	if(type & 0x02) { strcat(typetext, "SHARED:"); }
 	if(type & 0x04) { strcat(typetext, "GLOBAL:"); }
 	if(type & 0xF8) { strcat(typetext, "UNKNOWN:"); }
+	if(privdata > 0) snprintf(privdatatext, 40, " PRIVATE DATA %X ", privdata);
+	else strcat(privdatatext, " ");
 
+	if(caid == 0x4AE1 && provid == 0x11 && privdata == 0) return; // megavolt Need rewrite, add priority
+	
 	uint16_t i;
 	for(i = 0; i < demux[demux_id].EMMpidcount; i++)
 	{
-		if(demux[demux_id].EMMpids[i].PID == emmpid && demux[demux_id].EMMpids[i].CAID == caid && demux[demux_id].EMMpids[i].PROVID == provid)
+		if(demux[demux_id].EMMpids[i].PID == emmpid && demux[demux_id].EMMpids[i].CAID == caid && demux[demux_id].EMMpids[i].PROVID == provid && demux[demux_id].EMMpids[i].privdata == privdata)
 		{
 			if(!(demux[demux_id].EMMpids[i].type&type)){
 				demux[demux_id].EMMpids[i].type |= type; // register this emm kind to this emmpid
@@ -1602,7 +1621,8 @@
 	demux[demux_id].EMMpids[demux[demux_id].EMMpidcount].CAID = caid;
 	demux[demux_id].EMMpids[demux[demux_id].EMMpidcount].PROVID = provid;
 	demux[demux_id].EMMpids[demux[demux_id].EMMpidcount++].type = type;
-	cs_log_dbg(D_DVBAPI, "Added new emmpid %d CAID: %04X EMM_PID: %04X PROVID: %06X TYPE %s", demux[demux_id].EMMpidcount - 1, caid, emmpid, provid, typetext);
+	demux[demux_id].EMMpids[demux[demux_id].EMMpidcount++].privdata = privdata;
+	cs_log_dbg(D_DVBAPI, "Added new emmpid %d CAID: %04X EMM_PID: %04X PROVID: %06X%sTYPE %s", demux[demux_id].EMMpidcount - 1, caid, emmpid, provid, privdatatext, typetext);
 }
 
 void dvbapi_parse_cat(int32_t demux_id, uchar *buf, int32_t len)
@@ -1634,6 +1654,7 @@
 	uint16_t i, k;
 
 	cs_log_dump_dbg(D_DVBAPI, buf, len, "cat:");
+	//FILE *f = fopen("/tmp/emm_pid.bin","wb"); fwrite(buf,len,1,f); fclose(f); //megavolt
 
 	for(i = 8; i < (b2i(2, buf + 1)&0xFFF) - 1; i += buf[i + 1] + 2)
 	{
@@ -1647,12 +1668,12 @@
 		switch(caid >> 8)
 		{
 			case 0x01:
-				dvbapi_add_emmpid(demux_id, caid, emm_pid, 0, EMM_UNIQUE | EMM_GLOBAL);
+				dvbapi_add_emmpid(demux_id, caid, emm_pid, 0, 0, EMM_UNIQUE | EMM_GLOBAL);
 				for(k = i + 7; k < i + buf[i + 1] + 2; k += 4)
 				{
 					emm_provider = b2i(2, buf + k + 2);
 					emm_pid = b2i(2, buf + k)&0xFFF;
-					dvbapi_add_emmpid(demux_id, caid, emm_pid, emm_provider, EMM_SHARED);
+					dvbapi_add_emmpid(demux_id, caid, emm_pid, emm_provider, 0, EMM_SHARED);
 				}
 				break;
 			case 0x05:
@@ -1661,7 +1682,7 @@
 					if (buf[k] == 0x14)
 					{
 						emm_provider = (b2i(3, buf + k + 2) & 0xFFFFF0); // viaccess fixup last digit is a dont care!
-						dvbapi_add_emmpid(demux_id, caid, emm_pid, emm_provider, EMM_UNIQUE | EMM_SHARED | EMM_GLOBAL);
+						dvbapi_add_emmpid(demux_id, caid, emm_pid, emm_provider, 0, EMM_UNIQUE | EMM_SHARED | EMM_GLOBAL);
 					}
 				}
 				break;
@@ -1671,16 +1692,30 @@
 					for(k = i + 7; k < i + 7 + buf[i + 6]; k += 2)
 					{
 						emm_provider = b2i(2, buf + k);
-						dvbapi_add_emmpid(demux_id, caid, emm_pid, emm_provider, EMM_UNIQUE | EMM_SHARED | EMM_GLOBAL);
+						dvbapi_add_emmpid(demux_id, caid, emm_pid, emm_provider, 0, EMM_UNIQUE | EMM_SHARED | EMM_GLOBAL);
 					}
 				}
 				else
 				{
-					dvbapi_add_emmpid(demux_id, caid, emm_pid, emm_provider, EMM_UNIQUE | EMM_SHARED | EMM_GLOBAL);
+					dvbapi_add_emmpid(demux_id, caid, emm_pid, emm_provider, 0, EMM_UNIQUE | EMM_SHARED | EMM_GLOBAL);
+				}
+				break;
+			case 0x27:
+			case 0x4A:
+				emm_provider = (uint32_t)buf[i+6];
+				if(buf[i+6] == 0xFE) dvbapi_add_emmpid(demux_id, caid, emm_pid, emm_provider, 0x102, EMM_GLOBAL);
+				else
+				{
+					uint32_t privdata = 0;
+					if(buf[i+1] == 0x0A)
+					{
+						privdata = (buf[i+8] << 24) | (buf[i+9] << 16) | (buf[i+10] << 8) | buf[i+11];
+					}
+					dvbapi_add_emmpid(demux_id, caid, emm_pid, emm_provider, privdata, EMM_UNIQUE | EMM_SHARED | EMM_GLOBAL);
 				}
 				break;
 			default:
-				dvbapi_add_emmpid(demux_id, caid, emm_pid, 0, EMM_UNIQUE | EMM_SHARED | EMM_GLOBAL);
+				dvbapi_add_emmpid(demux_id, caid, emm_pid, 0, 0, EMM_UNIQUE | EMM_SHARED | EMM_GLOBAL);
 				break;
 		}
 	}
@@ -1725,7 +1760,7 @@
 			{
 				for(k = 0; k < MAX_STREAM_INDICES; k++)
 				{
-					if(demux[i].ECMpids[j].index[k] == idx) 
+					if(demux[i].ECMpids[j].index[k] == idx)
 					{
 						fail = 1;
 						idx++;
@@ -1738,8 +1773,7 @@
 		{
 			idx = 0;
 			fail = 1;
-		}	
-		
+		}   
 		cs_sleepms(1);
 	}
 	
@@ -1751,14 +1785,13 @@
 {
 	int32_t i, currentfd;
 	ca_index_t newidx = 0, curidx;
-	
 	if(demux[demux_id].pidindex == -1 && enable) return; // no current pid on enable? --> exit
 
 	switch(selected_api)
 	{
 #if defined(WITH_STAPI) || defined(WITH_STAPI5)
 	case STAPI:
-		if(!enable) idx = INDEX_STAPI_DISABLE;
+		 if(!enable) idx = INDEX_STAPI_DISABLE;
 		stapi_set_pid(demux_id, num, idx, demux[demux_id].STREAMpids[num], demux[demux_id].pmt_file); // only used to disable pids!!!
 		break;
 #endif
@@ -1787,7 +1820,7 @@
 					ca_pid2.pid = demux[demux_id].STREAMpids[num];
 					
 					// removed last of this streampid on ca? -> disable this pid with -1 on this ca
-					if((action == REMOVED_STREAMPID_LASTINDEX) && (is_ca_used(i, ca_pid2.pid) == INDEX_NOTFOUND)) curidx = INDEX_DISABLE; 
+					if((action == REMOVED_STREAMPID_LASTINDEX) && (is_ca_used(i, ca_pid2.pid) == INDEX_NOTFOUND)) curidx = INDEX_DISABLE;
 					
 					// removed index of streampid that is used to decode on ca -> get a fresh one
 					if(action == REMOVED_DECODING_STREAMPID_INDEX)
@@ -1795,7 +1828,7 @@
 						newidx = is_ca_used(i, demux[demux_id].STREAMpids[num]); // get an active index for this pid and enable it on ca device
 						curidx = INDEX_DISABLE;
 					}
-
+	
 					while (curidx != INDEX_INVALID || newidx != INDEX_INVALID)
 					{
 						if(curidx != INDEX_INVALID)
@@ -1808,11 +1841,10 @@
 						else if (newidx != INDEX_INVALID)
 						{
 							ca_pid2.index = newidx;
-							cs_log_dbg(D_DVBAPI, "Demuxer %d takeover stream %d pid=0x%04x by index=%d on ca%d", demux_id, num + 1,
-								ca_pid2.pid, ca_pid2.index, i);
+							cs_log_dbg(D_DVBAPI, "Demuxer %d takeover stream %d pid=0x%04x by index=%d on ca%d", demux_id, num + 1, ca_pid2.pid, ca_pid2.index, i);
 							newidx = INDEX_INVALID; // flag this takeover / new index as handled
 						}
-
+	
 						if(use_des && cfg.dvbapi_extended_cw_api == 2)
 						{
 							ca_pid2.index |= 0x100;
@@ -1835,9 +1867,8 @@
 									cs_log_dbg(D_TRACE | D_DVBAPI,"CA_SET_PID ioctl error (errno=%d %s)", errno, strerror(errno));
 									remove_streampid_from_list(i, ca_pid2.pid, ca_pid2.index);
 								}
-								
 								ca_index_t result = is_ca_used(i,0); // check if in use by any pid
-								
+	
 								if(result == INDEX_NOTFOUND)
 								{
 									cs_log_dbg(D_DVBAPI, "Demuxer %d close now unused CA%d device", demux_id, i);
@@ -1878,7 +1909,6 @@
 	}
 }
 
-
 void dvbapi_stop_descrambling(int32_t demux_id)
 {
 	int32_t i, j;
@@ -1940,7 +1970,8 @@
 				|| (p->provid && p->provid != demux[demux_id].ECMpids[pid].PROVID)
 				|| (p->ecmpid && p->ecmpid != demux[demux_id].ECMpids[pid].ECM_PID)
 				|| (p->srvid && p->srvid != demux[demux_id].program_number)
-				|| (p->pidx && p->pidx-1 != pid))
+				|| (p->pidx && p->pidx-1 != pid)
+				|| (p->privdata && p->privdata != demux[demux_id].ECMpids[pid].privdata))
 			{ continue; }
 		// if found chid and first run apply chid filter, on forced pids always apply!
 		if(p->type == 'p' && p->chid < 0x10000 && (demux[demux_id].ECMpids[pid].checked == 1 || (p && p->force)))
@@ -1993,13 +2024,13 @@
 				   (int)(gone/1000));
 			continue; // skip this card needs to process emms first before it can be used for descramble
 		}
-		if(p && p->force) { match = 1; }  // forced pid always started!
+		if(p && p->force) { match = 1;}  // forced pid always started!
 
 		if(!match) // if this reader does not match, check betatunnel for it
 			match = lb_check_auto_betatunnel(er, rdr);
 
 		if(!match && chk_is_betatunnel_caid(er->caid))  // these caids might be tunneled invisible by peers
-			{ match = 1; } // so make it a match to try it!
+			{ match = 1;} // so make it a match to try it!
 
 		if(config_enabled(CS_CACHEEX) && (!match && (cacheex_is_match_alias(dvbapi_client, er))))   // check if cache-ex is matching
 		{
@@ -2306,9 +2337,9 @@
 
 		char c_srvid[34];
 		c_srvid[0] = '\0';
-		uint32_t caid = 0, provid = 0, srvid = 0, ecmpid = 0;
+		uint32_t caid = 0, provid = 0, srvid = 0, ecmpid = 0, privdata = 0;
 		uint32_t chid = 0x10000; //chid=0 is a valid chid
-		ret = sscanf(str1, "%4x:%6x:%33[^:]:%4x:%4x"SCNx16, &caid, &provid, c_srvid, &ecmpid, &chid);
+		ret = sscanf(str1, "%4x:%6x:%33[^:]:%4x:%4x:%8x"SCNx16, &caid, &provid, c_srvid, &ecmpid, &chid, &privdata);
 		if(ret < 1)
 		{
 			cs_log("Error in oscam.dvbapi: ret=%d | %c: %04X %06X %s %04X %04X",
@@ -2317,14 +2348,15 @@
 		}
 		else
 		{
-			cs_log_dbg(D_DVBAPI, "Parsing rule: ret=%d | %c: %04X %06X %s %04X %04X",
-						  ret, type, caid, provid, c_srvid, ecmpid, chid);
+			cs_log_dbg(D_DVBAPI, "Parsing rule: ret=%d | %c: %04X %06X %s %04X %04X %04X",
+						  ret, type, caid, provid, c_srvid, ecmpid, chid, privdata);
 		}
 
 		entry->caid = caid;
 		entry->provid = provid;
 		entry->ecmpid = ecmpid;
 		entry->chid = chid;
+		entry->privdata = privdata;
 
 		uint32_t delay = 0, force = 0, mapcaid = 0, mapprovid = 0, mapecmpid = 0, pidx = 0;
 		switch(type)
@@ -2492,6 +2524,7 @@
 			
 			if(prio->type == 'p') // check for prio
 			{
+				if(prio->privdata != 0 && prio->privdata != demux[demux_index].ECMpids[n].privdata) { continue; }
 				if(prio->chid < 0x10000) { demux[demux_index].ECMpids[n].CHID = prio->chid; }
 				if(prio->force)
 				{
@@ -2810,13 +2843,13 @@
 	uint32_t descriptor_length = 0;
 	uint32_t j, u, k;
 	uint8_t skip_border = cfg.dvbapi_boxtype == BOXTYPE_SAMYGO ? 0x05 : 0x02; // skip input values <0x05 on samygo
-	
-	static const char format_identifiers_audio[10][5] = 
-		{
-			"AC-3", "BSSD", "dmat", "DTS1", "DTS2",
-			"DTS3", "EAC3", "HDMV", "mlpa", "Opus",
-		};
 
+	static const char format_identifiers_audio[10][5] =
+	{
+		"AC-3", "BSSD", "dmat", "DTS1", "DTS2",
+		"DTS3", "EAC3", "HDMV", "mlpa", "Opus",
+	};
+	
 	if(info_length < 1)
 		{ return; }
 
@@ -2826,10 +2859,10 @@
 		info_length--;
 	}
 
-	for(j = 0; j + 1 < info_length; j += descriptor_length + 2)
+	for(j = 0; j < info_length; j += descriptor_length + 2)
 	{
 		descriptor_length = buffer[j + 1];
-		
+
 		if(is_audio)
 		{
 			if(buffer[j] == 0x6A || buffer[j] == 0x73 || buffer[j] == 0x81)
@@ -2869,6 +2902,7 @@
 		int32_t descriptor_ca_system_id = b2i(2, buffer + j + 2);
 		int32_t descriptor_ca_pid = b2i(2, buffer + j + 4)&0x1FFF;
 		int32_t descriptor_ca_provider = 0;
+		uint32_t privdata = 0;
 		char txt[40]; // room for PBM: 8 byte pbm and DATE: date
 		memset(txt, 0x00, sizeof(txt));
 
@@ -2884,7 +2918,7 @@
 				snprintf(txt, sizeof(txt), "PBM: "); 
 				cs_hexdump(0, buffer + j + u + 7, 8, txt+5, (2*8)+1); // hexdump 8 byte pbm
 				snprintf(txt+20, sizeof(txt)-20, " DATE: %d-%d-%d", day, month, year+1990); 
-				dvbapi_add_ecmpid(demux_id, descriptor_ca_system_id, descriptor_ca_pid, descriptor_ca_provider, txt);
+				dvbapi_add_ecmpid(demux_id, descriptor_ca_system_id, descriptor_ca_pid, descriptor_ca_provider, 0, txt);
 			}
 		}
 		else
@@ -2892,13 +2926,20 @@
 			if(caid_is_viaccess(descriptor_ca_system_id) && descriptor_length == 0x0F && buffer[j + 12] == 0x14)
 				{ descriptor_ca_provider = b2i(3, buffer + j + 14) &0xFFFFF0; }
 
-			if(caid_is_nagra(descriptor_ca_system_id) && descriptor_length == 0x07)
+			else if(caid_is_nagra(descriptor_ca_system_id) && descriptor_length == 0x07)
 				{ descriptor_ca_provider = b2i(2, buffer + j + 7); }
 			
-			if((descriptor_ca_system_id >> 8 == 0x4A || descriptor_ca_system_id == 0x2710) && descriptor_length > 0x04 )
-				{ descriptor_ca_provider = buffer[j + 6]; }
+			else if(caid_is_dre(descriptor_ca_system_id) && descriptor_length > 0x04 )
+				{ 
+					descriptor_ca_provider = buffer[j + 6];
+					if( descriptor_length == 0xA)
+					{
+						privdata = (buffer[j+8] << 24) | (buffer[j+9] << 16) | (buffer[j+10] << 8) | buffer[j+11];
+						snprintf(txt,40,"PRIVATE DATA: %X",privdata);
+					}
+				}
 
-			dvbapi_add_ecmpid(demux_id, descriptor_ca_system_id, descriptor_ca_pid, descriptor_ca_provider, txt);
+			dvbapi_add_ecmpid(demux_id, descriptor_ca_system_id, descriptor_ca_pid, descriptor_ca_provider, privdata, txt);
 			
 		}
 	}
@@ -3088,7 +3129,7 @@
 	uint16_t ca_mask, demux_index, adapter_index, pmtpid;
 	uint32_t program_number, program_info_length;
 	uint8_t program_info_start = is_real_pmt ? 12 : 6;
-		
+  
 	if(!is_real_pmt)
 	{
 
@@ -3106,13 +3147,13 @@
 #endif
 		program_number = b2i(2, buffer + 1);
 		program_info_length = b2i(2, buffer + 4) &0xFFF;
-		
+	
 		cs_log_dump_dbg(D_DVBAPI, buffer, length, "capmt:");
 		cs_log_dbg(D_DVBAPI, "Receiver sends PMT command %d for channel %04X", ca_pmt_list_management, program_number);
-		
+	
 		if(!pmt_stopmarking && (ca_pmt_list_management == LIST_FIRST || ca_pmt_list_management == LIST_ONLY))
 		{
-			for(i = 0; i < MAX_DEMUX; i++) 
+			for(i = 0; i < MAX_DEMUX; i++)
 			{
 				if(demux[i].program_number == 0) { continue; }  // skip empty demuxers
 				if(demux[i].socket_fd != connfd) { continue; }  // skip demuxers belonging to other ca pmt connection
@@ -3122,64 +3163,66 @@
 			}
 			pmt_stopmarking = 1; // only stop demuxing for first pmt record
 		}
-		
+	
 		getDemuxOptions(i, buffer, &ca_mask, &demux_index, &adapter_index, &pmtpid);
 		cs_log_dbg(D_DVBAPI,"Receiver wants to demux srvid %04X on adapter %04X camask %04X index %04X pmtpid %04X",
-			program_number, adapter_index, ca_mask, demux_index, pmtpid);
-		
+													program_number, adapter_index, ca_mask, demux_index, pmtpid);
+	
 		for(i = 0; i < MAX_DEMUX; i++)    // search current demuxers for running the same program as the one we received in this PMT object
 		{
 			if(demux[i].program_number == 0) { continue; }
 			if(cfg.dvbapi_boxtype == BOXTYPE_IPBOX_PMT) demux_index = i; // fixup for ipbox
-    	
+		
 			bool full_check = 1, matched = 0;
 			if (config_enabled(WITH_COOLAPI) || config_enabled(WITH_COOLAPI2) || cfg.dvbapi_boxtype == BOXTYPE_SAMYGO)
-				full_check = 0;
-    	
+																								full_check = 0;
+		
 			if (full_check)
-				matched = (connfd > 0 && demux[i].socket_fd == connfd) && demux[i].program_number == program_number;
+					matched = (connfd > 0 && demux[i].socket_fd == connfd) && demux[i].program_number == program_number;
 			else
 				matched = connfd > 0 && demux[i].program_number == program_number;
-    	
+			
 			if(matched)
 			{
-				if (full_check) {
+				if (full_check)
+				{
 					if (demux[i].adapter_index != adapter_index) continue; // perhaps next demuxer matches?
 					if (demux[i].ca_mask != ca_mask) continue; // perhaps next demuxer matches?
 					if (demux[i].demux_index != demux_index) continue; // perhaps next demuxer matches?
 				}
-				if(ca_pmt_list_management == LIST_UPDATE){
+				if(ca_pmt_list_management == LIST_UPDATE)
+				{
 					cs_log("Demuxer %d PMT update for decoding of SRVID %04X! ", i, program_number);
 				}
-    	
-				demux_id = i;
 				
+				demux_id = i;
+			
 				cs_log("Demuxer %d continue decoding of SRVID %04X", i, demux[i].program_number);
-    	
+			
 				openxcas_set_sid(program_number);
-    	
+			
 				demux[i].stopdescramble = 0; // dont stop current demuxer!
 				break; // no need to explore other demuxers since we have a found!
 			}
 		}
-    	
+		
 		// start using the new list
 		if(ca_pmt_list_management != LIST_FIRST && ca_pmt_list_management != LIST_MORE)
 		{
 			for(j = 0; j < MAX_DEMUX; j++)
 			{
 				if(demux[j].program_number == 0) { continue; }
-				if(demux[j].stopdescramble == 1) { dvbapi_stop_descrambling(j); }// Stop descrambling and remove all demuxer entries not in new PMT. 
+				if(demux[j].stopdescramble == 1) { dvbapi_stop_descrambling(j); }// Stop descrambling and remove all demuxer entries not in new PMT.
 			}
 			start_descrambling = 1; // flag that demuxer descrambling is to be executed!
 			pmt_stopmarking = 0; // flag that demuxers may be marked for stop decoding again
 		}
-    	
+		
 		if(demux_id == -1)
 		{
 			for(demux_id = 0; demux_id < MAX_DEMUX && demux[demux_id].program_number > 0; demux_id++) { ; }
 		}
-    	
+		
 		if(demux_id >= MAX_DEMUX)
 		{
 			cs_log("ERROR: No free id (MAX_DEMUX)");
@@ -3242,7 +3285,7 @@
 		uint16_t elementary_pid = b2i(2, buffer + i + 1)&0x1FFF;
 		uint8_t is_audio = 0;
 		es_info_length = b2i(2, buffer + i +3)&0x0FFF;
-		
+
 		if(demux[demux_id].STREAMpidcount >= ECM_PIDS)
 		{
 			break;
@@ -3253,23 +3296,22 @@
 		demux[demux_id].STREAMpidcount++;
 		
 		// find and register videopid
-		if(!vpid && 
-			(stream_type == 0x01 || stream_type == 0x02 || stream_type == 0x10 || stream_type == 0x1B 
-			|| stream_type == 0x24 || stream_type == 0x42 || stream_type == 0xD1 || stream_type == 0xEA)) 
+		if(!vpid &&   (stream_type == 0x01 || stream_type == 0x02 || stream_type == 0x10 || stream_type == 0x1B
+					|| stream_type == 0x24 || stream_type == 0x42 || stream_type == 0xD1 || stream_type == 0xEA))
 		{
 			vpid = elementary_pid;
 		}
-		
+
 		if(es_info_length == 0 && stream_type == 0x06) // we are out of luck
 		{
 			demux[demux_id].STREAMpidsType[demux[demux_id].STREAMpidcount-1] = 0x03;
 			stream_type = 0x03;
 		}
-			
+ 	
 		if(es_info_length != 0 && es_info_length < length)
 		{
 			dvbapi_parse_descriptor(demux_id, es_info_length, buffer + i + 5, &is_audio);
-			
+	
 			if((stream_type == 0x06 || stream_type == 0x80 || stream_type == 0x82) && is_audio)
 			{
 				demux[demux_id].STREAMpidsType[demux[demux_id].STREAMpidcount-1] = 0x03;
@@ -3291,18 +3333,18 @@
 					{ continue; }
 				cs_log_dbg(D_DVBAPI, "Demuxer %d fake ecmpid %04X@%06X:%04x for unencrypted stream on srvid %04X", demux_id, addentry->mapcaid, addentry->mapprovid,
 					addentry->mapecmpid, demux[demux_id].program_number);
-				dvbapi_add_ecmpid(demux_id, addentry->mapcaid, addentry->mapecmpid, addentry->mapprovid, " (fake ecmpid)");
+				dvbapi_add_ecmpid(demux_id, addentry->mapcaid, addentry->mapecmpid, addentry->mapprovid, 0, " (fake ecmpid)");
 				break;
 			}
 		}
-		
+
 		cs_log("Demuxer %d stream %s(type: %02x pid: %04x length: %d)", demux_id, get_streamtxt(stream_type), stream_type, elementary_pid, es_info_length);
 	}
 	
 	if(!is_real_pmt)
 	{
 		cs_log("Demuxer %d found %d ECMpids and %d STREAMpids in caPMT", demux_id, demux[demux_id].ECMpidcount, demux[demux_id].STREAMpidcount);
-			
+	
 		getDemuxOptions(demux_id, buffer, &ca_mask, &demux_index, &adapter_index, &pmtpid);
 		demux[demux_id].adapter_index = adapter_index;
 		demux[demux_id].ca_mask = ca_mask;
@@ -3327,12 +3369,12 @@
 		adapter_index = demux[demux_id].adapter_index;
 		connfd = demux[demux_id].socket_fd;
 	}
-	
+ 	
 	for(j = 0; j < demux[demux_id].ECMpidcount; j++)
 	{
 		demux[demux_id].ECMpids[j].VPID = vpid; // register found vpid on all ecmpids of this demuxer
 	}
-		
+	
 	char channame[CS_SERVICENAME_SIZE];
 	get_servicename(dvbapi_client, demux[demux_id].program_number, demux[demux_id].ECMpidcount > 0 ? demux[demux_id].ECMpids[0].PROVID : 0 , demux[demux_id].ECMpidcount > 0 ? demux[demux_id].ECMpids[0].CAID : NO_CAID_VALUE, channame, sizeof(channame));
 	cs_log("Demuxer %d serving srvid %04X (%s) on adapter %04X camask %04X index %04X pmtpid %04X", demux_id,
@@ -3888,16 +3930,16 @@
 {
 	uint16_t srvid;
 	uint32_t i;
-
+	
 	dvbapi_stop_filter(demux_id, TYPE_PAT);
-
+	
 	for(i=8; i+7<length; i+=4)
 	{
 		srvid = b2i(2, buffer+i);
-		
+	
 		if(srvid == 0)
 			{ continue; }
-		
+	
 		if(demux[demux_id].program_number == srvid)
 		{
 			dvbapi_start_pmt_filter(demux_id, b2i(2, buffer+i+2) & 0x1FFF);
@@ -4337,6 +4379,8 @@
 	if(filtertype == TYPE_ECM)
 	{
 		uint32_t chid = 0x10000;
+		int8_t pvu_skip = 0;
+		uint32_t ecmlen = SCT_LEN(buffer);
 		ECM_REQUEST *er;
 		
 		if(len != 0)  // len = 0 receiver encountered an internal bufferoverflow!
@@ -4363,8 +4407,23 @@
 				return;
 			}
 
-			if(curpid->table == buffer[0] && !caid_is_irdeto(curpid->CAID))  // wait for odd / even ecm change (only not for irdeto!)
-			{ 
+			if(curpid->CAID>>8 == 0x0E)
+			{
+				pvu_skip = 1;
+				
+				if(ecmlen > 0xb)
+				{
+					if(buffer[0xb] > curpid->pvu_counter || (curpid->pvu_counter == 255 && buffer[0xb] == 0)
+							|| ((curpid->pvu_counter - buffer[0xb]) > 5))
+					{
+						curpid->pvu_counter = buffer[0xb];
+						pvu_skip = 0;
+					}
+				}
+			}
+
+			if((curpid->table == buffer[0] && !caid_is_irdeto(curpid->CAID)) || pvu_skip)  // wait for odd / even ecm change (only not for irdeto!)
+			{
 				
 				if(!(er = get_ecmtask()))
 				{ 
@@ -4636,7 +4695,6 @@
 			return; // just skip on internal bufferoverflow
 		}
 		
-		
 		if(demux[demux_id].demux_fd[filter_num].pid == 0x01) // CAT
 		{
 			cs_log_dbg(D_DVBAPI, "receiving cat");
@@ -4645,7 +4703,7 @@
 			dvbapi_stop_filternum(demux_id, filter_num);
 			return;
 		}
-		dvbapi_process_emm(demux_id, filter_num, buffer, sctlen);
+		 dvbapi_process_emm(demux_id, filter_num, buffer, sctlen);
 	}
 	
 	if(filtertype == TYPE_SDT)
@@ -4653,18 +4711,18 @@
 		cs_log_dump_dbg(D_DVBAPI, buffer, sctlen, "Demuxer %d Filter %d fetched SDT data (length = 0x%03X):", demux_id, filter_num + 1, sctlen);
 		dvbapi_parse_sdt(demux_id, buffer, sctlen);
 	}
-
+	
 	if(filtertype == TYPE_PAT)
 	{
 		cs_log_dump_dbg(D_DVBAPI, buffer, sctlen, "Demuxer %d Filter %d fetched PAT data (length = 0x%03X):", demux_id, filter_num + 1, sctlen);
 		dvbapi_parse_pat(demux_id, buffer, sctlen);
-	}	
-
+	}
+	
 	if(filtertype == TYPE_PMT)
 	{
 		cs_log_dump_dbg(D_DVBAPI, buffer, sctlen, "Demuxer %d Filter %d fetched CAPMT data (length = 0x%03X):", demux_id, filter_num + 1, sctlen);
 		dvbapi_parse_capmt(buffer, sctlen, demux[demux_id].socket_fd, demux[demux_id].pmt_file, 1, demux_id);
-	}		
+	} 	
 }
 
 static void *dvbapi_main_local(void *cli)
@@ -4711,7 +4769,6 @@
 			}
 		}
 	}
-	
 	memset(ca_fd, 0, sizeof(ca_fd));
 	memset(unassoc_fd, 0, sizeof(unassoc_fd));
 
@@ -4873,7 +4930,7 @@
 			{
 				gone = comp_timeb(&now, &demux[i].emmstart);	
 			
-				if(gone > 30*1000){
+				if(gone > 10*1000){ // megavolt change 30 to 10 
 					
 					if(do_emm_start) {
 						cs_ftime(&demux[i].emmstart); // trick to let emm fetching start after 30 seconds to speed up zapping
@@ -4881,7 +4938,7 @@
 					}
 				}
 				
-				if(gone > 10*1000){
+				if(gone > 3*1000){ // megavolt change 10 to 3 
 					if(do_sdt_start)
 					{
 						dvbapi_start_sdt_filter(i);
@@ -4901,7 +4958,7 @@
 				else
 				{
 					gone = comp_timeb(&now, &demux[i].emmstart);
-					if(gone > 30*1000)
+					if(gone > 10*1000) // megavolt change 30 to 10 
 					{
 						demux[i].emmstart = now;
 						dvbapi_start_emm_filter(i); // start emmfiltering delayed if filters already were running
@@ -5148,16 +5205,18 @@
 					}
 
 					//reading and completing data from socket
-					if (connfd > 0) {
+					if (connfd > 0)
+					{
 						uint32_t pmtlen = 0, chunks_processed = 0;
 
 						int8_t tries = 1;
-						do {
+						do
+						{
 							if(tries > 1)
 							{
 								cs_sleepms(50);
 							}
-							cs_log_dbg(D_TRACE, "%s to read from connection fd %d try %d", ((chunks_processed == 0 && pmtlen == 0) ? "Trying":"Continue"), connfd , tries);
+							 cs_log_dbg(D_TRACE, "%s to read from connection fd %d try %d", ((chunks_processed == 0 && pmtlen == 0) ? "Trying":"Continue"), connfd , tries);
 							len = cs_recv(connfd, mbuf + pmtlen, sizeof(mbuf) - pmtlen, MSG_DONTWAIT);
 							if (len > 0)
 							{
@@ -5168,7 +5227,6 @@
 								//client disconnects, stop all assigned decoding
 								cs_log_dbg(D_DVBAPI, "Socket %d reported connection close", connfd);
 								int active_conn = 0; //other active connections counter
-								
 								for (j = 0; j < MAX_DEMUX; j++)
 								{
 									if (demux[j].socket_fd == connfd)
@@ -5284,8 +5342,7 @@
 											uint16_t client_proto_ptr;
 											memcpy(&client_proto_ptr, &mbuf[4], 2);
 											uint16_t client_proto = ntohs(client_proto_ptr);
-											if (client_name)
-												free(client_name);
+											if (client_name) free(client_name);
 											if (cs_malloc(&client_name, data_len + 1))
 											{
 												memcpy(client_name, &mbuf[7], data_len);
@@ -5333,10 +5390,12 @@
 							}
 						}
 
-						if (pmtlen > 0 && connfd != -1) {
+						if (pmtlen > 0 && connfd != -1)
+						{
 							if (pmtlen < 3)
 								cs_log_dbg(D_DVBAPI, "CA PMT server message too short!");
-							else {
+							else
+							{
 								if (pmtlen >= sizeof(mbuf))
 									cs_log("***** WARNING: PMT BUFFER OVERFLOW, PLEASE REPORT! ****** ");
 								cs_log_dump_dbg(D_DVBAPI, mbuf, pmtlen, "New PMT info from socket (total size: %d)", pmtlen);
@@ -5473,7 +5532,6 @@
 							cs_log("ERROR: ioctl(CA_SET_DESCR): %s", strerror(errno));
 						}
 					}
-					
 					if(cfg.dvbapi_extended_cw_api == 1)
 					{
 						ca_descr_mode.index = usedidx;
@@ -5481,13 +5539,13 @@
 						ca_descr_mode.cipher_mode = cipher_mode;
 	
 						if(cfg.dvbapi_boxtype == BOXTYPE_PC || cfg.dvbapi_boxtype == BOXTYPE_PC_NODMX)
-							dvbapi_net_send(DVBAPI_CA_SET_DESCR_MODE, demux[demux_id].socket_fd, demux_id, -1 /*unused*/, (unsigned char *) &ca_descr_mode, NULL, NULL);
+								dvbapi_net_send(DVBAPI_CA_SET_DESCR_MODE, demux[demux_id].socket_fd, demux_id, -1 /*unused*/, (unsigned char *) &ca_descr_mode, NULL, NULL);
 						else
 						{
 							if(ca_fd[i] <= 0)
 							{
 								ca_fd[i] = dvbapi_open_device(1, i, demux[demux_id].adapter_index);
-								if(ca_fd[i] <= 0) { continue; } 
+								if(ca_fd[i] <= 0) { continue; }
 							}
 							if (dvbapi_ioctl(ca_fd[i], CA_SET_DESCR_MODE, &ca_descr_mode) < 0)
 							{
@@ -5614,15 +5672,14 @@
 				int32_t t, o, ecmcounter = 0;
 				int32_t oldpidindex = demux[i].pidindex;
 				demux[i].pidindex = j; // set current ecmpid as the new pid to descramble
-				if(oldpidindex != -1) 
+				if(oldpidindex != -1)
 				{
 					for(k = 0; k < MAX_STREAM_INDICES; k++)
-					{	
+					{   
 						demux[i].ECMpids[j].index[k] = demux[i].ECMpids[oldpidindex].index[k]; // swap index with lower status pid that was descrambling
 						demux[i].ECMpids[j].useMultipleIndices = demux[i].ECMpids[oldpidindex].useMultipleIndices;
 					}
 				}
-					
 				for(t = 0; t < demux[i].ECMpidcount; t++)  //check this pid with controlword FOUND for higher status:
 				{
 					if(t != j && demux[i].ECMpids[j].status >= demux[i].ECMpids[t].status)
@@ -5796,6 +5853,7 @@
 
 		delayer(er, delay);
 
+		if(er->caid>>8 != 0x0E)
 		switch(selected_api)
 		{
 #if defined(WITH_STAPI) || defined(WITH_STAPI5)
@@ -5815,56 +5873,55 @@
 						idx = demux[i].ECMpids[j].useMultipleIndices ? demux[i].ECMpids[j].index[k] : demux[i].ECMpids[j].index[0];
 						dvbapi_set_pid(i, k, idx, false, false); // disable streampid
 					}
-					
+			
 					for(k = 0; k < MAX_STREAM_INDICES; k++)
-					{	
+					{   
 						demux[i].ECMpids[j].index[k] = INDEX_INVALID;
-					}				
-				}
-				
+					}               
+				}         
 				if(er->cw_ex.mode == CW_MODE_MULTIPLE_CW)
 				{
 					int32_t key_pos_a = 0;
 					uint8_t *cw, stream_type;
-
+	
 					demux[i].ECMpids[j].useMultipleIndices = 1;
-					
+	
 					for(k = 0; k < demux[i].STREAMpidcount; k++)
 					{
 						stream_type = demux[i].STREAMpidsType[k];
-							
-						// Video
-						if(stream_type == 0x01 || stream_type == 0x02 || stream_type == 0x10 || stream_type == 0x1B 
-							|| stream_type == 0x24 || stream_type == 0x42 || stream_type == 0x80 || stream_type == 0xD1 
-							|| stream_type == 0xEA)
+	
+							// Video
+						if(stream_type == 0x01  || stream_type == 0x02 || stream_type == 0x10 || stream_type == 0x1B
+												|| stream_type == 0x24 || stream_type == 0x42 || stream_type == 0x80 || stream_type == 0xD1
+												|| stream_type == 0xEA)
 						{
 							cw = er->cw;
 						}
-						// Audio
-						else if(stream_type == 0x03 || stream_type == 0x04 || stream_type == 0x0F || stream_type == 0x11 
-							|| stream_type == 0x81 || (stream_type >= 0x83 && stream_type <= 0x87) || stream_type == 0x8A)
+							// Audio
+						else if(stream_type == 0x03 || stream_type == 0x04 || stream_type == 0x0F || stream_type == 0x11
+													|| stream_type == 0x81 || (stream_type >= 0x83 && stream_type <= 0x87) || stream_type == 0x8A)
 						{
 							cw = er->cw_ex.audio[key_pos_a];
 							
 							if(key_pos_a < 3)
 							{
-								key_pos_a++;	
+								key_pos_a++;   
 							}
-						}		
-						// Data	
+						}       
+							// Data
 						else
 						{
 							cw = er->cw_ex.data;
 						}
-						
+		
 						dvbapi_write_cw(i, cw, j, k, er->cw_ex.algo, er->cw_ex.algo_mode);
+						}
+					}
+					else
+					{
+						demux[i].ECMpids[j].useMultipleIndices = 0;
+						dvbapi_write_cw(i, er->cw, j, 0, er->cw_ex.algo, er->cw_ex.algo_mode);
 					}
-				}
-				else
-				{
-					demux[i].ECMpids[j].useMultipleIndices = 0;
-					dvbapi_write_cw(i, er->cw, j, 0, er->cw_ex.algo, er->cw_ex.algo_mode);
-				}
 #else
 				dvbapi_write_cw(i, er->cw, j, 0, CA_ALGO_DVBCSA, CA_MODE_ECB);
 #endif
@@ -6411,18 +6468,18 @@
 	if(pid == -1 || pid > demux[demux_index].ECMpidcount) return INDEX_INVALID;
 	
 	if(demux[demux_index].ECMpids[pid].useMultipleIndices)
-	{		
+	{       
 		n = stream_id;
 		idx = demux[demux_index].ECMpids[pid].index[n];
-		
+	
 		if(idx == INDEX_INVALID)   // if no indexer for this pid get one!
 		{
 			idx = dvbapi_get_descindex(demux_index);
 			demux[demux_index].ECMpids[pid].index[n] = idx;
 			cs_log_dbg(D_DVBAPI, "Demuxer %d PID: %d CAID: %04X ECMPID: %04X is using index %d for stream %d", demux_index, pid,
-					  demux[demux_index].ECMpids[pid].CAID, demux[demux_index].ECMpids[pid].ECM_PID, idx, n);
+			demux[demux_index].ECMpids[pid].CAID, demux[demux_index].ECMpids[pid].ECM_PID, idx, n);
 		}
-		
+	
 		if(!demux[demux_index].ECMpids[pid].streams || ((demux[demux_index].ECMpids[pid].streams & (1 << n)) == (uint) (1 << n)))
 		{
 			dvbapi_set_pid(demux_index, n, idx, true, use_des); // enable streampid
@@ -6431,17 +6488,17 @@
 		{
 			dvbapi_set_pid(demux_index, n, idx, false, false); // disable streampid
 		}
-	}	
+	}   
 	else
 	{
 		idx = demux[demux_index].ECMpids[pid].index[0];
-		
+	
 		if(idx == INDEX_INVALID)   // if no indexer for this pid get one!
 		{
 			idx = dvbapi_get_descindex(demux_index);
 			demux[demux_index].ECMpids[pid].index[0] = idx;
 			cs_log_dbg(D_DVBAPI, "Demuxer %d PID: %d CAID: %04X ECMPID: %04X is using index %d", demux_index, pid,
-						  demux[demux_index].ECMpids[pid].CAID, demux[demux_index].ECMpids[pid].ECM_PID, idx);
+								demux[demux_index].ECMpids[pid].CAID, demux[demux_index].ECMpids[pid].ECM_PID, idx);
 		}
 		
 		for(n = 0; n < demux[demux_index].STREAMpidcount; n++)
@@ -6453,8 +6510,8 @@
 			else
 			{
 				dvbapi_set_pid(demux_index, n, idx, false, false); // disable streampid
-			} 
-		}      
+			}
+		}     
 	}
 	
 	return idx; // return caindexer
@@ -6471,26 +6528,27 @@
 		itr = ll_iter_create(ll_activestreampids);
 		while((listitem = ll_iter_next(&itr)))
 		{
-			if (cadevice == listitem->cadevice && pid == listitem->streampid){
-				if((listitem->activeindexers & (1 << idx)) == (uint) (1 << idx)){
-					
+			if (cadevice == listitem->cadevice && pid == listitem->streampid)
+			{
+				if((listitem->activeindexers & (1 << idx)) == (uint) (1 << idx))
+				{
 					if(cfg.dvbapi_extended_cw_api == 2 && use_des != listitem->use_des)
 					{
 						listitem->use_des = use_des;
 						return FIRST_STREAMPID_INDEX;
 					}
-					
 					return FOUND_STREAMPID_INDEX; // match found
-				}else{
+				}
+				else
+				{
 					listitem->activeindexers|=(1 << idx); // ca + pid found but not this index -> add this index
 					cs_log_dbg(D_DVBAPI, "Added existing streampid %04X with new index %d to ca%d", pid, idx, cadevice);
-
+					
 					if(cfg.dvbapi_extended_cw_api == 2 && use_des != listitem->use_des)
 					{
 						listitem->use_des = use_des;
 						return FIRST_STREAMPID_INDEX;
 					}
-					
 					return ADDED_STREAMPID_INDEX;
 				}
 			}
@@ -6573,40 +6631,42 @@
 	if (ecmpid == -1) return; // no active ecmpid!
 	
 	int32_t j;
-
 	if(demux[demux_id].ECMpids[ecmpid].useMultipleIndices == 0)
 	{
 		ca_index_t idx = demux[demux_id].ECMpids[ecmpid].index[0];
 		int32_t i,n;
 		struct s_streampid *listitem;
-		// search for old enabled streampids on all ca devices that have to be disabled
+			// search for old enabled streampids on all ca devices that have to be disabled
 		for(i = 0; i < MAX_DEMUX && idx != INDEX_INVALID; i++)
 		{
 			if(!((demux[demux_id].ca_mask & (1 << i)) == (uint) (1 << i))) continue; // continue if ca is unused by this demuxer
-			
+	
 			LL_ITER itr;
 			itr = ll_iter_create(ll_activestreampids);
 			while((listitem = ll_iter_next(&itr)))
 			{
 				if (i != listitem->cadevice) continue; // ca doesnt match
 				if (!((listitem->activeindexers & (1 << (idx))) == (uint) (1 << (idx)))) continue; // index doesnt match
-				for(n = 0; n < demux[demux_id].STREAMpidcount; n++){
+				for(n = 0; n < demux[demux_id].STREAMpidcount; n++)
+				{
 					if(demux[demux_id].ECMpidcount == 0) // FTA? -> disable stream!
 					{
-						n = demux[demux_id].STREAMpidcount;
+						n = demux[demux_id].STREAMpidcount; 
 						break;
 					}
-					if (listitem->streampid == demux[demux_id].STREAMpids[n]){ // check if pid matches with current streampid on demuxer
+					if (listitem->streampid == demux[demux_id].STREAMpids[n])
+					{ // check if pid matches with current streampid on demuxer
 						break;
 					}
 				}
-				if (n == demux[demux_id].STREAMpidcount){
+				if (n == demux[demux_id].STREAMpidcount)
+				{
 					demux[demux_id].STREAMpids[n] = listitem->streampid; // put it temp here!
 					dvbapi_set_pid(demux_id, n, idx, false, false); // no match found so disable this now unused streampid
 					demux[demux_id].STREAMpids[n] = 0; // remove temp!
 				}
 			}
-			
+	
 			for(n = 0; n < demux[demux_id].STREAMpidcount && demux[demux_id].ECMpidcount != 0; n++) // ECMpidcount != 0 -> skip enabling on fta
 			{
 				ll_iter_reset(&itr);
@@ -6617,7 +6677,7 @@
 						if (i != listitem->cadevice) continue; // ca doesnt match
 						if (!((listitem->activeindexers & (1 << (idx))) == (uint) (1 << (idx)))) continue; // index doesnt match
 						if (listitem->streampid == demux[demux_id].STREAMpids[n]) // check if pid matches with current streampid on demuxer
-						{ 
+						{
 							break;
 						}
 					}
@@ -6639,38 +6699,42 @@
 		for(i = 0; i < MAX_DEMUX && idx != INDEX_INVALID; i++)
 		{
 			if(!((demux[demux_id].ca_mask & (1 << i)) == (uint) (1 << i))) continue; // continue if ca is unused by this demuxer
-			
+	
 			LL_ITER itr;
 			itr = ll_iter_create(ll_activestreampids);
 			while((listitem = ll_iter_next(&itr)))
 			{
 				if (i != listitem->cadevice) continue; // ca doesnt match
-				
+	
 				for(skip = 1, j = 0; j < MAX_STREAM_INDICES; j++)
 				{
 					idx = demux[demux_id].ECMpids[ecmpid].index[j];
 					if(idx == INDEX_INVALID) continue;
-					
+	
 					if ((listitem->activeindexers & (1 << (idx))) == (uint) (1 << (idx)))
 					{
 						skip = 0; // index match
 						break;
 					}
 				}
-				
+	
 				if(skip) continue;
-				
-				for(n = 0; n < demux[demux_id].STREAMpidcount; n++){
+	
+				for(n = 0; n < demux[demux_id].STREAMpidcount; n++)
+				{
 					if(demux[demux_id].ECMpidcount == 0) // FTA? -> disable stream!
 					{
 						n = demux[demux_id].STREAMpidcount;
 						break;
 					}
-					if (listitem->streampid == demux[demux_id].STREAMpids[n]){ // check if pid matches with current streampid on demuxer
+				
+					if (listitem->streampid == demux[demux_id].STREAMpids[n]) // check if pid matches with current streampid on demuxer
+					{
 						break;
-					}
+					}	
 				}
-				if (n == demux[demux_id].STREAMpidcount){
+				if (n == demux[demux_id].STREAMpidcount)
+				{
 					demux[demux_id].STREAMpids[n] = listitem->streampid; // put it temp here!
 					dvbapi_set_pid(demux_id, n, idx, false, false); // no match found so disable this now unused streampid
 					demux[demux_id].STREAMpids[n] = 0; // remove temp!
@@ -6685,23 +6749,23 @@
 					while((listitem = ll_iter_next(&itr)))
 					{
 						if (i != listitem->cadevice) continue; // ca doesnt match
-						
+			
 						for(skip = 1, j = 0; j < MAX_STREAM_INDICES; j++)
 						{
 							idx = demux[demux_id].ECMpids[ecmpid].index[j];
 							if(idx == INDEX_INVALID) continue;
-							
-							if ((listitem->activeindexers & (1 << (idx))) == (uint) (1 << (idx)))
-							{
-								skip = 0; // index match
-								break;
-							}
+	
+								if ((listitem->activeindexers & (1 << (idx))) == (uint) (1 << (idx)))
+								{
+									skip = 0; // index match
+									break;
+								}
 						}
-						
+			
 						if(skip) continue;
 					
 						if (listitem->streampid == demux[demux_id].STREAMpids[n]) // check if pid matches with current streampid on demuxer
-						{ 
+						{
 							break;
 						}
 					}
@@ -6711,11 +6775,10 @@
 					}
 				}
 			}
-		}		
+		}
 	}
 }
 
-
 ca_index_t is_ca_used(uint8_t cadevice, int32_t pid)
 {
 	if(!ll_activestreampids) return INDEX_NOTFOUND;
diff -ruN oscam-emu-2015-12-03-11142.orig/module-dvbapi.h oscam-emu-2015-12-03-11142/module-dvbapi.h
--- oscam-emu-2015-12-03-11142.orig/module-dvbapi.h	2015-12-12 00:38:27.894433427 +0300
+++ oscam-emu-2015-12-03-11142/module-dvbapi.h	2015-12-04 00:43:30.000000000 +0300
@@ -31,7 +31,7 @@
 #define ECM_PIDS 30
 #define MAX_FILTER 32
 
-#ifdef WITH_EXTENDED_CW	
+#ifdef WITH_EXTENDED_CW
 #define MAX_STREAM_INDICES 32
 #else
 #define MAX_STREAM_INDICES 1
@@ -118,9 +118,11 @@
 	int8_t status;
 	uint8_t tries;
 	unsigned char table;
+	int16_t pvu_counter;
 	ca_index_t index[MAX_STREAM_INDICES];
 	int8_t useMultipleIndices;
 	uint32_t streams;
+	uint32_t privdata; // dre private data megavolt
 };
 
 typedef struct filter_s
@@ -151,6 +153,7 @@
 	uint32_t PROVID;
 	uint16_t PID;
 	uint8_t type;
+	uint32_t privdata; // dre private data megavolt
 };
 
 #define PTINUM 10
@@ -209,8 +212,8 @@
 	uint8_t		cadevice; // holds ca device
 	uint16_t 	streampid; // holds pids
 	uint32_t	activeindexers; // bitmask indexers if streampid enabled for index bit is set
-	ca_index_t	caindex; // holds index that is used to decode on ca device
-	bool		use_des;
+	ca_index_t  caindex; // holds index that is used to decode on ca device
+	bool        use_des;
 }STREAMPIDTYPE;
 
 struct s_dvbapi_priority
@@ -221,6 +224,7 @@
 	uint16_t srvid;
 	uint32_t chid;
 	uint16_t ecmpid;
+	uint32_t privdata;
 	uint16_t mapcaid;
 	uint32_t mapprovid;
 	uint16_t mapecmpid;
@@ -299,18 +303,21 @@
 	int32_t index;      /* -1 == disable*/
 } ca_pid_t;
 
-enum ca_descr_algo {
+enum ca_descr_algo
+{
 	CA_ALGO_DVBCSA,
 	CA_ALGO_DES,
 	CA_ALGO_AES128,
 };
- 
-enum ca_descr_cipher_mode {
+
+enum ca_descr_cipher_mode
+{
 	CA_MODE_ECB,
 	CA_MODE_CBC,
 };
 
-typedef struct ca_descr_mode {
+typedef struct ca_descr_mode
+{
 	uint32_t index;
 	enum ca_descr_algo algo;
 	enum ca_descr_cipher_mode cipher_mode;
diff -ruN oscam-emu-2015-12-03-11142.orig/module-dvbapi-stapi.c oscam-emu-2015-12-03-11142/module-dvbapi-stapi.c
--- oscam-emu-2015-12-03-11142.orig/module-dvbapi-stapi.c	2015-11-06 02:48:40.000000000 +0300
+++ oscam-emu-2015-12-03-11142/module-dvbapi-stapi.c	2015-12-04 00:43:30.000000000 +0300
@@ -656,7 +656,7 @@
 {
 	int32_t n;
 
-	if(idx == INDEX_STAPI_DISABLE)
+	if(idx == (ca_index_t) INDEX_STAPI_DISABLE)
 	{
 		for(n = 0; n < PTINUM; n++)
 		{
diff -ruN oscam-emu-2015-12-03-11142.orig/module-dvbapi-stapi.h oscam-emu-2015-12-03-11142/module-dvbapi-stapi.h
--- oscam-emu-2015-12-03-11142.orig/module-dvbapi-stapi.h	2015-11-06 02:48:40.000000000 +0300
+++ oscam-emu-2015-12-03-11142/module-dvbapi-stapi.h	2015-12-04 00:43:30.000000000 +0300
@@ -4,7 +4,7 @@
 int32_t stapi_open(void);
 int32_t stapi_set_filter(int32_t demux_id, uint16_t pid, uchar *filter, uchar *mask, int32_t num, char *pmtfile);
 int32_t stapi_remove_filter(int32_t demux_id, int32_t num, char *pmtfile);
-int32_t stapi_set_pid(int32_t demux_id, int32_t num, uint32_t idx, uint16_t pid, char *pmtfile);
+int32_t stapi_set_pid(int32_t demux_id, int32_t num, ca_index_t idx, uint16_t pid, char *pmtfile);
 int32_t stapi_write_cw(int32_t demux_id, uchar *cw, uint16_t *, int32_t, char *pmtfile);
 int32_t stapi_activate_section_filter(int32_t fd, uchar *filter, uchar *mask);
 
diff -ruN oscam-emu-2015-12-03-11142.orig/module-emulator.c oscam-emu-2015-12-03-11142/module-emulator.c
--- oscam-emu-2015-12-03-11142.orig/module-emulator.c	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/module-emulator.c	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,724 @@
+#include "globals.h"
+#include "oscam-string.h"
+#include "oscam-config.h"
+#include "oscam-conf-chk.h"
+#include "oscam-time.h"
+#include "module-emulator-osemu.h"
+#include "module-emulator-stream.h"
+
+// oscam virtual emu card reader
+#define CS_OK      1
+#define CS_ERROR   0
+
+static int32_t emu_do_ecm(struct s_reader *rdr, const struct ecm_request_t *er, struct s_ecm_answer *ea)
+{
+	if (!ProcessECM(rdr, er->ecmlen, er->caid, er->prid, er->ecm, ea->cw, er->srvid, er->pid)) {
+		return CS_OK;
+	}
+
+	return CS_ERROR;
+}
+
+static void refresh_entitlements(struct s_reader *reader);
+
+static int32_t emu_do_emm(struct s_reader *rdr, struct emm_packet_t *emm)
+{
+	uint32_t keysAdded = 0;
+
+	if(emm->emmlen < 3) {
+		return CS_ERROR;
+	}
+
+	if(SCT_LEN(emm->emm) > emm->emmlen) {
+		return CS_ERROR;
+	}
+
+	if(!ProcessEMM(rdr, b2i(2, emm->caid), b2i(4, emm->provid), emm->emm, &keysAdded)) {		
+		if(keysAdded > 0) { refresh_entitlements(rdr); }
+		return CS_OK;
+	}
+
+	return CS_ERROR;
+}
+
+static int32_t EMU_Init(struct s_reader *reader);
+
+static int32_t emu_card_info(struct s_reader *rdr) {
+	EMU_Init(rdr);
+	return CS_OK;
+}
+
+static int32_t emu_card_init(struct s_reader *UNUSED(rdr), struct s_ATR *UNUSED(atr))
+{return CS_ERROR;}
+
+static int32_t emu_get_emm_filter(struct s_reader *UNUSED(rdr), struct s_csystem_emm_filter **UNUSED(emm_filters), unsigned int *UNUSED(filter_count))
+{return CS_ERROR;}
+
+
+int32_t emu_get_via3_emm_type(EMM_PACKET *ep, struct s_reader *rdr)
+{
+	uint32_t provid = 0;
+
+	if(ep->emm[3] == 0x90 && ep->emm[4] == 0x03)
+	{
+		provid = b2i(3, ep->emm+5);
+		provid &=0xFFFFF0; 
+		i2b_buf(4, provid, ep->provid);
+	}
+
+	switch(ep->emm[0])
+	{
+	case 0x88:
+		ep->type = UNIQUE;
+		memset(ep->hexserial, 0, 8);
+		memcpy(ep->hexserial, ep->emm + 4, 4);
+		rdr_log_dbg(rdr, D_EMM, "UNIQUE");
+		return 1;
+
+	case 0x8A:
+	case 0x8B:
+		ep->type = GLOBAL;
+		rdr_log_dbg(rdr, D_EMM, "GLOBAL");
+		return 1;
+
+	case 0x8C:
+	case 0x8D:
+		ep->type = SHARED;
+		rdr_log_dbg(rdr, D_EMM, "SHARED (part)");
+		// We need those packets to pass otherwise we would never
+		// be able to complete EMM reassembly
+		return 1;
+
+	case 0x8E:
+		ep->type = SHARED;
+		rdr_log_dbg(rdr, D_EMM, "SHARED");
+		memset(ep->hexserial, 0, 8);
+		memcpy(ep->hexserial, ep->emm + 3, 3);
+		return 1;
+
+	default:
+		ep->type = UNKNOWN;
+		rdr_log_dbg(rdr, D_EMM, "UNKNOWN");
+		return 1;
+	}
+}
+
+int32_t emu_get_ird2_emm_type(EMM_PACKET *ep, struct s_reader *rdr)
+{
+	int32_t l = (ep->emm[3] & 0x07);
+	int32_t base = (ep->emm[3] >> 3);
+	char dumprdrserial[l * 3], dumpemmserial[l * 3];
+
+	switch(l)
+	{
+
+	case 0:
+		// global emm, 0 bytes addressed
+		ep->type = GLOBAL;
+		rdr_log_dbg(rdr, D_EMM, "GLOBAL base = %02x", base);
+		return 1;
+
+	case 2:
+		// shared emm, 2 bytes addressed
+		ep->type = SHARED;
+		memset(ep->hexserial, 0, 8);
+		memcpy(ep->hexserial, ep->emm + 4, l);
+		cs_hexdump(1, rdr->hexserial, l, dumprdrserial, sizeof(dumprdrserial));
+		cs_hexdump(1, ep->hexserial, l, dumpemmserial, sizeof(dumpemmserial));
+		rdr_log_dbg_sensitive(rdr, D_EMM, "SHARED l = %d ep = {%s} rdr = {%s} base = %02x", l,
+								 dumpemmserial, dumprdrserial, base);
+		return 1;
+
+	case 3:
+		// unique emm, 3 bytes addressed
+		ep->type = UNIQUE;
+		memset(ep->hexserial, 0, 8);
+		memcpy(ep->hexserial, ep->emm + 4, l);
+		cs_hexdump(1, rdr->hexserial, l, dumprdrserial, sizeof(dumprdrserial));
+		cs_hexdump(1, ep->hexserial, l, dumpemmserial, sizeof(dumpemmserial));
+		rdr_log_dbg_sensitive(rdr, D_EMM, "UNIQUE l = %d ep = {%s} rdr = {%s} base = %02x", l,
+								 dumpemmserial, dumprdrserial, base);
+		return 1;
+
+	default:
+		ep->type = UNKNOWN;
+		rdr_log_dbg(rdr, D_EMM, "UNKNOWN");
+		return 1;
+	}
+}
+
+int32_t emu_get_pvu_emm_type(EMM_PACKET *ep, struct s_reader *rdr)
+{
+	if(ep->emm[0] == 0x82)
+	{
+		ep->type = UNIQUE;
+		memset(ep->hexserial, 0, 8);
+		memcpy(ep->hexserial, ep->emm + 12, 4);
+	}
+	else
+	{
+		ep->type = UNKNOWN;
+		rdr_log_dbg(rdr, D_EMM, "UNKNOWN");
+	}
+	return 1;	
+}
+
+int32_t emu_get_dre2_emm_type(EMM_PACKET *ep, struct s_reader *rdr)
+{
+	if(ep->emm[0] == 0x91)
+	{
+		ep->type = GLOBAL;
+		rdr_log_dbg(rdr, D_EMM, "GLOBAL");
+		return 1;				
+	}
+	else
+	{
+		switch(ep->emm[0])
+		{
+		/*case 0x87:
+			ep->type = UNIQUE;
+			return 1; //FIXME: no filling of ep->hexserial
+    	
+		case 0x83:
+		case 0x89:
+			ep->type = SHARED;
+			// FIXME: Seems to be that SA is only used with caid 0x4ae1
+			if(rdr->caid == 0x4ae1)
+			{
+				memset(ep->hexserial, 0, 8);
+				memcpy(ep->hexserial, ep->emm + 3, 4);
+				return 1;
+			}
+			else
+			{ 
+				return 1; 
+			}
+    	
+		case 0x80:
+		case 0x82:*/
+		case 0x86:
+		/*case 0x8c:*/
+			ep->type = SHARED;
+			memset(ep->hexserial, 0, 8);
+			ep->hexserial[0] = ep->emm[3];
+			return 1;;
+    	
+		default:
+			ep->type = UNKNOWN;
+			return 1;
+		}
+	}
+}
+
+static int32_t emu_get_emm_type(struct emm_packet_t *ep, struct s_reader *rdr)
+{
+	switch(b2i(2, ep->caid)>>8)
+	{
+		case 0x05:
+			return emu_get_via3_emm_type(ep, rdr);
+
+		case 0x06:
+			return emu_get_ird2_emm_type(ep, rdr);
+			
+		case 0x0E:
+			return emu_get_pvu_emm_type(ep, rdr);
+	
+		case 0x4A:
+			return emu_get_dre2_emm_type(ep, rdr);
+												
+		default:
+			break;
+	}
+	
+	return CS_ERROR;
+}
+
+static int32_t emu_get_via3_emm_filter(struct s_reader *UNUSED(rdr), struct s_csystem_emm_filter **emm_filters, unsigned int *filter_count, uint16_t UNUSED(caid), uint32_t UNUSED(provid))
+{
+	if(*emm_filters == NULL)
+	{
+		const unsigned int max_filter_count = 1;
+		
+		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
+			{ return CS_ERROR; }
+
+		struct s_csystem_emm_filter *filters = *emm_filters;
+		*filter_count = 0;
+
+		int32_t idx = 0;
+
+		filters[idx].type = EMM_GLOBAL;
+		filters[idx].enabled   = 1;
+		filters[idx].filter[0] = 0x8A;
+		filters[idx].mask[0]   = 0xFE;
+		filters[idx].filter[3] = 0x80; 
+		filters[idx].mask[3]   = 0x80;
+		idx++;
+
+		*filter_count = idx;
+	}	
+	
+	return CS_OK;
+}
+
+static int32_t emu_get_ird2_emm_filter(struct s_reader* rdr, struct s_csystem_emm_filter **emm_filters, unsigned int *filter_count, uint16_t caid, uint32_t UNUSED(provid))
+{
+	uint8_t hexserial[3], prid[4];
+	FILTER* emu_provids;
+	int8_t have_provid = 0, have_serial = 0;
+	int32_t i;
+	
+	if(GetIrdeto2Hexserial(caid, hexserial))
+		{ have_serial = 1; }
+
+	emu_provids = get_emu_prids_for_caid(rdr, caid);
+	if(emu_provids != NULL && emu_provids->nprids > 0)
+		{ have_provid = 1;}		
+
+	if(*emm_filters == NULL)
+	{
+		const unsigned int max_filter_count = have_serial + (2*(have_provid ? emu_provids->nprids : 0));
+		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
+			{ return CS_ERROR; }
+
+		struct s_csystem_emm_filter *filters = *emm_filters;
+		*filter_count = 0;
+
+		unsigned int idx = 0;
+
+		if(have_serial)
+		{
+			filters[idx].type = EMM_UNIQUE;
+			filters[idx].enabled   = 1;
+			filters[idx].filter[0] = 0x82;
+			filters[idx].mask[0]   = 0xFF;
+			filters[idx].filter[1] = 0xFB;
+			filters[idx].mask[1]   = 0x07;
+			memcpy(&filters[idx].filter[2], hexserial, 3);
+			memset(&filters[idx].mask[2], 0xFF, 3);
+			idx++;
+		}
+		
+		for(i=0; have_provid && i<emu_provids->nprids; i++)
+		{
+			i2b_buf(4, emu_provids->prids[i], prid);
+			
+			filters[idx].type = EMM_UNIQUE;
+			filters[idx].enabled   = 1;
+			filters[idx].filter[0] = 0x82;
+			filters[idx].mask[0]   = 0xFF;
+			filters[idx].filter[1] = 0xFB;
+			filters[idx].mask[1]   = 0x07;
+			memcpy(&filters[idx].filter[2], &prid[1], 3);
+			memset(&filters[idx].mask[2], 0xFF, 3);
+			idx++;
+        	
+			filters[idx].type = EMM_SHARED;
+			filters[idx].enabled   = 1;
+			filters[idx].filter[0] = 0x82;
+			filters[idx].mask[0]   = 0xFF;
+			filters[idx].filter[1] = 0xFA;
+			filters[idx].mask[1]   = 0x07;
+			memcpy(&filters[idx].filter[2], &prid[1], 2);
+			memset(&filters[idx].mask[2], 0xFF, 2);
+			idx++;
+		}
+
+		*filter_count = idx;
+	}
+
+	return CS_OK;
+}
+
+static int32_t emu_get_pvu_emm_filter(struct s_reader *UNUSED(rdr), struct s_csystem_emm_filter **emm_filters, unsigned int *filter_count, uint16_t UNUSED(caid), uint32_t UNUSED(provid))
+{
+	uint8_t hexserials[8][4];
+	int32_t i, count = 0;
+	
+	if(!GetPowervuHexserials(0xFFFF, hexserials, 8, &count))
+		{ return CS_ERROR; }
+	
+	if(*emm_filters == NULL)
+	{
+		const unsigned int max_filter_count = count;
+		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
+			{ return CS_ERROR; }
+
+		struct s_csystem_emm_filter *filters = *emm_filters;
+		*filter_count = 0;
+
+		int32_t idx = 0;
+
+		for(i=0; i<count; i++)
+		{
+			filters[idx].type = EMM_UNIQUE;
+			filters[idx].enabled   = 1;
+			filters[idx].filter[0] = 0x82;
+			filters[idx].filter[10] = hexserials[i][0];
+			filters[idx].filter[11] = hexserials[i][1];
+			filters[idx].filter[12] = hexserials[i][2];
+			filters[idx].filter[13] = hexserials[i][3];
+			filters[idx].mask[0]   = 0xFF;
+			filters[idx].mask[10]  = 0xFF;
+			filters[idx].mask[11]  = 0xFF;
+			filters[idx].mask[12]  = 0xFF;
+			filters[idx].mask[13]  = 0xFF;
+			idx++;
+		}
+
+		*filter_count = idx;
+	}
+
+	return CS_OK;
+}
+
+static int32_t emu_get_dre2_emm_filter(struct s_reader *UNUSED(rdr), struct s_csystem_emm_filter **emm_filters, unsigned int *filter_count, uint16_t caid, uint32_t UNUSED(provid))
+{
+	uint8_t hexserials[8];
+	int32_t i, count = 0;
+	
+	if(!GetDrecryptHexserials(caid, hexserials, 8, &count))
+		{ count = 0; }
+	
+	if(*emm_filters == NULL)
+	{
+		const unsigned int max_filter_count = 1 + count;
+		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
+			{ return CS_ERROR; }
+
+		struct s_csystem_emm_filter *filters = *emm_filters;
+		*filter_count = 0;
+
+		int32_t idx = 0;
+
+		filters[idx].type = EMM_GLOBAL;
+		filters[idx].enabled   = 1;
+		filters[idx].filter[0] = 0x91;
+		filters[idx].mask[0]   = 0xFF;
+		idx++;
+
+		for(i=0; i<count; i++)
+		{
+			filters[idx].type = EMM_SHARED;
+			filters[idx].enabled   = 1;
+			filters[idx].filter[0] = 0x86;
+			filters[idx].filter[1] = hexserials[i];
+			filters[idx].mask[0]   = 0xFF;
+			filters[idx].mask[1]   = 0xFF;
+			idx++;
+		}
+
+		*filter_count = idx;
+	}
+
+	return CS_OK;
+}
+
+static int32_t emu_get_emm_filter_adv(struct s_reader *rdr, struct s_csystem_emm_filter **emm_filters, unsigned int *filter_count, uint16_t caid, uint32_t provid)
+{
+	switch(caid>>8)
+	{
+		case 0x05:
+			return emu_get_via3_emm_filter(rdr, emm_filters, filter_count, caid, provid);
+
+		case 0x06:
+			return emu_get_ird2_emm_filter(rdr, emm_filters, filter_count, caid, provid);
+			
+		case 0x0E:
+			return emu_get_pvu_emm_filter(rdr, emm_filters, filter_count, caid, provid);
+			
+		case 0x4A:
+			return emu_get_dre2_emm_filter(rdr, emm_filters, filter_count, caid, provid);
+												
+		default:
+			break;
+	}
+	
+	return CS_ERROR;
+}
+
+const struct s_cardsystem reader_emu =
+{
+	.desc = "emu",
+	.caids = (uint16_t[]){ 0x0D, 0x09, 0x0500, 0x18, 0x06, 0x26, 0xFFFF, 0x0E, 0x4A, 0 },
+	.do_ecm = emu_do_ecm,
+	.do_emm = emu_do_emm,
+	.card_info = emu_card_info,
+	.card_init = emu_card_init,
+	.get_emm_type = emu_get_emm_type,
+	.get_emm_filter = emu_get_emm_filter, //needed to pass checks
+	.get_emm_filter_adv = emu_get_emm_filter_adv,
+};
+
+
+#define CR_OK 0
+#define CR_ERROR 1
+
+static void emu_add_entitlement(struct s_reader *rdr, uint16_t caid, uint32_t provid, uint8_t *key, char *keyName, uint32_t keyLength, uint8_t isData)
+{
+	if(!rdr->ll_entitlements) { rdr->ll_entitlements = ll_create("ll_entitlements"); }
+
+	S_ENTITLEMENT *item;
+	if(cs_malloc(&item, sizeof(S_ENTITLEMENT)))
+	{
+
+		// fill item
+		item->caid = caid;
+		item->provid = provid;
+		item->id = 0;
+		item->class = 0;
+		item->start = 0;
+		item->end = 2147472000;
+		item->type = 0;
+		item->isKey = 1;
+		memcpy(item->name, keyName, 8);
+		item->key = key;
+		item->keyLength = keyLength;
+		item->isData = isData;
+
+		//add item
+		ll_append(rdr->ll_entitlements, item);
+	}
+}
+
+static uint8_t oneByte = 0x01;
+
+static void refresh_entitlements(struct s_reader *reader)
+{
+	uint32_t i;
+	KeyData *tmpKeyData;
+
+	if(reader->ll_entitlements)
+	{ ll_clear_data(reader->ll_entitlements); }
+
+	for(i=0; i<CwKeys.keyCount; i++)
+		emu_add_entitlement(reader, CwKeys.EmuKeys[i].provider>>8, CwKeys.EmuKeys[i].provider&0xFF,
+							CwKeys.EmuKeys[i].key, CwKeys.EmuKeys[i].keyName, CwKeys.EmuKeys[i].keyLength, 0);
+
+	for(i=0; i<ViKeys.keyCount; i++)
+		emu_add_entitlement(reader, 0x500, ViKeys.EmuKeys[i].provider, ViKeys.EmuKeys[i].key, ViKeys.EmuKeys[i].keyName,
+							ViKeys.EmuKeys[i].keyLength, 0);
+
+	for(i=0; i<NagraKeys.keyCount; i++)
+		emu_add_entitlement(reader, 0x1801, NagraKeys.EmuKeys[i].provider, NagraKeys.EmuKeys[i].key, NagraKeys.EmuKeys[i].keyName,
+							NagraKeys.EmuKeys[i].keyLength, 0);
+
+	for(i=0; i<IrdetoKeys.keyCount; i++) {
+		tmpKeyData = &IrdetoKeys.EmuKeys[i];
+		do {
+			emu_add_entitlement(reader, tmpKeyData->provider>>8, tmpKeyData->provider&0xFF, tmpKeyData->key, tmpKeyData->keyName, tmpKeyData->keyLength, 0);
+			tmpKeyData = (KeyData*)tmpKeyData->nextKey;
+		}
+		while(tmpKeyData!= NULL);
+	}
+
+	for(i=0; i<NDSKeys.keyCount; i++)
+	{ emu_add_entitlement(reader, NDSKeys.EmuKeys[i].provider, 0, NDSKeys.EmuKeys[i].key, NDSKeys.EmuKeys[i].keyName, NDSKeys.EmuKeys[i].keyLength, 0); }
+
+	emu_add_entitlement(reader, 0x090F, 0, viasat_const, "00", 64, 1);
+	emu_add_entitlement(reader, 0x093E, 0, viasat_const, "00", 64, 1);
+
+	for(i=0; i<BissKeys.keyCount; i++)
+	{ emu_add_entitlement(reader, 0x2600, BissKeys.EmuKeys[i].provider, BissKeys.EmuKeys[i].key, BissKeys.EmuKeys[i].keyName, BissKeys.EmuKeys[i].keyLength, 0); }
+
+	emu_add_entitlement(reader, 0xFFFF, 0, &oneByte, "00", 1, 1);
+	
+	for(i=0; i<PowervuKeys.keyCount; i++)
+		emu_add_entitlement(reader, 0x0E00, PowervuKeys.EmuKeys[i].provider, PowervuKeys.EmuKeys[i].key, PowervuKeys.EmuKeys[i].keyName,
+							PowervuKeys.EmuKeys[i].keyLength, 0);
+							
+	for(i=0; i<DreKeys.keyCount; i++)
+		emu_add_entitlement(reader, 0x4AE1, DreKeys.EmuKeys[i].provider, DreKeys.EmuKeys[i].key, DreKeys.EmuKeys[i].keyName,
+							DreKeys.EmuKeys[i].keyLength, 0);
+}
+
+extern char cs_confdir[128];
+
+static void set_hexserial_to_version(struct s_reader *rdr)
+{
+	char cVersion[32];
+	
+	uint32_t version = GetOSemuVersion();
+	uint8_t hversion[2];
+	memset(hversion, 0, 2);
+	snprintf(cVersion, sizeof(cVersion), "%04d", version);
+	CharToBin(hversion, cVersion, 4);
+	rdr->hexserial[3] = hversion[0];
+	rdr->hexserial[4] = hversion[1];	
+}
+
+static void set_prids(struct s_reader *rdr)
+{
+	int32_t i, j;
+
+	rdr->nprov = 0;
+	
+	for(i = 0; (i < rdr->emu_auproviders.nfilts) && (rdr->nprov < CS_MAXPROV); i++)
+	{
+		for(j = 0; (j < rdr->emu_auproviders.filts[i].nprids) && (rdr->nprov < CS_MAXPROV); j++)
+		{
+			i2b_buf(4, rdr->emu_auproviders.filts[i].prids[j], rdr->prid[i]);
+			rdr->nprov++;
+		}
+	}
+}
+
+FILTER* get_emu_prids_for_caid(struct s_reader *rdr, uint16_t caid)
+{
+	int32_t i;
+	
+	for(i = 0; i < rdr->emu_auproviders.nfilts; i++)
+	{
+		if(caid == rdr->emu_auproviders.filts[i].caid)
+		{
+			return &rdr->emu_auproviders.filts[i];
+		}
+	}
+	
+	return NULL;
+}
+
+static int32_t EMU_Init(struct s_reader *reader)
+{
+	if(stream_server_thread_init == 0)
+	{
+		stream_server_thread_init = 1;
+		
+		SAFE_MUTEX_INIT(&emu_fixed_key_data_mutex, NULL);
+		
+		memset(&emu_fixed_key_data, 0, sizeof(emu_stream_client_data));
+		
+		ll_emu_stream_delayed_keys = ll_create("ll_emu_stream_delayed_keys");
+		
+		emu_stream_source_port = cfg.emu_stream_source_port;
+		emu_stream_relay_port = cfg.emu_stream_relay_port;
+
+		start_thread("stream_server", stream_server, NULL, NULL, 1, 1);
+		start_thread("stream_key_delayer", stream_key_delayer, NULL, NULL, 1, 1);
+	}
+	
+	set_hexserial_to_version(reader);
+	
+#if !defined(__APPLE__) && !defined(__ANDROID__)
+	read_emu_keymemory();
+#endif
+
+	set_emu_extee(reader);
+	
+	set_emu_keyfile_path(cs_confdir);
+
+	if(!read_emu_keyfile(cs_confdir))
+	{
+		if(read_emu_keyfile("/var/keys/"))
+		{
+			set_emu_keyfile_path("/var/keys/");
+		}
+	}
+
+	refresh_entitlements(reader);
+
+	set_prids(reader);
+	
+	return CR_OK;
+}
+
+static int32_t EMU_GetStatus(struct s_reader *UNUSED(reader), int32_t *in) { *in = 1; return CR_OK; }
+static int32_t EMU_Activate(struct s_reader *UNUSED(reader), struct s_ATR *UNUSED(atr)) { return CR_OK; }
+static int32_t EMU_Transmit(struct s_reader *UNUSED(reader), uint8_t *UNUSED(buffer), uint32_t UNUSED(size),
+							uint32_t UNUSED(expectedlen), uint32_t UNUSED(delay), uint32_t UNUSED(timeout)) { return CR_OK; }
+static int32_t EMU_Receive(struct s_reader *UNUSED(reader), uint8_t *UNUSED(buffer), uint32_t UNUSED(size),
+						   uint32_t UNUSED(delay), uint32_t UNUSED(timeout)) { return CR_OK; }
+static int32_t EMU_Close(struct s_reader *UNUSED(reader)) { return CR_OK; }
+static int32_t EMU_write_settings(struct s_reader *UNUSED(reader), struct s_cardreader_settings *UNUSED(s)) { return CR_OK; }
+static int32_t EMU_card_write(struct s_reader *UNUSED(pcsc_reader),const uchar *UNUSED(buf) ,uint8_t *UNUSED(cta_res),
+							  uint16_t *UNUSED(cta_lr),int32_t UNUSED(l)) { return CR_OK; }
+static int32_t EMU_set_protocol(struct s_reader *UNUSED(rdr),uint8_t *UNUSED(params),uint32_t *UNUSED(length),
+								uint32_t UNUSED(len_request)) { return CR_OK; }
+
+const struct s_cardreader cardreader_emu =
+{
+	.desc           = "emu",
+	.typ            = R_EMU,
+	.skip_extra_atr_parsing = 1,
+	.reader_init    = EMU_Init,
+	.get_status     = EMU_GetStatus,
+	.activate       = EMU_Activate,
+	.transmit       = EMU_Transmit,
+	.receive        = EMU_Receive,
+	.close          = EMU_Close,
+	.write_settings = EMU_write_settings,
+	.card_write     = EMU_card_write,
+	.set_protocol   = EMU_set_protocol,
+};
+
+void add_emu_reader(void)
+{
+	LL_ITER itr;
+	struct s_reader *rdr;
+	int8_t haveEmuReader = 0;
+	char *emuName = "emulator";
+	char *ctab, *ftab, *emu_auproviders;
+
+	itr = ll_iter_create(configured_readers);
+	while((rdr = ll_iter_next(&itr)))
+	{
+		if(rdr->typ == R_EMU) {
+			haveEmuReader = 1;
+			break;
+		}
+	}
+
+	rdr = NULL;
+
+	if(!haveEmuReader) {
+		if(!cs_malloc(&rdr, sizeof(struct s_reader))) { return; }
+		reader_set_defaults(rdr);
+
+		rdr->enable = 1;
+		rdr->typ = R_EMU;
+		strncpy(rdr->label, emuName, strlen(emuName));
+		strncpy(rdr->device, emuName, strlen(emuName));
+
+		ctab = strdup("0D00,0D02,090F,0500,1801,0604,2600,FFFF,0E00,4AE1");
+		chk_caidtab(ctab, &rdr->ctab);
+		NULLFREE(ctab);
+
+		ftab = strdup(	"0D00:000000,000004,000010,000014,000020,0000C0,0000C4,0000C8,0000CC;"
+						"0D02:000000,00008C,0000A0,0000A4,0000A8;"
+						"090F:000000;"
+						"0500:000000,030B00,023800,021110,007400,007800;"
+						"1801:000000,007301,001101;"
+						"0604:000000;"
+						"2600:000000;"
+						"FFFF:000000;"
+						"0E00:000000;"
+						"4AE1:000011,0000FE;");
+		
+		chk_ftab(ftab, &rdr->ftab);
+		NULLFREE(ftab);
+
+		emu_auproviders = strdup("0500:030B00;0604:010200;0E00:000000;4AE1:000011,0000FE;");
+		chk_ftab(emu_auproviders, &rdr->emu_auproviders);
+		NULLFREE(emu_auproviders);
+
+		rdr->cachemm = 2;
+		rdr->rewritemm = 3;
+		rdr->logemm = 2;
+		rdr->deviceemm = 0;
+
+		rdr->grp = 0x1ULL;
+
+		rdr->crdr = &cardreader_emu;
+
+		reader_fixups_fn(rdr);
+		ll_append(configured_readers, rdr);
+	}
+
+#ifdef HAVE_DVBAPI
+	if(cfg.dvbapi_enabled && cfg.dvbapi_delayer < 60) {
+		cfg.dvbapi_delayer = 60;
+	}
+#endif
+
+	cs_log("[Emu] oscam-emu version %d", GetOSemuVersion());
+}
diff -ruN oscam-emu-2015-12-03-11142.orig/module-emulator-dre2overcrypt.c oscam-emu-2015-12-03-11142/module-emulator-dre2overcrypt.c
--- oscam-emu-2015-12-03-11142.orig/module-emulator-dre2overcrypt.c	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/module-emulator-dre2overcrypt.c	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,390 @@
+#include "globals.h"
+#include "oscam-string.h"
+#include "module-emulator-st20.h"
+#include "module-emulator-dre2overcrypt.h"
+#include "snippet.h"
+
+static uint16_t gId = 0xFFFF;
+static uint32_t decrypt_addr;
+static uint32_t gRawSec = 0;
+static uint8_t gVersion = 0xFF;
+
+typedef struct data_block_t
+{
+	uint8_t *data;
+	uint32_t size;
+	uint32_t used;
+} data_block;
+
+typedef struct memory_block_t
+{
+	uint8_t *pos;
+	uint8_t *end;
+} memory_block;
+
+static data_block raw_buffer = { NULL, 0, 0 };
+static data_block code_buffer = { NULL, 0, 0 };
+
+static int offtin(uint8_t *buf)
+{
+	int y;
+	y = buf[7] & 0x7F;
+	y = y * 256; y += buf[6];
+	y = y * 256; y += buf[5];
+	y = y * 256; y += buf[4];
+	y = y * 256; y += buf[3];
+	y = y * 256; y += buf[2];
+	y = y * 256; y += buf[1];
+	y = y * 256; y += buf[0];
+	if(buf[7] & 0x80) y =- y;
+	return y;
+}
+
+static int bspatch(uint8_t *dest, uint8_t *src, int src_len, uint8_t *patch)
+{
+	int i, newsize, bzctrllen, bzdatalen, oldpos, newpos, ctrl[3];
+	uint8_t *cstream, *dstream, *estream;
+
+	if(memcmp(patch, "BSDIFF40", 8)) return -1;
+
+	bzctrllen = offtin(patch + 8);
+	bzdatalen = offtin(patch + 16);
+	newsize = offtin(patch + 24);
+	if((bzctrllen < 0) || (bzdatalen < 0) || (newsize < 0)) return -1;
+
+	oldpos = 0;
+	newpos = 0;
+	cstream = patch + 32;
+	dstream = cstream + bzctrllen;
+	estream = dstream + bzdatalen;
+
+	while(newpos < newsize)
+	{
+			/* Read control data */
+		for(i = 0; i < 3; i++)
+		{
+			ctrl[i] = offtin(cstream);
+			cstream += 8;
+		}
+			/* Sanity-check */
+		if((newpos + ctrl[0]) > newsize) return -1;
+			/* Read diff string */
+		memcpy(dest + newpos, dstream, ctrl[0]);
+		dstream += ctrl[0];
+			/* Add old data to diff string */
+		for(i = 0; i < ctrl[0]; i++)
+		{
+			if(((oldpos + i) >= 0) && ((oldpos + i) < src_len)) dest[newpos + i] += src[oldpos + i];
+		}
+			/* Adjust pointers */
+		newpos += ctrl[0];
+		oldpos += ctrl[0];
+			/* Sanity-check */
+		if((newpos + ctrl[1]) > newsize) return -1;
+			/* Read extra string */
+		memcpy(dest + newpos, estream, ctrl[1]);
+		estream += ctrl[1];
+			/* Adjust pointers */
+		newpos += ctrl[1];
+		oldpos += ctrl[2];
+	}
+	return newsize;
+}
+
+static int dre_unpack(uint8_t *dest, uint8_t *src, int len)
+{
+	uint8_t dbuf[0x1000], mask;
+	int i, soffs, doffs, dbidx, boffs, n;
+
+	dbidx = 4078;
+	memset(dbuf, 32, 4078);
+	for(soffs = 0, doffs = 0; soffs < len; )
+	{
+		mask = src[soffs++];
+		for(i = 0; i < 8 && soffs < len; i++, mask >>= 1)
+		{
+			if(mask & 1)
+			{
+				dest[doffs++] = dbuf[dbidx] = src[soffs++];
+				dbidx = (dbidx + 1) & 0xfff;
+			}
+			else
+			{
+				boffs = src[soffs++];
+				n = src[soffs++];
+				boffs |= (n & 0xf0) << 4;
+				n &= 0xf;
+				n += 3;
+				while(n--)
+				{
+					boffs &= 0xfff;
+					dest[doffs++] = dbuf[dbidx] = dbuf[boffs++];
+					dbidx = (dbidx + 1) & 0xfff;
+				}
+			}
+		}
+	}
+	return doffs;
+}
+
+typedef struct 
+{
+	int magic_number;               /* magic number - value        .    */
+	int codesize;                   /* size of code in the rcu.         */
+	int entrypointoffset;           /* entrypoint offset into the code. */
+	int datasize;                   /* size of data region.             */
+	int datalocationoffset;         /* offset to place data at.         */
+	int bsssize;                    /* size of bss region.              */
+	int bsslocationoffset;          /* offset to place bss at.          */
+	int staticlinkoffset;           /* offset to staticlink in data.    */
+	int relsize;                    /* size of relocation table.        */
+	int conssize;                   /* size of constructor table.       */
+	int dessize;                    /* size of destructor table.        */
+	int stacksize;                  /* size of stack this rcu needs.    */
+	int heapsize;                   /* size of heap this rcu needs.     */
+	int dbgfilenamesize;            /* size of .dbg filename.           */
+	int slot0;                      /* 4 words space for user use.      */
+	int slot1;
+	int slot2;
+	int slot3;
+} rcu_header_t;
+
+static void rcu_load_offs(uint32_t *offs, uint8_t *buf, int size)
+{
+	uint32_t i;
+	for(i = 0; i < size / sizeof(int); i++)
+	{
+		offs[i] = (uint32_t)(buf[3 + i * 4] << 24) | (buf[2 + i * 4] << 16) | (buf[1 + i * 4] << 8) | buf[0 + i * 4];
+	}
+}
+
+static void rcu_load(uint8_t *rcu)
+{
+	int rcu_data_size;
+	uint32_t i;
+	uint32_t nexports, nimports;
+	rcu_header_t rcuh;
+	uint8_t *ptr, *rcu_code, *rcu_data;
+
+	rcu_load_offs((uint32_t *)&rcuh, rcu, sizeof(rcu_header_t));
+	ptr = rcu + sizeof(rcu_header_t);
+	rcu_code = ptr;
+	ptr += rcuh.codesize;
+	rcu_data_size = rcuh.datasize + rcuh.bsssize;
+	rcu_data = ptr;
+	ptr += rcuh.datasize;
+
+	if(rcuh.relsize)
+	{
+		uint32_t relocations[rcuh.relsize / sizeof(int)];
+		rcu_load_offs(relocations, ptr, rcuh.relsize);
+		ptr += rcuh.relsize;
+	}
+	if(rcuh.conssize)
+	{
+		uint32_t constructors[rcuh.conssize / sizeof(int)];
+		rcu_load_offs(constructors, ptr, rcuh.conssize);
+		ptr += rcuh.conssize;
+	}
+	if(rcuh.dessize)
+	{
+		uint32_t destructors[rcuh.dessize / sizeof(int)];
+		rcu_load_offs(destructors, ptr, rcuh.dessize);
+		ptr += rcuh.dessize;
+	}
+
+	ptr = rcu_data + rcu_data_size - 16 + 4;
+	rcu_load_offs(&nexports, ptr, sizeof(int));
+	if(nexports)
+	{
+		uint32_t exports[nexports * 3];
+		rcu_load_offs(exports, ptr - nexports * sizeof(int) * 3, nexports * sizeof(int) * 3);
+		for(i = 0; i < nexports; i++)
+		{
+			char *symbol = (char *) (rcu_code + exports[0 + i * 3]);
+			uint32_t faddr = exports[2 + i * 3];
+			if(strcmp(symbol, "snippet_decrypt") == 0) decrypt_addr = faddr;
+		}
+	}
+	ptr -= nexports * 3 * sizeof(int) + 8;
+	rcu_load_offs(&nimports, ptr, sizeof(int));
+	if(nimports)
+	{
+		uint32_t imports[nimports * 3];
+		rcu_load_offs(imports, ptr - nimports * sizeof(int) * 3, nimports * sizeof(int) * 3);
+	}
+}
+
+int load_sections(uint8_t *body)
+{
+	uint8_t section[4096];
+	uint16_t sect_len, sect_no, last_sect_no, curr_sect_no = 0;
+	int body_len, total_body_len = 0; 
+	uint32_t i=0;
+
+	while((i+3)<raw_buffer.used)
+	{
+		memcpy(section, raw_buffer.data+i, 3);
+		i+=3;
+		memcpy(&sect_len, section+1, 2);
+		sect_len = ntohs(sect_len) & 0xfff;
+		
+		memcpy(section + 3, raw_buffer.data+i, sect_len);
+		i+=sect_len;
+
+		if(section[0] != 0x91 || sect_len < (4 + 5)) continue;
+
+		uint32_t crc = crc32(-1, section, sect_len + 3 - 4);
+		uint32_t sect_crc = (uint32_t) section[sect_len - 1 + 3] << 24 | section[sect_len - 2 + 3] << 16 | section[sect_len - 3 + 3] << 8 | section[sect_len - 4 + 3];
+		
+		if(crc != sect_crc)
+		{
+			cs_log("[icg] Broken section crc %08x %08x\n",(uint32_t) crc,(uint32_t) sect_crc);
+			continue;
+		}
+
+		sect_no = section[6];
+		last_sect_no = section[7];
+
+		if(curr_sect_no == 0)
+		{
+			gId = (section[13] << 8) | section[14];
+			gVersion = (section[5] & 0x3e) >> 1;
+		}
+		if(curr_sect_no == sect_no)
+		{
+			body_len = sect_len - 5 - 4;
+			memcpy(body, section + 8, body_len);
+			total_body_len += body_len;
+			body += body_len;
+			curr_sect_no++;
+		}
+		if(curr_sect_no > last_sect_no) break;
+	}
+	return total_body_len;
+}
+
+static int32_t allocate_data_block(data_block *buff, uint32_t size)
+{
+	if (buff->data == NULL)
+	{
+		buff->data = malloc(size);
+		if (buff->data == NULL) { return -1; }
+		buff->size = size;
+		buff->used = 0;
+	}
+	if (buff->size < size)
+	{
+		uint8_t *new_buff;
+
+		new_buff = malloc(size);
+		if (new_buff == NULL) { return -1; }
+		memcpy(new_buff, buff->data, buff->used);
+
+		free(buff->data);
+
+		buff->data = new_buff;
+		buff->size = size;
+	}
+	return 0;
+}
+
+uint8_t Drecrypt2OverCW(uint16_t overcryptId, uint8_t *cw)
+{
+	if(overcryptId == gId)
+	{
+		if(st20_run(code_buffer.data, code_buffer.used, decrypt_addr, cw, overcryptId)) return 0;
+		else return 1;
+	}
+	else
+	{
+		cs_log("[icg] ICG algo %04X not found", overcryptId);
+	}
+	return 2;
+}
+
+void Drecrypt2OverEMM(uint8_t *emm)
+{	
+	uint32_t dataLen;
+	printf("emm filter %02X len %X\n",emm[0], (((emm[1] & 0x0F) << 8) | emm[2]));
+	FILE *f = fopen("/tmp/emm_snip.bin","wb"); fwrite(emm,(((emm[1] & 0x0F) << 8) | emm[2])+3 ,1,f); fclose(f); //megavolt
+	if(gVersion == (emm[5] & 0x3e) >> 1)
+	{
+		return;
+	}
+
+	if (gRawSec == 0)
+	{
+		if(emm[6] != 0)
+		{
+			return;
+		}
+	}
+
+	if (emm[6] != gRawSec)
+	{
+		gRawSec = 0;
+		return;
+	}
+
+	dataLen = ((emm[1] & 0xF) << 8) | emm[2];
+	dataLen += 3;
+	if(dataLen < 4)
+	{
+		return;
+	}
+
+	if (gRawSec == 0)
+	{
+		raw_buffer.used = 0;
+	}
+
+	if (allocate_data_block(&raw_buffer, raw_buffer.used + dataLen))
+	{
+		return;
+	}
+
+	memcpy(raw_buffer.data + raw_buffer.used, emm, dataLen);
+	raw_buffer.used += dataLen;
+
+	if (emm[6] != emm[7])
+	{
+		gRawSec++;
+		return;
+	}
+
+	gRawSec = 0;
+
+	int patch_len, rcu_len, len, snip_len;
+	uint8_t *buf = malloc(0x1000), *snip = malloc(0x10000), *rcu = malloc(0x10000), *patch = malloc(0x10000);
+	
+	if(buf == NULL || snip == NULL || rcu == NULL || patch == NULL) return;
+	
+    snip_len = (initial_snippet[4] << 24) | (initial_snippet[5] << 16) | (initial_snippet[6] << 8) | initial_snippet[7];
+    
+    if(dre_unpack(snip, initial_snippet + 8, sizeof(initial_snippet) - 8) >= snip_len)
+    {
+		if((len = load_sections(buf)) > 0)
+		{
+			patch_len = (buf[14] << 24) | (buf[15] << 16) | (buf[16] << 8) | buf[17];
+			if(dre_unpack(patch, buf + 18, len - 18) >= patch_len)
+			{
+				rcu_len = bspatch(rcu, snip, snip_len, patch);
+				if(rcu_len > 0)
+				{
+					rcu_load(rcu);
+					allocate_data_block(&code_buffer,rcu_len);
+					memcpy(code_buffer.data, rcu, rcu_len);
+					code_buffer.used = (uint32_t) rcu_len;
+					cs_log("[icg] snippet patch created. ICG algo %04X", gId);
+				}
+			}
+		}
+	}
+	
+	free(buf);
+	free(snip);
+	free(rcu);
+	free(patch);
+}
+
diff -ruN oscam-emu-2015-12-03-11142.orig/module-emulator-dre2overcrypt.h oscam-emu-2015-12-03-11142/module-emulator-dre2overcrypt.h
--- oscam-emu-2015-12-03-11142.orig/module-emulator-dre2overcrypt.h	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/module-emulator-dre2overcrypt.h	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,7 @@
+#ifndef DRE2_OVERCRYPT_H_
+#define DRE2_OVERCRYPT_H_
+
+	uint8_t Drecrypt2OverCW(uint16_t overcryptId, uint8_t *cw);
+	void Drecrypt2OverEMM(uint8_t *emm);
+
+#endif
diff -ruN oscam-emu-2015-12-03-11142.orig/module-emulator-osemu.c oscam-emu-2015-12-03-11142/module-emulator-osemu.c
--- oscam-emu-2015-12-03-11142.orig/module-emulator-osemu.c	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/module-emulator-osemu.c	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,4089 @@
+#include "globals.h"
+#include "ffdecsa/ffdecsa.h"
+
+#ifdef WITH_EMU
+#include "cscrypt/bn.h"
+#include "cscrypt/des.h"
+#include "cscrypt/idea.h"
+#include "cscrypt/md5.h"
+#include "oscam-aes.h"
+#include "oscam-string.h"
+#include "oscam-config.h"
+#include "oscam-conf-chk.h"
+#include "oscam-time.h"
+#include "module-newcamd-des.h"
+// from reader-viaccess.c:
+void hdSurEncPhase1_D2_0F_11(uint8_t *CWs);
+void hdSurEncPhase2_D2_0F_11(uint8_t *CWs);
+void hdSurEncPhase1_D2_13_15(uint8_t *cws);
+void hdSurEncPhase2_D2_13_15(uint8_t *cws);
+#else
+#include "bn.h"
+#include "des.h"
+#include "idea.h"
+#include "md5.h"
+#include "viades.h"
+#include "via3surenc.h"
+#endif
+
+#include "module-emulator-osemu.h"
+#include "module-emulator-stream.h"
+#include "module-emulator-dre2overcrypt.h"
+	
+// Version info
+uint32_t GetOSemuVersion(void)
+{
+	return atoi("$Version: 716 $"+10);
+}
+
+// Key DB
+static char *emu_keyfile_path = NULL;
+extern char cs_confdir[128];
+
+void set_emu_keyfile_path(char *path)
+{
+	if(emu_keyfile_path != NULL) {
+		free(emu_keyfile_path);
+	}
+	emu_keyfile_path = (char*)malloc(strlen(path)+1);
+	if(emu_keyfile_path == NULL) {
+		return;
+	}
+	memcpy(emu_keyfile_path, path, strlen(path));
+	emu_keyfile_path[strlen(path)] = 0;
+}
+
+int32_t CharToBin(uint8_t *out, char *in, uint32_t inLen)
+{
+	uint32_t i, tmp;
+	for(i=0; i<inLen/2; i++) {
+		if(sscanf(in + i*2, "%02X", &tmp) != 1) {
+			return 0;
+		}
+		out[i] = (uint8_t)tmp;
+	}
+	return 1;
+}
+
+KeyDataContainer CwKeys = { .EmuKeys=NULL, .keyCount=0, .keyMax=0 };
+KeyDataContainer ViKeys = { .EmuKeys=NULL, .keyCount=0, .keyMax=0 };
+KeyDataContainer NagraKeys = { .EmuKeys=NULL, .keyCount=0, .keyMax=0 };
+KeyDataContainer IrdetoKeys = { .EmuKeys=NULL, .keyCount=0, .keyMax=0 };
+KeyDataContainer NDSKeys = { .EmuKeys=NULL, .keyCount=0, .keyMax=0 };
+KeyDataContainer BissKeys = { .EmuKeys=NULL, .keyCount=0, .keyMax=0 };
+KeyDataContainer PowervuKeys = { .EmuKeys=NULL, .keyCount=0, .keyMax=0 };
+KeyDataContainer DreKeys = { .EmuKeys=NULL, .keyCount=0, .keyMax=0 };
+
+static KeyDataContainer *GetKeyContainer(char identifier)
+{
+	switch(identifier) {
+	case 'W':
+		return &CwKeys;
+	case 'V':
+		return &ViKeys;
+	case 'N':
+		return &NagraKeys;
+	case 'I':
+		return &IrdetoKeys;
+	case 'S':
+		return &NDSKeys;
+	case 'F':
+		return &BissKeys;
+	case 'P':
+		return &PowervuKeys;
+	case 'D':
+		return &DreKeys;
+	default:
+		return NULL;
+	}
+}
+
+static void WriteEEToFile(struct s_reader *rdr, uint8_t ident)
+{
+	FILE *file = NULL;
+	opkeys_t *ee = ident == 0x11 ? rdr->ee36 : rdr->ee56;
+	char *path = ident == 0x11 ? rdr->extee36 : rdr->extee56;
+	
+	if(ee == NULL) return;
+	
+	if((file = fopen(path,"wb")) == NULL) return;
+	fwrite(ee,1,sizeof(opkeys_t),file);
+	fclose(file);
+}
+
+static void WriteKeyToFile(char identifier, uint32_t provider, char *keyName, uint8_t *key, uint32_t keyLength)
+{
+	char line[1200], dateText[100];
+	uint32_t pathLength;
+	struct dirent *pDirent;
+	DIR *pDir;
+	char *path, *filepath, filename[EMU_KEY_FILENAME_MAX_LEN+1], *keyValue;
+	FILE *file = NULL;
+	uint8_t fileNameLen = strlen(EMU_KEY_FILENAME);
+	time_t now;
+	struct tm t;
+
+	pathLength = strlen(emu_keyfile_path);
+	path = (char*)malloc(pathLength+1);
+	if(path == NULL) {
+		return;
+	}
+	strncpy(path, emu_keyfile_path, pathLength+1);
+
+	pathLength = strlen(path);
+	if(pathLength >= fileNameLen && strcasecmp(path+pathLength-fileNameLen, EMU_KEY_FILENAME) == 0) {
+		// cut file name
+		path[pathLength-fileNameLen] = '\0';
+	}
+
+	pathLength = strlen(path);
+	if(path[pathLength-1] == '/' || path[pathLength-1] == '\\') {
+		// cut trailing /
+		path[pathLength-1] = '\0';
+	}
+
+	pDir = opendir(path);
+	if (pDir == NULL) {
+		cs_log("cannot open key file path: %s", path);
+		free(path);
+		return;
+	}
+
+	while((pDirent = readdir(pDir)) != NULL) {
+		if(strcasecmp(pDirent->d_name, EMU_KEY_FILENAME) == 0) {
+			strncpy(filename, pDirent->d_name, sizeof(filename));
+			break;
+		}
+	}
+	closedir(pDir);
+
+	if(pDirent == NULL) {
+		strncpy(filename, EMU_KEY_FILENAME, sizeof(filename));
+	}
+
+	pathLength = strlen(path)+1+strlen(filename)+1;
+	filepath = (char*)malloc(pathLength);
+	if(filepath == NULL) {
+		free(path);
+		return;
+	}
+	snprintf(filepath, pathLength, "%s/%s", path, filename);
+	free(path);
+
+	cs_log("writing key file: %s", filepath);
+
+	file = fopen(filepath, "a");
+	free(filepath);
+	if(file == NULL) {
+		return;
+	}
+
+	now = time(NULL);
+	localtime_r(&now, &t);
+	strftime(dateText, sizeof(dateText)-1, "%c", &t);
+
+	keyValue = (char*)malloc((keyLength*2)+1);
+	if(keyValue == NULL) {
+		return;
+	}
+	cs_hexdump(0, key, keyLength, keyValue, (keyLength*2)+1);
+
+	snprintf(line, sizeof(line), "\n%c %04X %s %s ; added by OSEmu %s\n", identifier, provider, keyName, keyValue, dateText);
+	free(keyValue);
+
+	fwrite(line, strlen(line), 1, file);
+	fclose(file);
+}
+
+static int32_t SetKey(char identifier, uint32_t provider, char *keyName, uint8_t *key,
+					  uint32_t keyLength, uint8_t writeKey)
+{
+	uint32_t i;
+	uint8_t *tmpKey = NULL, *orgKey = NULL;
+	KeyDataContainer *KeyDB;
+	KeyData *tmpKeyData, *newKeyData;
+	identifier = (char)toupper((int)identifier);
+
+	KeyDB = GetKeyContainer(identifier);
+	if(KeyDB == NULL) {
+		return 0;
+	}
+
+	// fix patched mgcamd format for Irdeto
+	if(identifier == 'I' && provider < 0xFFFF) {
+		provider = provider<<8;
+	}
+
+	// fix checksum for biss keys with a length of 6
+	if(identifier == 'F' && keyLength == 6) {
+
+		tmpKey = (uint8_t*)malloc(8*sizeof(uint8_t));
+		if(tmpKey == NULL) {
+			return 0;
+		}
+
+		tmpKey[0] = key[0];
+		tmpKey[1] = key[1];
+		tmpKey[2] = key[2];
+		tmpKey[3] = ((key[0] + key[1] + key[2]) & 0xff);
+		tmpKey[4] = key[3];
+		tmpKey[5] = key[4];
+		tmpKey[6] = key[5];
+		tmpKey[7] = ((key[3] + key[4] + key[5]) & 0xff);
+
+		orgKey = key;
+		key = tmpKey;
+		keyLength = 8;
+	}
+
+	for(i=0; i<KeyDB->keyCount; i++) {
+		if(KeyDB->EmuKeys[i].provider != provider) {
+			continue;
+		}
+		if(strcmp(KeyDB->EmuKeys[i].keyName, keyName)) {
+			continue;
+		}
+
+		// allow multiple keys for Irdeto
+		if(identifier == 'I')
+		{
+			// reject duplicates
+			tmpKeyData = &KeyDB->EmuKeys[i];
+			do {
+				if(memcmp(tmpKeyData->key, key, tmpKeyData->keyLength < keyLength ? tmpKeyData->keyLength : keyLength) == 0) {
+					if(tmpKey != NULL) {
+						free(tmpKey);
+					}
+					return 0;
+				}
+				tmpKeyData = (KeyData*)tmpKeyData->nextKey;
+			}
+			while(tmpKeyData != NULL);
+
+			// add new key
+			newKeyData = (KeyData*)malloc(sizeof(KeyData));
+			if(newKeyData == NULL) {
+				if(tmpKey != NULL) {
+					free(tmpKey);
+				}
+				return 0;
+			}
+			newKeyData->identifier = identifier;
+			newKeyData->provider = provider;
+			if(strlen(keyName) < EMU_MAX_CHAR_KEYNAME) {
+				strncpy(newKeyData->keyName, keyName, EMU_MAX_CHAR_KEYNAME);
+			}
+			else {
+				memcpy(newKeyData->keyName, keyName, EMU_MAX_CHAR_KEYNAME);
+			}
+			newKeyData->keyName[EMU_MAX_CHAR_KEYNAME-1] = 0;
+			newKeyData->key = key;
+			newKeyData->keyLength = keyLength;
+			newKeyData->nextKey = NULL;
+
+			tmpKeyData = &KeyDB->EmuKeys[i];
+			while(tmpKeyData->nextKey != NULL) {
+				tmpKeyData = (KeyData*)tmpKeyData->nextKey;
+			}
+			tmpKeyData->nextKey = newKeyData;
+
+			if(writeKey) {
+				WriteKeyToFile(identifier, provider, keyName, key, keyLength);
+			}
+		}
+		else // identifier != 'I'
+		{
+			free(KeyDB->EmuKeys[i].key);
+			KeyDB->EmuKeys[i].key = key;
+			KeyDB->EmuKeys[i].keyLength = keyLength;
+
+			if(writeKey) {
+				WriteKeyToFile(identifier, provider, keyName, key, keyLength);
+			}
+		}
+
+		if(tmpKey != NULL) {
+			free(orgKey);
+		}
+		return 1;
+	}
+
+	if(KeyDB->keyCount+1 > KeyDB->keyMax) {
+		if(KeyDB->EmuKeys == NULL) {
+			KeyDB->EmuKeys = (KeyData*)malloc(sizeof(KeyData)*(KeyDB->keyMax+64));
+			if(KeyDB->EmuKeys == NULL) {
+				if(tmpKey != NULL) {
+					free(tmpKey);
+				}
+				return 0;
+			}
+			KeyDB->keyMax+=64;
+		}
+		else {
+			tmpKeyData = (KeyData*)realloc(KeyDB->EmuKeys, sizeof(KeyData)*(KeyDB->keyMax+16));
+			if(tmpKeyData == NULL) {
+				if(tmpKey != NULL) {
+					free(tmpKey);
+				}
+				return 0;
+			}
+			KeyDB->EmuKeys = tmpKeyData;
+			KeyDB->keyMax+=16;
+		}
+	}
+
+	KeyDB->EmuKeys[KeyDB->keyCount].identifier = identifier;
+	KeyDB->EmuKeys[KeyDB->keyCount].provider = provider;
+	if(strlen(keyName) < EMU_MAX_CHAR_KEYNAME) {
+		strncpy(KeyDB->EmuKeys[KeyDB->keyCount].keyName, keyName, EMU_MAX_CHAR_KEYNAME);
+	}
+	else {
+		memcpy(KeyDB->EmuKeys[KeyDB->keyCount].keyName, keyName, EMU_MAX_CHAR_KEYNAME);
+	}
+	KeyDB->EmuKeys[KeyDB->keyCount].keyName[EMU_MAX_CHAR_KEYNAME-1] = 0;
+	KeyDB->EmuKeys[KeyDB->keyCount].key = key;
+	KeyDB->EmuKeys[KeyDB->keyCount].keyLength = keyLength;
+	KeyDB->EmuKeys[KeyDB->keyCount].nextKey = NULL;
+	KeyDB->keyCount++;
+
+	if(writeKey) {
+		WriteKeyToFile(identifier, provider, keyName, key, keyLength);
+	}
+
+	if(tmpKey != NULL) {
+		free(orgKey);
+	}
+	return 1;
+}
+
+static int32_t FindKey(char identifier, uint32_t provider, char *keyName, uint8_t *key, uint32_t maxKeyLength,
+					   uint8_t isCriticalKey, uint8_t keyRef, uint8_t matchLength, uint32_t *getProvider)
+{
+	uint32_t i;
+	uint8_t j;
+	KeyDataContainer *KeyDB;
+	KeyData *tmpKeyData;
+
+	KeyDB = GetKeyContainer(identifier);
+	if(KeyDB == NULL) {
+		return 0;
+	}
+
+	for(i=0; i<KeyDB->keyCount; i++) {
+		if(getProvider == NULL && KeyDB->EmuKeys[i].provider != provider) {
+			continue;
+		}
+		if(strcmp(KeyDB->EmuKeys[i].keyName, keyName)) {
+			continue;
+		}
+
+		//matchLength cannot be used when multiple keys are allowed
+		//for a single provider/keyName combination.
+		//Currently this is only the case for Irdeto keys.
+		if(matchLength && KeyDB->EmuKeys[i].keyLength != maxKeyLength) {
+			continue;
+		}
+
+		tmpKeyData = &KeyDB->EmuKeys[i];
+
+		j = 0;
+		while(j<keyRef && tmpKeyData->nextKey != NULL) {
+			j++;
+			tmpKeyData = (KeyData*)tmpKeyData->nextKey;
+		}
+
+		if(j == keyRef) {
+			memcpy(key, tmpKeyData->key, tmpKeyData->keyLength > maxKeyLength ? maxKeyLength : tmpKeyData->keyLength);
+			if(tmpKeyData->keyLength < maxKeyLength) {
+				memset(key+tmpKeyData->keyLength, 0, maxKeyLength - tmpKeyData->keyLength);
+			}
+			if(getProvider != NULL) {
+				(*getProvider) = tmpKeyData->provider;
+			}
+			return 1;
+		}
+		else {
+			break;
+		}
+	}
+
+	if(isCriticalKey) {
+		cs_log("[Emu] Key not found: %c %X %s", identifier, provider, keyName);
+	}
+	return 0;
+}
+
+static int32_t UpdateKey(char identifier, uint32_t provider, char *keyName, uint8_t *key, uint32_t keyLength)
+{
+	uint8_t *tmpKey = (uint8_t*)malloc(sizeof(uint8_t)*keyLength);
+	if(tmpKey == NULL)
+	{
+		return 0;
+	}
+
+	if(FindKey(identifier, provider, keyName, tmpKey, keyLength, 0, 0, 0, NULL)
+			&& memcmp(tmpKey, key, keyLength) == 0)
+	{
+		free(tmpKey);
+		return 0;
+	}
+
+	free(tmpKey);
+
+	return SetKey(identifier, provider, keyName, key, keyLength, 1);
+}
+
+void set_emu_extee(struct s_reader *reader)
+{
+	FILE *file = NULL;
+	
+	if(reader->ee36 != NULL)
+	{
+		//add md5 check
+		free(reader->ee36);
+	}
+	
+	if(reader->ee56 != NULL)
+	{
+		//add md5 check
+		free(reader->ee56);
+	}
+	
+	reader->ee36 = malloc(sizeof(opkeys_t));
+	reader->ee56 = malloc(sizeof(opkeys_t));
+	
+	if(reader->ee36 == NULL || reader->ee56 == NULL) return;
+	
+	memset(reader->ee36,0,sizeof(opkeys_t));
+	memset(reader->ee56,0,sizeof(opkeys_t));
+	
+	if(reader->extee36 == NULL) {reader->extee36 = malloc(256); snprintf(reader->extee36,256,"%see36.bin",cs_confdir);}
+	if(reader->extee56 == NULL) {reader->extee56 = malloc(256); snprintf(reader->extee56,256,"%see56.bin",cs_confdir);}
+	
+	if((file = fopen(reader->extee36,"rb")) != NULL)
+	{
+		if(fread(reader->ee36,1,sizeof(opkeys_t),file) != sizeof(opkeys_t))
+		{
+			memset(reader->ee36,0,sizeof(opkeys_t));
+		}
+		fclose(file);
+	}
+	else cs_log("cannot open key file path: %s", reader->extee36);
+	
+	if((file = fopen(reader->extee56,"rb")) != NULL)
+	{
+		if(fread(reader->ee56,1,sizeof(opkeys_t),file) != sizeof(opkeys_t))
+		{
+			memset(reader->ee56,0,sizeof(opkeys_t));
+		}
+		fclose(file);
+	}
+	else cs_log("cannot open key file path: %s", reader->extee56);
+}
+
+uint8_t read_emu_keyfile(char *opath)
+{
+	char line[1200], keyName[EMU_MAX_CHAR_KEYNAME], keyString[1026];
+	uint32_t pathLength, provider, keyLength;
+	uint8_t *key;
+	struct dirent *pDirent;
+	DIR *pDir;
+	char *path, *filepath, filename[EMU_KEY_FILENAME_MAX_LEN+1]/*,eepath[256]*/;
+	FILE *file = NULL;
+	char identifier;
+	uint8_t fileNameLen = strlen(EMU_KEY_FILENAME);
+	
+	pathLength = strlen(opath);
+	path = (char*)malloc(pathLength+1);
+	if(path == NULL) {
+		return 0;
+	}
+	strncpy(path, opath, pathLength+1);
+
+	pathLength = strlen(path);
+	if(pathLength >= fileNameLen && strcasecmp(path+pathLength-fileNameLen, EMU_KEY_FILENAME) == 0) {
+		// cut file name
+		path[pathLength-fileNameLen] = '\0';
+	}
+
+	pathLength = strlen(path);
+	if(path[pathLength-1] == '/' || path[pathLength-1] == '\\') {
+		// cut trailing /
+		path[pathLength-1] = '\0';
+	}
+
+	pDir = opendir(path);
+	if (pDir == NULL) {
+		cs_log("cannot open key file path: %s", path);
+		free(path);
+		return 0;
+	}
+
+	while((pDirent = readdir(pDir)) != NULL) {
+		if(strcasecmp(pDirent->d_name, EMU_KEY_FILENAME) == 0) {
+			strncpy(filename, pDirent->d_name, sizeof(filename));
+			break;
+		}
+	}
+	closedir(pDir);
+
+	if(pDirent == NULL) {
+		cs_log("key file not found in: %s", path);
+		free(path);
+		return 0;
+	}
+
+	pathLength = strlen(path)+1+strlen(filename)+1;
+	filepath = (char*)malloc(pathLength);
+	if(filepath == NULL) {
+		free(path);
+		return 0;
+	}
+	snprintf(filepath, pathLength, "%s/%s", path, filename);
+	free(path);
+
+	cs_log("reading key file: %s", filepath);
+
+	file = fopen(filepath, "r");
+	free(filepath);
+	if(file == NULL) {
+		return 0;
+	}
+
+	set_emu_keyfile_path(opath);
+
+	while(fgets(line, 1200, file)) {
+		if(sscanf(line, "%c %8x %11s %1024s", &identifier, &provider, keyName, keyString) != 4) {
+			continue;
+		}
+
+		keyLength = strlen(keyString)/2;
+		key = (uint8_t*)malloc(keyLength);
+		if(key == NULL) {
+			fclose(file);
+			return 0;
+		}
+
+		CharToBin(key, keyString, strlen(keyString));
+		if(!SetKey(identifier, provider, keyName, key, keyLength, 0)) {
+			free(key);
+		}
+	}
+	fclose(file);
+
+	return 1;
+}
+
+#if !defined(__APPLE__) && !defined(__ANDROID__)
+extern uint8_t SoftCamKey_Data[]    __asm__("_binary_SoftCam_Key_start");
+extern uint8_t SoftCamKey_DataEnd[] __asm__("_binary_SoftCam_Key_end");
+
+void read_emu_keymemory(void)
+{
+	char *keyData, *line, *saveptr, keyName[EMU_MAX_CHAR_KEYNAME], keyString[1026];
+	uint32_t provider, keyLength;
+	uint8_t *key;
+	char identifier;
+
+	keyData = (char*)malloc(SoftCamKey_DataEnd-SoftCamKey_Data+1);
+	if(keyData == NULL) {
+		return;
+	}
+	memcpy(keyData, SoftCamKey_Data, SoftCamKey_DataEnd-SoftCamKey_Data);
+	keyData[SoftCamKey_DataEnd-SoftCamKey_Data] = 0x00;
+
+	line = strtok_r(keyData, "\n", &saveptr);
+	while(line != NULL) {
+		if(sscanf(line, "%c %8x %11s %1024s", &identifier, &provider, keyName, keyString) != 4) {
+			line = strtok_r(NULL, "\n", &saveptr);
+			continue;
+		}
+		keyLength = strlen(keyString)/2;
+		key = (uint8_t*)malloc(keyLength);
+		if(key == NULL) {
+			free(keyData);
+			return;
+		}
+
+		CharToBin(key, keyString, strlen(keyString));
+		if(!SetKey(identifier, provider, keyName, key, keyLength, 0)) {
+			free(key);
+		}
+		line = strtok_r(NULL, "\n", &saveptr);
+	}
+	free(keyData);
+}
+#endif
+
+// Shared functions
+
+static inline uint16_t GetEcmLen(const uint8_t *ecm)
+{
+	return (((ecm[1] & 0x0f)<< 8) | ecm[2]) +3;
+}
+
+static void ReverseMem(uint8_t *in, int32_t len)
+{
+	uint8_t temp;
+	int32_t i;
+	for(i = 0; i < (len / 2); i++) {
+		temp = in[i];
+		in[i] = in[len - i - 1];
+		in[len - i - 1] = temp;
+	}
+}
+
+static void ReverseMemInOut(uint8_t *out, const uint8_t *in, int32_t n)
+{
+	if(n>0) {
+		out+=n;
+		do {
+			*(--out)=*(in++);
+		}
+		while(--n);
+	}
+}
+
+static int8_t EmuRSAInput(BIGNUM *d, const uint8_t *in, int32_t n, int8_t le)
+{
+	int8_t result = 0;
+
+	if(le) {
+		uint8_t *tmp = (uint8_t *)malloc(sizeof(uint8_t)*n);
+		if(tmp == NULL) {
+			return 0;
+		}
+		ReverseMemInOut(tmp,in,n);
+		result = BN_bin2bn(tmp,n,d)!=0;
+		free(tmp);
+	}
+	else {
+		result = BN_bin2bn(in,n,d)!=0;
+	}
+	return result;
+}
+
+static int32_t EmuRSAOutput(uint8_t *out, int32_t n, BIGNUM *r, int8_t le)
+{
+	int32_t s = BN_num_bytes(r);
+	if(s>n) {
+		uint8_t *buff = (uint8_t *)malloc(sizeof(uint8_t)*s);
+		if(buff == NULL) {
+			return 0;
+		}
+		BN_bn2bin(r,buff);
+		memcpy(out,buff+s-n,n);
+		free(buff);
+	}
+	else if(s<n) {
+		int32_t l=n-s;
+		memset(out,0,l);
+		BN_bn2bin(r,out+l);
+	}
+	else {
+		BN_bn2bin(r,out);
+	}
+	if(le) {
+		ReverseMem(out,n);
+	}
+	return s;
+}
+
+static int32_t EmuRSA(uint8_t *out, const uint8_t *in, int32_t n, BIGNUM *exp, BIGNUM *mod, int8_t le)
+{
+	BN_CTX *ctx;
+	BIGNUM *r, *d;
+	int32_t result = 0;
+
+	ctx = BN_CTX_new();
+	r = BN_new();
+	d = BN_new();
+
+	if(EmuRSAInput(d,in,n,le) && BN_mod_exp(r,d,exp,mod,ctx)) {
+		result = EmuRSAOutput(out,n,r,le);
+	}
+
+	BN_free(d);
+	BN_free(r);
+	BN_CTX_free(ctx);
+	return result;
+}
+
+static inline void xxor(uint8_t *data, int32_t len, const uint8_t *v1, const uint8_t *v2)
+{
+	uint32_t i;
+	switch(len)
+	{
+	case 16:
+		for(i = 8; i < 16; ++i)
+		{
+			data[i] = v1[i] ^ v2[i];
+		}
+	case 8:
+		for(i = 4; i < 8; ++i)
+		{
+			data[i] = v1[i] ^ v2[i];
+		}
+	case 4:
+		for(i = 0; i < 4; ++i)
+		{
+			data[i] = v1[i] ^ v2[i];
+		}
+		break;
+	default:
+		while(len--) { *data++ = *v1++ ^ *v2++; }
+		break;
+	}
+}
+
+static int8_t isValidDCW(uint8_t *dw)
+{
+	if (((dw[0]+dw[1]+dw[2]) & 0xFF) != dw[3]) {
+		return 0;
+	}
+	if (((dw[4]+dw[5]+dw[6]) & 0xFF) != dw[7]) {
+		return 0;
+	}
+	if (((dw[8]+dw[9]+dw[10]) & 0xFF) != dw[11]) {
+		return 0;
+	}
+	if (((dw[12]+dw[13]+dw[14]) & 0xFF) != dw[15]) {
+		return 0;
+	}
+	return 1;
+}
+
+static inline uint8_t GetBit(uint8_t byte, uint8_t bitnb)
+{
+	return ((byte&(1<<bitnb)) ? 1: 0);
+}
+
+static inline uint8_t SetBit(uint8_t val, uint8_t bitnb, uint8_t biton)
+{
+	return (biton ? (val | (1<<bitnb)) : (val & ~(1<<bitnb)));
+}
+
+static void ExpandDesKey(unsigned char *key)
+{
+	uint8_t i, j, parity;
+	uint8_t tmpKey[7];
+
+	memcpy(tmpKey, key, 7);
+
+	key[0] = (tmpKey[0] & 0xFE);
+	key[1] = ((tmpKey[0] << 7) | ((tmpKey[1] >> 1) & 0xFE));
+	key[2] = ((tmpKey[1] << 6) | ((tmpKey[2] >> 2) & 0xFE));
+	key[3] = ((tmpKey[2] << 5) | ((tmpKey[3] >> 3) & 0xFE));
+	key[4] = ((tmpKey[3] << 4) | ((tmpKey[4] >> 4) & 0xFE));
+	key[5] = ((tmpKey[4] << 3) | ((tmpKey[5] >> 5) & 0xFE));
+	key[6] = ((tmpKey[5] << 2) | ((tmpKey[6] >> 6) & 0xFE));
+	key[7] = (tmpKey[6] << 1);
+
+	for (i = 0; i < 8; i++)
+	{
+		parity = 1;
+		for (j = 1; j < 8; j++) if ((key[i] >> j) & 0x1) { parity = ~parity & 0x01; }
+		key[i] |= parity;
+	}
+}
+
+// Cryptoworks EMU
+static int8_t GetCwKey(uint8_t *buf,uint32_t ident, uint8_t keyIndex, uint32_t keyLength, uint8_t isCriticalKey)
+{
+
+	char keyName[EMU_MAX_CHAR_KEYNAME];
+	uint32_t tmp;
+
+	if((ident>>4)== 0xD02A) {
+		keyIndex &=0xFE;    // map to even number key indexes
+	}
+	if((ident>>4)== 0xD00C) {
+		ident = 0x0D00C0;    // map provider C? to C0
+	}
+	else if(keyIndex==6 && ((ident>>8) == 0x0D05)) {
+		ident = 0x0D0504;    // always use provider 04 system key
+	}
+
+	tmp = keyIndex;
+	snprintf(keyName, EMU_MAX_CHAR_KEYNAME, "%.2X", tmp);
+	if(FindKey('W', ident, keyName, buf, keyLength, isCriticalKey, 0, 0, NULL)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+static const uint8_t cw_sbox1[64] = {
+	0xD8,0xD7,0x83,0x3D,0x1C,0x8A,0xF0,0xCF,0x72,0x4C,0x4D,0xF2,0xED,0x33,0x16,0xE0,
+	0x8F,0x28,0x7C,0x82,0x62,0x37,0xAF,0x59,0xB7,0xE0,0x00,0x3F,0x09,0x4D,0xF3,0x94,
+	0x16,0xA5,0x58,0x83,0xF2,0x4F,0x67,0x30,0x49,0x72,0xBF,0xCD,0xBE,0x98,0x81,0x7F,
+	0xA5,0xDA,0xA7,0x7F,0x89,0xC8,0x78,0xA7,0x8C,0x05,0x72,0x84,0x52,0x72,0x4D,0x38
+};
+static const uint8_t cw_sbox2[64] = {
+	0xD8,0x35,0x06,0xAB,0xEC,0x40,0x79,0x34,0x17,0xFE,0xEA,0x47,0xA3,0x8F,0xD5,0x48,
+	0x0A,0xBC,0xD5,0x40,0x23,0xD7,0x9F,0xBB,0x7C,0x81,0xA1,0x7A,0x14,0x69,0x6A,0x96,
+	0x47,0xDA,0x7B,0xE8,0xA1,0xBF,0x98,0x46,0xB8,0x41,0x45,0x9E,0x5E,0x20,0xB2,0x35,
+	0xE4,0x2F,0x9A,0xB5,0xDE,0x01,0x65,0xF8,0x0F,0xB2,0xD2,0x45,0x21,0x4E,0x2D,0xDB
+};
+static const uint8_t cw_sbox3[64] = {
+	0xDB,0x59,0xF4,0xEA,0x95,0x8E,0x25,0xD5,0x26,0xF2,0xDA,0x1A,0x4B,0xA8,0x08,0x25,
+	0x46,0x16,0x6B,0xBF,0xAB,0xE0,0xD4,0x1B,0x89,0x05,0x34,0xE5,0x74,0x7B,0xBB,0x44,
+	0xA9,0xC6,0x18,0xBD,0xE6,0x01,0x69,0x5A,0x99,0xE0,0x87,0x61,0x56,0x35,0x76,0x8E,
+	0xF7,0xE8,0x84,0x13,0x04,0x7B,0x9B,0xA6,0x7A,0x1F,0x6B,0x5C,0xA9,0x86,0x54,0xF9
+};
+static const uint8_t cw_sbox4[64] = {
+	0xBC,0xC1,0x41,0xFE,0x42,0xFB,0x3F,0x10,0xB5,0x1C,0xA6,0xC9,0xCF,0x26,0xD1,0x3F,
+	0x02,0x3D,0x19,0x20,0xC1,0xA8,0xBC,0xCF,0x7E,0x92,0x4B,0x67,0xBC,0x47,0x62,0xD0,
+	0x60,0x9A,0x9E,0x45,0x79,0x21,0x89,0xA9,0xC3,0x64,0x74,0x9A,0xBC,0xDB,0x43,0x66,
+	0xDF,0xE3,0x21,0xBE,0x1E,0x16,0x73,0x5D,0xA2,0xCD,0x8C,0x30,0x67,0x34,0x9C,0xCB
+};
+static const uint8_t AND_bit1[8] = {0x00,0x40,0x04,0x80,0x21,0x10,0x02,0x08};
+static const uint8_t AND_bit2[8] = {0x80,0x08,0x01,0x40,0x04,0x20,0x10,0x02};
+static const uint8_t AND_bit3[8] = {0x82,0x40,0x01,0x10,0x00,0x20,0x04,0x08};
+static const uint8_t AND_bit4[8] = {0x02,0x10,0x04,0x40,0x80,0x08,0x01,0x20};
+
+static void CW_SWAP_KEY(uint8_t *key)
+{
+	uint8_t k[8];
+	memcpy(k, key, 8);
+	memcpy(key, key + 8, 8);
+	memcpy(key + 8, k, 8);
+}
+
+static void CW_SWAP_DATA(uint8_t *k)
+{
+	uint8_t d[4];
+	memcpy(d, k + 4, 4);
+	memcpy(k + 4 ,k ,4);
+	memcpy(k, d, 4);
+}
+
+static void CW_DES_ROUND(uint8_t *d, uint8_t *k)
+{
+	uint8_t aa[44] = {1,0,3,1,2,2,3,2,1,3,1,1,3,0,1,2,3,1,3,2,2,0,7,6,5,4,7,6,5,7,6,5,6,7,5,7,5,7,6,6,7,5,4,4};
+	uint8_t bb[44] = {0x80,0x08,0x10,0x02,0x08,0x40,0x01,0x20,0x40,0x80,0x04,0x10,0x04,0x01,0x01,0x02,0x20,0x20,0x02,0x01,
+					  0x80,0x04,0x02,0x02,0x08,0x02,0x10,0x80,0x01,0x20,0x08,0x80,0x01,0x08,0x40,0x01,0x02,0x80,0x10,0x40,0x40,0x10,0x08,0x01
+					 };
+	uint8_t ff[4] = {0x02,0x10,0x04,0x04};
+	uint8_t l[24] = {0,2,4,6,7,5,3,1,4,5,6,7,7,6,5,4,7,4,5,6,4,7,6,5};
+
+	uint8_t des_td[8], i, o, n, c = 1, m = 0, r = 0, *a = aa, *b = bb, *f = ff, *p1 = l, *p2 = l+8, *p3 = l+16;
+
+	for (m = 0; m < 2; m++) {
+		for(i = 0; i < 4; i++) {
+			des_td[*p1++] =
+				(m) ? ((d[*p2++]*2) & 0x3F) | ((d[*p3++] & 0x80) ? 0x01 : 0x00): (d[*p2++]/2) | ((d[*p3++] & 0x01) ? 0x80 : 0x00);
+		}
+	}
+
+	for (i = 0; i < 8; i++) {
+		c = (c) ? 0 : 1;
+		r = (c) ? 6 : 7;
+		n = (i) ? i-1 : 1;
+		o = (c) ? ((k[n] & *f++) ? 1 : 0) : des_td[n];
+		for (m = 1; m < r; m++) {
+			o = (c) ? (o*2) | ((k[*a++] & *b++) ? 0x01 : 0x00) : (o/2) | ((k[*a++] & *b++) ? 0x80 : 0x00);
+		}
+		n = (i) ? n+1 : 0;
+		des_td[n] = (c) ? des_td[n] ^ o : (o ^ des_td[n] )/4;
+	}
+
+	for( i = 0; i < 8; i++) {
+		d[0] ^= (AND_bit1[i] & cw_sbox1[des_td[i]]);
+		d[1] ^= (AND_bit2[i] & cw_sbox2[des_td[i]]);
+		d[2] ^= (AND_bit3[i] & cw_sbox3[des_td[i]]);
+		d[3] ^= (AND_bit4[i] & cw_sbox4[des_td[i]]);
+	}
+
+	CW_SWAP_DATA(d);
+}
+
+static void CW_48_Key(uint8_t *inkey, uint8_t *outkey, uint8_t algotype)
+{
+	uint8_t Round_Counter, i = 8, *key128 = inkey, *key48 = inkey + 0x10;
+	Round_Counter = 7 - (algotype & 7);
+
+	memset(outkey, 0, 16);
+	memcpy(outkey, key48, 6);
+
+	for( ; i > Round_Counter; i--) {
+		if (i > 1) {
+			outkey[i-2] = key128[i];
+		}
+	}
+}
+
+static void CW_LS_DES_KEY(uint8_t *key,uint8_t Rotate_Counter)
+{
+	uint8_t round[] = {1,2,2,2,2,2,2,1,2,2,2,2,2,2,1,1};
+	uint8_t i, n;
+	uint16_t k[8];
+
+	n = round[Rotate_Counter];
+
+	for (i = 0; i < 8; i++) {
+		k[i] = key[i];
+	}
+
+	for (i = 1; i < n + 1; i++) {
+		k[7] = (k[7]*2) | ((k[4] & 0x008) ? 1 : 0);
+		k[6] = (k[6]*2) | ((k[7] & 0xF00) ? 1 : 0);
+		k[7] &=0xff;
+		k[5] = (k[5]*2) | ((k[6] & 0xF00) ? 1 : 0);
+		k[6] &=0xff;
+		k[4] = ((k[4]*2) | ((k[5] & 0xF00) ? 1 : 0)) & 0xFF;
+		k[5] &= 0xff;
+		k[3] = (k[3]*2) | ((k[0] & 0x008) ? 1 : 0);
+		k[2] = (k[2]*2) | ((k[3] & 0xF00) ? 1 : 0);
+		k[3] &= 0xff;
+		k[1] = (k[1]*2) | ((k[2] & 0xF00) ? 1 : 0);
+		k[2] &= 0xff;
+		k[0] = ((k[0]*2) | ((k[1] & 0xF00) ? 1 : 0)) & 0xFF;
+		k[1] &= 0xff;
+	}
+	for (i = 0; i < 8; i++) {
+		key[i] = (uint8_t) k[i];
+	}
+}
+
+static void CW_RS_DES_KEY(uint8_t *k, uint8_t Rotate_Counter)
+{
+	uint8_t i,c;
+	for (i = 1; i < Rotate_Counter+1; i++) {
+		c = (k[3] & 0x10) ? 0x80 : 0;
+		k[3] /= 2;
+		if (k[2] & 1) {
+			k[3] |= 0x80;
+		}
+		k[2] /= 2;
+		if (k[1] & 1) {
+			k[2] |= 0x80;
+		}
+		k[1] /= 2;
+		if (k[0] & 1) {
+			k[1] |= 0x80;
+		}
+		k[0] /= 2;
+		k[0] |= c ;
+		c = (k[7] & 0x10) ? 0x80 : 0;
+		k[7] /= 2;
+		if (k[6] & 1) {
+			k[7] |= 0x80;
+		}
+		k[6] /= 2;
+		if (k[5] & 1) {
+			k[6] |= 0x80;
+		}
+		k[5] /= 2;
+		if (k[4] & 1) {
+			k[5] |= 0x80;
+		}
+		k[4] /= 2;
+		k[4] |= c;
+	}
+}
+
+static void CW_RS_DES_SUBKEY(uint8_t *k, uint8_t Rotate_Counter)
+{
+	uint8_t round[] = {1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1};
+	CW_RS_DES_KEY(k, round[Rotate_Counter]);
+}
+
+static void CW_PREP_KEY(uint8_t *key )
+{
+	uint8_t DES_key[8],j;
+	int32_t Round_Counter = 6,i,a;
+	key[7] = 6;
+	memset(DES_key, 0 , 8);
+	do {
+		a = 7;
+		i = key[7];
+		j = key[Round_Counter];
+		do {
+			DES_key[i] = ( (DES_key[i] * 2) | ((j & 1) ? 1: 0) ) & 0xFF;
+			j /=2;
+			i--;
+			if (i < 0) {
+				i = 6;
+			}
+			a--;
+		}
+		while (a >= 0);
+		key[7] = i;
+		Round_Counter--;
+	}
+	while ( Round_Counter >= 0 );
+	a = DES_key[4];
+	DES_key[4] = DES_key[6];
+	DES_key[6] = a;
+	DES_key[7] = (DES_key[3] * 16) & 0xFF;
+	memcpy(key,DES_key,8);
+	CW_RS_DES_KEY(key,4);
+}
+
+static void CW_L2DES(uint8_t *data, uint8_t *key, uint8_t algo)
+{
+	uint8_t i, k0[22], k1[22];
+	memcpy(k0,key,22);
+	memcpy(k1,key,22);
+	CW_48_Key(k0, k1,algo);
+	CW_PREP_KEY(k1);
+	for (i = 0; i< 2; i++) {
+		CW_LS_DES_KEY( k1,15);
+		CW_DES_ROUND( data ,k1);
+	}
+}
+
+static void CW_R2DES(uint8_t *data, uint8_t *key, uint8_t algo)
+{
+	uint8_t i, k0[22],k1[22];
+	memcpy(k0,key,22);
+	memcpy(k1,key,22);
+	CW_48_Key(k0, k1, algo);
+	CW_PREP_KEY(k1);
+	for (i = 0; i< 2; i++) {
+		CW_LS_DES_KEY(k1,15);
+	}
+	for (i = 0; i< 2; i++) {
+		CW_DES_ROUND( data ,k1);
+		CW_RS_DES_SUBKEY(k1,1);
+	}
+	CW_SWAP_DATA(data);
+}
+
+static void CW_DES(uint8_t *data, uint8_t *inkey, uint8_t m)
+{
+	uint8_t key[22], i;
+	memcpy(key, inkey + 9, 8);
+	CW_PREP_KEY( key );
+	for (i = 16; i > 0; i--) {
+		if (m == 1) {
+			CW_LS_DES_KEY(key, (uint8_t) (i-1));
+		}
+		CW_DES_ROUND( data ,key);
+		if (m == 0) {
+			CW_RS_DES_SUBKEY(key, (uint8_t) (i-1));
+		}
+	}
+}
+
+static void CW_DEC_ENC(uint8_t *d, uint8_t *k, uint8_t a,uint8_t m)
+{
+	uint8_t n = m & 1;
+	CW_L2DES(d , k, a);
+	CW_DES (d , k, n);
+	CW_R2DES(d , k, a);
+	if (m & 2) {
+		CW_SWAP_KEY(k);
+	}
+}
+
+static void Cryptoworks3DES(uint8_t *data, uint8_t *key)
+{
+	uint32_t ks1[32], ks2[32];
+	
+	des_set_key(key, ks1);
+	des_set_key(key+8, ks2);
+	
+	des(data, ks1, 0);
+	des(data, ks2, 1);
+	des(data, ks1, 0);
+}
+
+static uint8_t CryptoworksProcessNano80(uint8_t *data, uint32_t caid, int32_t provider, uint8_t *opKey, uint8_t nanoLength, uint8_t nano80Algo)
+{
+	int32_t i, j;
+	uint8_t key[16], desKey[16], t[8], dat1[8], dat2[8], k0D00C000[16];
+	if(nanoLength < 11) {
+		return 0;
+	}
+	if(caid == 0x0D00 && provider != 0xA0 && !GetCwKey(k0D00C000, 0x0D00C0, 0, 16, 1)) {
+		return 0;
+	}
+
+	if(nano80Algo > 1) {
+		return 0;
+	}
+
+	memset(t, 0, 8);
+	memcpy(dat1, data, 8);
+
+	if(caid == 0x0D00 && provider != 0xA0) {
+		memcpy(key, k0D00C000, 16);
+	}
+	else {
+		memcpy(key, opKey, 16);
+	}
+	Cryptoworks3DES(data, key);
+	memcpy(desKey, data, 8);
+
+	memcpy(data, dat1, 8);
+	if(caid == 0x0D00 && provider != 0xA0) {
+		memcpy(key, &k0D00C000[8], 8);
+		memcpy(&key[8], k0D00C000, 8);
+	}
+	else {
+		memcpy(key, &opKey[8], 8);
+		memcpy(&key[8], opKey, 8);
+	}
+	Cryptoworks3DES(data, key);
+	memcpy(&desKey[8], data, 8);
+
+	for(i=8; i+7<nanoLength; i+=8) {
+		memcpy(dat1, &data[i], 8);
+		memcpy(dat2, dat1, 8);
+		memcpy(key, desKey, 16);
+		Cryptoworks3DES(dat1, key);
+		for(j=0; j<8; j++) {
+			dat1[j] ^= t[j];
+		}
+		memcpy(&data[i], dat1, 8);
+		memcpy(t, dat2, 8);
+	}
+
+	return data[10] + 5;
+}
+
+static void CryptoworksSignature(const uint8_t *data, uint32_t length, uint8_t *key, uint8_t *signature)
+{
+	uint32_t i, sigPos;
+	int8_t algo, first;
+
+	algo = data[0] & 7;
+	if(algo == 7) {
+		algo = 6;
+	}
+	memset(signature, 0, 8);
+	first = 1;
+	sigPos = 0;
+	for(i=0; i<length; i++) {
+		signature[sigPos] ^= data[i];
+		sigPos++;
+
+		if(sigPos > 7) {
+			if (first) {
+				CW_L2DES(signature, key, algo);
+			}
+			CW_DES(signature, key, 1);
+
+			sigPos = 0;
+			first = 0;
+		}
+	}
+	if(sigPos > 0) {
+		CW_DES(signature, key, 1);
+	}
+	CW_R2DES(signature, key, algo);
+}
+
+static void CryptoworksDecryptDes(uint8_t *data, uint8_t algo, uint8_t *key)
+{
+	int32_t i;
+	uint8_t k[22], t[8];
+
+	algo &= 7;
+	if(algo<7) {
+		CW_DEC_ENC(data, key, algo, 0);
+	}
+	else {
+		memcpy(k, key, 22);
+		for(i=0; i<3; i++) {
+			CW_DEC_ENC(data, k, algo, i&1);
+			memcpy(t,k,8);
+			memcpy(k,k+8,8);
+			memcpy(k+8,t,8);
+		}
+	}
+}
+
+static int8_t CryptoworksECM(uint32_t caid, uint8_t *ecm, uint8_t *cw)
+{
+	uint32_t ident;
+	uint8_t keyIndex = 0, nanoLength, newEcmLength, key[22], signature[8], nano80Algo = 1;
+	int32_t provider = -1;
+	uint16_t i, j, ecmLen = GetEcmLen(ecm);
+
+	if(ecmLen < 8) {
+		return 1;
+	}
+	if(ecm[7] != ecmLen - 8) {
+		return 1;
+	}
+
+	memset(key, 0, 22);
+
+	for(i = 8; i+1 < ecmLen; i += ecm[i+1] + 2) {
+		if(ecm[i] == 0x83 && i+2 < ecmLen) {
+			provider = ecm[i+2] & 0xFC;
+			keyIndex = ecm[i+2] & 3;
+			keyIndex = keyIndex ? 1 : 0;
+		}
+		else if(ecm[i] == 0x84 && i+3 < ecmLen) {
+			//nano80Provider = ecm[i+2] & 0xFC;
+			//nano80KeyIndex = ecm[i+2] & 3;
+			//nano80KeyIndex = nano80KeyIndex ? 1 : 0;
+			nano80Algo = ecm[i+3];
+		}
+	}
+
+	if(provider < 0) {
+		switch(caid) {
+		case 0x0D00:
+			provider = 0xC0;
+			break;
+		case 0x0D02:
+			provider = 0xA0;
+			break;
+		case 0x0D03:
+			provider = 0x04;
+			break;
+		case 0x0D05:
+			provider = 0x04;
+			break;
+		default:
+			return 1;
+		}
+	}
+
+	ident = (caid << 8) | provider;
+	if(!GetCwKey(key, ident, keyIndex, 16, 1)) {
+		return 2;
+	}
+	if(!GetCwKey(&key[16], ident, 6, 6, 1)) {
+		return 2;
+	}
+
+	for(i = 8; i+1 < ecmLen; i += ecm[i+1] + 2) {
+		if(ecm[i] == 0x80 && i+2+7 < ecmLen && i+2+ecm[i+1] <= ecmLen
+				&& (provider == 0xA0 || provider == 0xC0 || provider == 0xC4 || provider == 0xC8)) {
+			nanoLength = ecm[i+1];
+			newEcmLength = CryptoworksProcessNano80(ecm+i+2, caid, provider, key, nanoLength, nano80Algo);
+			if(newEcmLength == 0 || newEcmLength > ecmLen-(i+2+3)) {
+				return 1;
+			}
+			ecm[i+2+3] = 0x81;
+			ecm[i+2+4] = 0x70;
+			ecm[i+2+5] = newEcmLength;
+			ecm[i+2+6] = 0x81;
+			ecm[i+2+7] = 0xFF;
+			return CryptoworksECM(caid, ecm+i+2+3, cw);
+		}
+	}
+
+	if(ecmLen - 15 < 1) {
+		return 1;
+	}
+	CryptoworksSignature(ecm + 5, ecmLen - 15, key, signature);
+	for(i = 8; i+1 < ecmLen; i += ecm[i+1]+2) {
+		switch(ecm[i]) {
+		case 0xDA:
+		case 0xDB:
+		case 0xDC:
+			if(i+2+ecm[i+1] > ecmLen) {
+				break;
+			}
+			for(j=0; j+7<ecm[i+1]; j+=8) {
+				CryptoworksDecryptDes(&ecm[i+2+j], ecm[5], key);
+			}
+			break;
+		case 0xDF:
+			if(i+2+8 > ecmLen) {
+				break;
+			}
+			if(memcmp(&ecm[i+2], signature, 8)) {
+				return 6;
+			}
+			break;
+		}
+	}
+
+	for(i = 8; i+1 < ecmLen; i += ecm[i+1]+2) {
+		switch(ecm[i]) {
+		case 0xDB:
+			if(i+2+ecm[i+1] <= ecmLen && ecm[i+1]==16) {
+				memcpy(cw, &ecm[i+2], 16);
+				return 0;
+			}
+			break;
+		}
+	}
+
+	return 5;
+}
+
+// SoftNDS EMU
+static const uint8_t nds_const[]= {0x0F,0x1E,0x2D,0x3C,0x4B,0x5A,0x69,0x78,0x87,0x96,0xA5,0xB4,0xC3,0xD2,0xE1,0xF0};
+
+uint8_t viasat_const[]= {
+	0x15,0x85,0xC5,0xE4,0xB8,0x52,0xEC,0xF7,0xC3,0xD9,0x08,0xBA,0x22,0x4A,0x66,0xF2,
+	0x82,0x15,0x4F,0xB2,0x18,0x48,0x63,0x97,0xDC,0x19,0xD8,0x51,0x9A,0x39,0xFC,0xCA,
+	0x1C,0x24,0xD0,0x65,0xA9,0x66,0x2D,0xD6,0x53,0x3B,0x86,0xBA,0x40,0xEA,0x4C,0x6D,
+	0xD9,0x1E,0x41,0x14,0xFE,0x15,0xAF,0xC3,0x18,0xC5,0xF8,0xA7,0xA8,0x01,0x00,0x01,
+};
+
+static int8_t SoftNDSECM(uint16_t caid, uint8_t *ecm, uint8_t *dw)
+{
+	int32_t i;
+	uint8_t *tDW, irdEcmLen, offsetCw = 0, offsetP2 = 0;
+	uint8_t digest[16], md5_const[64];
+	MD5_CTX mdContext;
+	uint16_t ecmLen = GetEcmLen(ecm);
+
+	if(ecmLen < 7) {
+		return 1;
+	}
+
+	if(ecm[3] != 0x00 || ecm[4] != 0x00 || ecm[5] != 0x01) {
+		return 1;
+	}
+
+	irdEcmLen = ecm[6];
+	if(irdEcmLen < (10+3+8+4) || irdEcmLen+6 >= ecmLen) {
+		return 1;
+	}
+
+	for(i=0; 10+i+2 < irdEcmLen; i++) {
+		if(ecm[17+i] == 0x0F && ecm[17+i+1] == 0x40 && ecm[17+i+2] == 0x00) {
+			offsetCw = 17+i+3;
+			offsetP2 = offsetCw+9;
+		}
+	}
+
+	if(offsetCw == 0 || offsetP2 == 0) {
+		return 1;
+	}
+
+	if(offsetP2-7+4 > irdEcmLen) {
+		return 1;
+	}
+
+	if(caid == 0x090F || caid == 0x093E) {
+		memcpy(md5_const, viasat_const, 64);
+	}
+	else if(!FindKey('S', caid, "00", md5_const, 64, 1, 0, 0, NULL)) {
+		return 2;
+	}
+
+	memset(dw,0,16);
+	tDW = &dw[ecm[0]==0x81 ? 8 : 0];
+
+	MD5_Init(&mdContext);
+	MD5_Update(&mdContext, ecm+7, 10);
+	MD5_Update(&mdContext, ecm+offsetP2, 4);
+	MD5_Update(&mdContext, md5_const, 64);
+	MD5_Update(&mdContext, nds_const, 16);
+	MD5_Final(digest, &mdContext);
+
+	for (i=0; i<8; i++) {
+		tDW[i] = digest[i+8] ^ ecm[offsetCw+i];
+	}
+
+	if(((tDW[0]+tDW[1]+tDW[2])&0xFF)-tDW[3]) {
+		return 6;
+	}
+	if(((tDW[4]+tDW[5]+tDW[6])&0xFF)-tDW[7]) {
+		return 6;
+	}
+
+	return 0;
+}
+
+// Viaccess EMU
+static int8_t GetViaKey(uint8_t *buf, uint32_t ident, char keyName, uint32_t keyIndex, uint32_t keyLength, uint8_t isCriticalKey)
+{
+
+	char keyStr[EMU_MAX_CHAR_KEYNAME];
+	snprintf(keyStr, EMU_MAX_CHAR_KEYNAME, "%c%X", keyName, keyIndex);
+	if(FindKey('V', ident, keyStr, buf, keyLength, isCriticalKey, 0, 0, NULL)) {
+		return 1;
+	}
+
+	if(ident == 0xD00040 && FindKey('V', 0x030B00, keyStr, buf, keyLength, isCriticalKey, 0, 0, NULL)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+static void Via1Mod(const uint8_t* key2, uint8_t* data)
+{
+	int32_t kb, db;
+	for (db=7; db>=0; db--) {
+		for (kb=7; kb>3; kb--) {
+			int32_t a0=kb^db;
+			int32_t pos=7;
+			if (a0&4) {
+				a0^=7;
+				pos^=7;
+			}
+			a0=(a0^(kb&3)) + (kb&3);
+			if (!(a0&4)) {
+				data[db]^=(key2[kb] ^ ((data[kb^pos]*key2[kb^4]) & 0xFF));
+			}
+		}
+	}
+	for (db=0; db<8; db++) {
+		for (kb=0; kb<4; kb++) {
+			int32_t a0=kb^db;
+			int32_t pos=7;
+			if (a0&4) {
+				a0^=7;
+				pos^=7;
+			}
+			a0=(a0^(kb&3)) + (kb&3);
+			if (!(a0&4)) {
+				data[db]^=(key2[kb] ^ ((data[kb^pos]*key2[kb^4]) & 0xFF));
+			}
+		}
+	}
+}
+
+static void Via1Decode(uint8_t *data, uint8_t *key)
+{
+	Via1Mod(key+8, data);
+	nc_des(key, DES_ECM_CRYPT, data);
+	Via1Mod(key+8, data);
+}
+
+static void Via1Hash(uint8_t *data, uint8_t *key)
+{
+	Via1Mod(key+8, data);
+	nc_des(key, DES_ECM_HASH, data);
+	Via1Mod(key+8, data);
+}
+
+static inline void Via1DoHash(uint8_t *hashbuffer, uint8_t *pH, uint8_t data, uint8_t *hashkey)
+{
+	hashbuffer[*pH] ^= data;
+	(*pH)++;
+
+	if(*pH == 8) {
+		Via1Hash(hashbuffer, hashkey);
+		*pH = 0;
+	}
+}
+
+static int8_t Via1Decrypt(uint8_t* ecm, uint8_t* dw, uint32_t ident, uint8_t desKeyIndex)
+{
+	uint8_t work_key[16];
+	uint8_t *data, *des_data1, *des_data2;
+	uint16_t ecmLen = GetEcmLen(ecm);
+	int32_t msg_pos;
+	int32_t encStart = 0, hash_start, i;
+	uint8_t signature[8], hashbuffer[8], prepared_key[16], hashkey[16];
+	uint8_t tmp, k, pH, foundData = 0;
+
+	if (ident == 0) {
+		return 4;
+	}
+	memset(work_key, 0, 16);
+	if(!GetViaKey(work_key, ident, '0', desKeyIndex, 8, 1)) {
+		return 2;
+	}
+
+	if(ecmLen < 11) {
+		return 1;
+	}
+	data = ecm+9;
+	des_data1 = dw;
+	des_data2 = dw+8;
+
+	msg_pos = 0;
+	pH = 0;
+	memset(hashbuffer, 0, sizeof(hashbuffer));
+	memcpy(hashkey, work_key, sizeof(hashkey));
+	memset(signature, 0, 8);
+
+	while(9+msg_pos+2 < ecmLen) {
+		switch (data[msg_pos]) {
+		case 0xea:
+			if(9+msg_pos+2+15 < ecmLen) {
+				encStart = msg_pos + 2;
+				memcpy(des_data1, &data[msg_pos+2], 8);
+				memcpy(des_data2, &data[msg_pos+2+8], 8);
+				foundData |= 1;
+			}
+			break;
+		case 0xf0:
+			if(9+msg_pos+2+7 < ecmLen) {
+				memcpy(signature, &data[msg_pos+2], 8);
+				foundData |= 2;
+			}
+			break;
+		}
+		msg_pos += data[msg_pos+1]+2;
+	}
+
+	if(foundData != 3) {
+		return 1;
+	}
+
+	pH=i=0;
+
+	if(data[0] == 0x9f && 10+data[1] <= ecmLen) {
+		Via1DoHash(hashbuffer, &pH, data[i++], hashkey);
+		Via1DoHash(hashbuffer, &pH, data[i++], hashkey);
+
+		for (hash_start=0; hash_start < data[1]; hash_start++) {
+			Via1DoHash(hashbuffer, &pH, data[i++], hashkey);
+		}
+
+		while (pH != 0) {
+			Via1DoHash(hashbuffer, &pH, 0, hashkey);
+		}
+	}
+
+	if (work_key[7] == 0) {
+		for (; i < encStart + 16; i++) {
+			Via1DoHash(hashbuffer, &pH, data[i], hashkey);
+		}
+		memcpy(prepared_key, work_key, 8);
+	}
+	else {
+		prepared_key[0] = work_key[2];
+		prepared_key[1] = work_key[3];
+		prepared_key[2] = work_key[4];
+		prepared_key[3] = work_key[5];
+		prepared_key[4] = work_key[6];
+		prepared_key[5] = work_key[0];
+		prepared_key[6] = work_key[1];
+		prepared_key[7] = work_key[7];
+		memcpy(prepared_key+8, work_key+8, 8);
+
+		if (work_key[7] & 1) {
+			for (; i < encStart; i++) {
+				Via1DoHash(hashbuffer, &pH, data[i], hashkey);
+			}
+
+			k = ((work_key[7] & 0xf0) == 0) ? 0x5a : 0xa5;
+
+			for (i=0; i<8; i++) {
+				tmp = des_data1[i];
+				des_data1[i] = (k & hashbuffer[pH] ) ^ tmp;
+				Via1DoHash(hashbuffer, &pH, tmp, hashkey);
+			}
+
+			for (i = 0; i < 8; i++) {
+				tmp = des_data2[i];
+				des_data2[i] = (k & hashbuffer[pH] ) ^ tmp;
+				Via1DoHash(hashbuffer, &pH, tmp, hashkey);
+			}
+		}
+		else {
+			for (; i < encStart + 16; i++) {
+				Via1DoHash(hashbuffer, &pH, data[i], hashkey);
+			}
+		}
+	}
+	Via1Decode(des_data1, prepared_key);
+	Via1Decode(des_data2, prepared_key);
+	Via1Hash(hashbuffer, hashkey);
+	if(memcmp(signature, hashbuffer, 8)) {
+		return 6;
+	}
+	return 0;
+}
+
+static int8_t Via26ProcessDw(uint8_t *indata, uint32_t ident, uint8_t desKeyIndex)
+{
+	uint8_t pv1,pv2, i;
+	uint8_t Tmp[8], T1Key[300], P1Key[8], KeyDes1[16], KeyDes2[16], XorKey[8];
+	uint32_t ks1[32], ks2[32];
+
+	if(!GetViaKey(T1Key, ident, 'T', 1, 300, 1)) {
+		return 2;
+	}
+	if(!GetViaKey(P1Key, ident, 'P', 1, 8, 1)) {
+		return 2;
+	}
+	if(!GetViaKey(KeyDes1, ident, 'D', 1, 16, 1)) {
+		return 2;
+	}
+	if(!GetViaKey(KeyDes2, ident, '0', desKeyIndex, 16, 1)) {
+		return 2;
+	}
+	if(!GetViaKey(XorKey, ident, 'X', 1, 8, 1)) {
+		return 2;
+	}
+
+	for (i=0; i<8; i++) {
+		pv1 = indata[i];
+		Tmp[i] = T1Key[pv1];
+	}
+	for (i=0; i<8; i++) {
+		pv1 = P1Key[i];
+		pv2 = Tmp[pv1];
+		indata[i]=pv2;
+	}
+	
+	des_set_key(KeyDes1, ks1);
+	des(indata, ks1, 1);
+	
+	for (i=0; i<8; i++) {
+		indata[i] ^= XorKey[i];
+	}
+	
+	des_set_key(KeyDes2, ks1);
+	des_set_key(KeyDes2+8, ks2);
+	des(indata, ks1, 0);
+	des(indata, ks2, 1);
+	des(indata, ks1, 0);
+	
+	for (i=0; i<8; i++) {
+		indata[i] ^= XorKey[i];
+	}
+	
+	des_set_key(KeyDes1, ks1);
+	des(indata, ks1, 0);
+
+	for (i=0; i<8; i++) {
+		pv1 = indata[i];
+		pv2 = P1Key[i];
+		Tmp[pv2] = pv1;
+	}
+	for (i=0; i<8; i++) {
+		pv1 =  Tmp[i];
+		pv2 =  T1Key[pv1];
+		indata[i] = pv2;
+	}
+	return 0;
+}
+
+static int8_t Via26Decrypt(uint8_t* source, uint8_t* dw, uint32_t ident, uint8_t desKeyIndex)
+{
+	uint8_t tmpData[8], C1[8];
+	uint8_t *pXorVector;
+	int32_t i,j;
+
+	if (ident == 0) {
+		return 4;
+	}
+	if(!GetViaKey(C1, ident, 'C', 1, 8, 1)) {
+		return 2;
+	}
+
+	for (i=0; i<2; i++) {
+		memcpy(tmpData, source+ i*8, 8);
+		Via26ProcessDw(tmpData, ident, desKeyIndex);
+		if (i!=0) {
+			pXorVector = source;
+		}
+		else {
+			pXorVector = &C1[0];
+		}
+		for (j=0; j<8; j++) {
+			dw[i*8+j] = tmpData[j]^pXorVector[j];
+		}
+	}
+	return 0;
+}
+
+static void Via3Core(uint8_t *data, uint8_t Off, uint32_t ident, uint8_t* XorKey, uint8_t* T1Key)
+{
+	uint8_t i;
+	uint32_t lR2, lR3, lR4, lR6, lR7;
+
+	switch (ident) {
+	case 0x032820: {
+		for (i=0; i<4; i++) {
+			data[i]^= XorKey[(Off+i) & 0x07];
+		}
+		lR2 = (data[0]^0xBD)+data[0];
+		lR3 = (data[3]^0xEB)+data[3];
+		lR2 = (lR2-lR3)^data[2];
+		lR3 = ((0x39*data[1])<<2);
+		data[4] = (lR2|lR3)+data[2];
+		lR3 = ((((data[0]+6)^data[0]) | (data[2]<<1))^0x65)+data[0];
+		lR2 = (data[1]^0xED)+data[1];
+		lR7 = ((data[3]+0x29)^data[3])*lR2;
+		data[5] = lR7+lR3;
+		lR2 = ((data[2]^0x33)+data[2]) & 0x0A;
+		lR3 = (data[0]+0xAD)^data[0];
+		lR3 = lR3+lR2;
+		lR2 = data[3]*data[3];
+		lR7 = (lR2 | 1) + data[1];
+		data[6] = (lR3|lR7)+data[1];
+		lR3 = data[1] & 0x07;
+		lR2 = (lR3-data[2]) & (data[0] | lR2 |0x01);
+		data[7] = lR2+data[3];
+		for (i=0; i<4; i++) {
+			data[i+4] = T1Key[data[i+4]];
+		}
+	}
+	break;
+	case 0x030B00: {
+		for (i=0; i<4; i++) {
+			data[i]^= XorKey[(Off+i) & 0x07];
+		}
+		lR6 = (data[3] + 0x6E) ^ data[3];
+		lR6 = (lR6*(data[2] << 1)) + 0x17;
+		lR3 = (data[1] + 0x77) ^ data[1];
+		lR4 = (data[0] + 0xD7) ^ data[0];
+		data[4] = ((lR4 & lR3) | lR6) + data[0];
+		lR4 = ((data[3] + 0x71) ^ data[3]) ^ 0x90;
+		lR6 = (data[1] + 0x1B) ^ data[1];
+		lR4 = (lR4*lR6) ^ data[0];
+		data[5] = (lR4 ^ (data[2] << 1)) + data[1];
+		lR3 = (data[3] * data[3])| 0x01;
+		lR4 = (((data[2] ^ 0x35) + data[2]) | lR3) + data[2];
+		lR6 = data[1] ^ (data[0] + 0x4A);
+		data[6] = lR6 + lR4;
+		lR3 = (data[0] * (data[2] << 1)) | data[1];
+		lR4 = 0xFE - data[3];
+		lR3 = lR4 ^ lR3;
+		data[7] = lR3 + data[3];
+		for (i=0; i<4; i++) {
+			data[4+i] = T1Key[data[4+i]];
+		}
+	}
+	break;
+	default:
+		break;
+	}
+}
+
+static void Via3Fct1(uint8_t *data, uint32_t ident, uint8_t* XorKey, uint8_t* T1Key)
+{
+	uint8_t t;
+	Via3Core(data, 0, ident, XorKey, T1Key);
+
+	switch (ident) {
+	case 0x032820: {
+		t = data[4];
+		data[4] = data[7];
+		data[7] = t;
+	}
+	break;
+	case 0x030B00: {
+		t = data[5];
+		data[5] = data[7];
+		data[7] = t;
+	}
+	break;
+	default:
+		break;
+	}
+}
+
+static void Via3Fct2(uint8_t *data, uint32_t ident, uint8_t* XorKey, uint8_t* T1Key)
+{
+	uint8_t t;
+	Via3Core(data, 4, ident, XorKey, T1Key);
+
+	switch (ident) {
+	case 0x032820: {
+		t = data[4];
+		data[4] = data[7];
+		data[7] = data[5];
+		data[5] = data[6];
+		data[6] = t;
+	}
+	break;
+	case 0x030B00: {
+		t = data[6];
+		data[6] = data[7];
+		data[7] = t;
+	}
+	break;
+	default:
+		break;
+	}
+}
+
+static int8_t Via3ProcessDw(uint8_t *data, uint32_t ident, uint8_t desKeyIndex)
+{
+	uint8_t i;
+	uint8_t tmp[8], T1Key[300], P1Key[8], KeyDes[16], XorKey[8];
+	uint32_t ks1[32], ks2[32];
+
+	if(!GetViaKey(T1Key, ident, 'T', 1, 300, 1)) {
+		return 2;
+	}
+	if(!GetViaKey(P1Key, ident, 'P', 1, 8, 1)) {
+		return 2;
+	}
+	if(!GetViaKey(KeyDes, ident, '0', desKeyIndex, 16, 1)) {
+		return 2;
+	}
+	if(!GetViaKey(XorKey, ident, 'X', 1, 8, 1)) {
+		return 2;
+	}
+
+	for (i=0; i<4; i++) {
+		tmp[i] = data[i+4];
+	}
+	Via3Fct1(tmp, ident, XorKey, T1Key);
+	for (i=0; i<4; i++) {
+		tmp[i] = data[i]^tmp[i+4];
+	}
+	Via3Fct2(tmp, ident, XorKey, T1Key);
+	for (i=0; i<4; i++) {
+		tmp[i]^= XorKey[i+4];
+	}
+	for (i=0; i<4; i++) {
+		data[i] = data[i+4]^tmp[i+4];
+		data[i+4] = tmp[i];
+	}
+	
+	des_set_key(KeyDes, ks1);
+	des_set_key(KeyDes+8, ks2);
+	
+	des(data, ks1, 0);
+	des(data, ks2, 1);
+	des(data, ks1, 0);
+	
+	for (i=0; i<4; i++) {
+		tmp[i] = data[i+4];
+	}
+	Via3Fct2(tmp, ident, XorKey, T1Key);
+	for (i=0; i<4; i++) {
+		tmp[i] = data[i]^tmp[i+4];
+	}
+	Via3Fct1(tmp, ident, XorKey, T1Key);
+	for (i=0; i<4; i++) {
+		tmp[i]^= XorKey[i];
+	}
+	for (i=0; i<4; i++) {
+		data[i] = data[i+4]^tmp[i+4];
+		data[i+4] = tmp[i];
+	}
+	return 0;
+}
+
+static void Via3FinalMix(uint8_t *dw)
+{
+	uint8_t tmp[4];
+
+	memcpy(tmp, dw, 4);
+	memcpy(dw, dw + 4, 4);
+	memcpy(dw + 4, tmp, 4);
+
+	memcpy(tmp, dw + 8, 4);
+	memcpy(dw + 8, dw + 12, 4);
+	memcpy(dw + 12, tmp, 4);
+}
+
+static int8_t Via3Decrypt(uint8_t* source, uint8_t* dw, uint32_t ident, uint8_t desKeyIndex, uint8_t aesKeyIndex, uint8_t aesMode, int8_t doFinalMix)
+{
+	int8_t aesAfterCore = 0;
+	int8_t needsAES = (aesKeyIndex != 0xFF);
+	uint8_t tmpData[8], C1[8];
+	uint8_t *pXorVector;
+	char aesKey[16];
+	int32_t i, j;
+
+	if(ident == 0) {
+		return 4;
+	}
+	if(!GetViaKey(C1, ident, 'C', 1, 8, 1)) {
+		return 2;
+	}
+	if(needsAES && !GetViaKey((uint8_t*)aesKey, ident, 'E', aesKeyIndex, 16, 1)) {
+		return 2;
+	}
+	if(aesMode==0x0D || aesMode==0x11 || aesMode==0x15) {
+		aesAfterCore = 1;
+	}
+
+	if(needsAES && !aesAfterCore) {
+		if(aesMode == 0x0F) {
+			hdSurEncPhase1_D2_0F_11(source);
+			hdSurEncPhase2_D2_0F_11(source);
+		}
+		else if(aesMode == 0x13) {
+			hdSurEncPhase1_D2_13_15(source);
+		}
+		struct aes_keys aes;
+		aes_set_key(&aes, aesKey);
+		aes_decrypt(&aes, source, 16);
+		if(aesMode == 0x0F) {
+			hdSurEncPhase1_D2_0F_11(source);
+		}
+		else if(aesMode == 0x13) {
+			hdSurEncPhase2_D2_13_15(source);
+		}
+	}
+
+	for(i=0; i<2; i++) {
+		memcpy(tmpData, source+i*8, 8);
+		Via3ProcessDw(tmpData, ident, desKeyIndex);
+		if (i!=0) {
+			pXorVector = source;
+		}
+		else {
+			pXorVector = &C1[0];
+		}
+		for (j=0; j<8; j++) {
+			dw[i*8+j] = tmpData[j]^pXorVector[j];
+		}
+	}
+
+	if(needsAES && aesAfterCore) {
+		if(aesMode == 0x11) {
+			hdSurEncPhase1_D2_0F_11(dw);
+			hdSurEncPhase2_D2_0F_11(dw);
+		}
+		else if(aesMode == 0x15) {
+			hdSurEncPhase1_D2_13_15(dw);
+		}
+		struct aes_keys aes;
+		aes_set_key(&aes, aesKey);
+		aes_decrypt(&aes, dw, 16);
+		if(aesMode == 0x11) {
+			hdSurEncPhase1_D2_0F_11(dw);
+		}
+		if(aesMode == 0x15) {
+			hdSurEncPhase2_D2_13_15(dw);
+		}
+	}
+
+	if(ident == 0x030B00) {
+		if(doFinalMix) {
+			Via3FinalMix(dw);
+		}
+		if(!isValidDCW(dw)) {
+			return 6;
+		}
+	}
+	return 0;
+}
+
+static int8_t ViaccessECM(uint8_t *ecm, uint8_t *dw)
+{
+	uint32_t currentIdent = 0;
+	uint8_t nanoCmd = 0, nanoLen = 0, version = 0, providerKeyLen = 0, desKeyIndex = 0, aesMode = 0, aesKeyIndex = 0xFF;
+	int8_t doFinalMix = 0, result = 1;
+	uint16_t i = 0, keySelectPos = 0, ecmLen = GetEcmLen(ecm);
+
+	for (i=4; i+2<ecmLen; ) {
+		nanoCmd = ecm[i++];
+		nanoLen = ecm[i++];
+		if(i+nanoLen > ecmLen) {
+			return 1;
+		}
+
+		switch (nanoCmd) {
+		case 0x40:
+			if (nanoLen < 0x03) {
+				break;
+			}
+			version = ecm[i];
+			if (nanoLen == 3) {
+				currentIdent=((ecm[i]<<16)|(ecm[i+1]<<8))|(ecm[i+2]&0xF0);
+				desKeyIndex = ecm[i+2]&0x0F;
+				keySelectPos = i+3;
+			}
+			else {
+				currentIdent =(ecm[i]<<16)|(ecm[i+1]<<8)|((ecm[i+2]>>4)&0x0F);
+				desKeyIndex = ecm[i+3];
+				keySelectPos = i+4;
+			}
+			providerKeyLen = nanoLen;
+			break;
+		case 0x90:
+			if (nanoLen < 0x03) {
+				break;
+			}
+			version = ecm[i];
+			currentIdent= ((ecm[i]<<16)|(ecm[i+1]<<8))|(ecm[i+2]&0xF0);
+			desKeyIndex = ecm[i+2]&0x0F;
+			keySelectPos = i+4;
+			if((version == 3) && (nanoLen > 3)) {
+				desKeyIndex = ecm[i+(nanoLen-4)]&0x0F;
+			}
+			providerKeyLen = nanoLen;
+			break;
+		case 0x80:
+			nanoLen = 0;
+			break;
+		case 0xD2:
+			if (nanoLen < 0x02) {
+				break;
+			}
+			aesMode = ecm[i];
+			aesKeyIndex = ecm[i+1];
+			break;
+		case 0xDD:
+			nanoLen = 0;
+			break;
+		case 0xEA:
+			if (nanoLen < 0x10) {
+				break;
+			}
+
+			if (version < 2) {
+				return Via1Decrypt(ecm, dw, currentIdent, desKeyIndex);
+			}
+			else if (version == 2) {
+				return Via26Decrypt(ecm + i, dw, currentIdent, desKeyIndex);
+			}
+			else if (version == 3) {
+				doFinalMix = 0;
+				if (currentIdent == 0x030B00 && providerKeyLen>3) {
+					if(keySelectPos+2 >= ecmLen) {
+						break;
+					}
+					if (ecm[keySelectPos]==0x05 && ecm[keySelectPos+1]==0x67 && (ecm[keySelectPos+2]==0x00 || ecm[keySelectPos+2]==0x01)) {
+						if(ecm[keySelectPos+2]==0x01) {
+							doFinalMix = 1;
+						}
+					}
+					else {
+						break;
+					}
+				}
+				return Via3Decrypt(ecm + i, dw, currentIdent, desKeyIndex, aesKeyIndex, aesMode, doFinalMix);
+			}
+			break;
+		default:
+			break;
+		}
+		i += nanoLen;
+	}
+	return result;
+}
+
+// Nagra EMU
+static int8_t GetNagraKey(uint8_t *buf, uint32_t ident, char keyName, uint32_t keyIndex, uint8_t isCriticalKey)
+{
+	char keyStr[EMU_MAX_CHAR_KEYNAME];
+	snprintf(keyStr, EMU_MAX_CHAR_KEYNAME, "%c%X", keyName, keyIndex);
+	if(FindKey('N', ident, keyStr, buf, keyName == 'M' ? 64 : 16, isCriticalKey, 0, 0, NULL)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+static int8_t Nagra2Signature(const uint8_t *vkey, const uint8_t *sig, const uint8_t *msg, int32_t len)
+{
+	uint8_t buff[16];
+	uint8_t iv[8];
+	int32_t i,j;
+
+	memcpy(buff,vkey,sizeof(buff));
+	for(i=0; i+7<len; i+=8) {
+		IDEA_KEY_SCHEDULE ek;
+		idea_set_encrypt_key(buff, &ek);
+		memcpy(buff,buff+8,8);
+		memset(iv,0,sizeof(iv));
+		idea_cbc_encrypt(msg+i,buff+8,8,&ek,iv,IDEA_ENCRYPT);
+		for(j=7; j>=0; j--) {
+			buff[j+8]^=msg[i+j];
+		}
+	}
+	buff[8]&=0x7F;
+	return (memcmp(sig,buff+8,8)==0);
+}
+
+static int8_t DecryptNagra2ECM(uint8_t *in, uint8_t *out, const uint8_t *key, int32_t len, const uint8_t *vkey, uint8_t *keyM)
+{
+	BIGNUM *exp, *mod;
+	uint8_t iv[8];
+	int32_t i = 0, sign = in[0] & 0x80;
+	uint8_t binExp = 3;
+	int8_t result = 1;
+
+	exp = BN_new();
+	mod = BN_new();
+	BN_bin2bn(&binExp, 1, exp);
+	BN_bin2bn(keyM, 64, mod);
+
+	if(EmuRSA(out,in+1,64,exp,mod,1)<=0) {
+		BN_free(exp);
+		BN_free(mod);
+		return 0;
+	}
+	out[63]|=sign;
+	if(len>64) {
+		memcpy(out+64,in+65,len-64);
+	}
+
+	memset(iv,0,sizeof(iv));
+	if(in[0]&0x04) {
+		uint8_t key1[8], key2[8];
+		ReverseMemInOut(key1,&key[0],8);
+		ReverseMemInOut(key2,&key[8],8);
+
+		for(i=7; i>=0; i--) {
+			ReverseMem(out+8*i,8);
+		}
+		des_ede2_cbc_decrypt(out, iv, key1, key2, len);
+		for(i=7; i>=0; i--) {
+			ReverseMem(out+8*i,8);
+		}
+	}
+	else {
+		IDEA_KEY_SCHEDULE ek;
+		idea_set_encrypt_key(key, &ek);
+		idea_cbc_encrypt(out, out, len&~7, &ek, iv, IDEA_DECRYPT);
+	}
+
+	ReverseMem(out,64);
+	if(result && EmuRSA(out,out,64,exp,mod,0)<=0) {
+		result = 0;
+	}
+	if(result && vkey && !Nagra2Signature(vkey,out,out+8,len-8)) {
+		result = 0;
+	}
+
+	BN_free(exp);
+	BN_free(mod);
+	return result;
+}
+
+static int8_t Nagra2ECM(uint8_t *ecm, uint8_t *dw)
+{
+	uint32_t ident, identMask, tmp1, tmp2, tmp3;
+	uint8_t cmdLen, ideaKeyNr, *dec, ideaKey[16], vKey[16], m1Key[64], mecmAlgo = 0;
+	int8_t useVerifyKey = 0;
+	int32_t l=0, s;
+	uint16_t i = 0, ecmLen = GetEcmLen(ecm);
+
+	if(ecmLen < 8) {
+		return 1;
+	}
+	cmdLen = ecm[4] - 5;
+	ident = (ecm[5] << 8) + ecm[6];
+	ideaKeyNr = (ecm[7]&0x10)>>4;
+	if(ideaKeyNr) {
+		ideaKeyNr = 1;
+	}
+	if(ident == 1283 || ident == 1285 || ident == 1297) {
+		ident = 1281;
+	}
+	if(cmdLen <= 63 || ecmLen < cmdLen + 10) {
+		return 1;
+	}
+
+	if(!GetNagraKey(ideaKey, ident, '0', ideaKeyNr, 1)) {
+		return 2;
+	}
+	if(GetNagraKey(vKey, ident, 'V', 0, 0)) {
+		useVerifyKey = 1;
+	}
+	if(!GetNagraKey(m1Key, ident, 'M', 1, 1)) {
+		return 2;
+	}
+	ReverseMem(m1Key, 64);
+
+	dec = (uint8_t*)malloc(sizeof(uint8_t)*cmdLen);
+	if(dec == NULL) {
+		return 7;
+	}
+	if(!DecryptNagra2ECM(ecm+9, dec, ideaKey, cmdLen, useVerifyKey?vKey:0, m1Key)) {
+		free(dec);
+		return 1;
+	}
+
+	for(i=(dec[14]&0x10)?16:20; i<cmdLen && l!=3; ) {
+		switch(dec[i]) {
+		case 0x10:
+		case 0x11:
+			if(i+10 < cmdLen && dec[i+1]==0x09) {
+				s = (~dec[i])&1;
+				mecmAlgo = dec[i+2]&0x60;
+				memcpy(dw+(s<<3),&dec[i+3],8);
+				i+=11;
+				l|=(s+1);
+			}
+			else {
+				i++;
+			}
+			break;
+		case 0x00:
+			i+=2;
+			break;
+		case 0x30:
+		case 0x31:
+		case 0x32:
+		case 0x33:
+		case 0x34:
+		case 0x35:
+		case 0x36:
+		case 0xB0:
+			if(i+1 < cmdLen) {
+				i+=dec[i+1]+2;
+			}
+			else {
+				i++;
+			}
+			break;
+		default:
+			i++;
+			continue;
+		}
+	}
+
+	free(dec);
+
+	if(l!=3) {
+		return 1;
+	}
+	if(mecmAlgo>0) {
+		return 1;
+	}
+
+	identMask = ident & 0xFF00;
+	if (identMask == 0x1100 || identMask == 0x500 || identMask == 0x3100) {
+		memcpy(&tmp1, dw, 4);
+		memcpy(&tmp2, dw + 4, 4);
+		memcpy(&tmp3, dw + 12, 4);
+		memcpy(dw, dw + 8, 4);
+		memcpy(dw + 4, &tmp3, 4);
+		memcpy(dw + 8, &tmp1, 4);
+		memcpy(dw + 12, &tmp2, 4);
+	}
+	return 0;
+}
+
+// Irdeto EMU
+static int8_t GetIrdetoKey(uint8_t *buf, uint32_t ident, char keyName, uint32_t keyIndex, uint8_t isCriticalKey, uint8_t *keyRef)
+{
+	char keyStr[EMU_MAX_CHAR_KEYNAME];
+	snprintf(keyStr, EMU_MAX_CHAR_KEYNAME, "%c%X", keyName, keyIndex);
+	if(FindKey('I', ident, keyStr, buf, 16, *keyRef > 0 ? 0 : isCriticalKey, *keyRef, 0, NULL)) {
+		(*keyRef)++;
+		return 1;
+	}
+
+	return 0;
+}
+
+static void Irdeto2Encrypt(uint8_t *data, const uint8_t *seed, const uint8_t *key, int32_t len)
+{
+	const uint8_t *tmp = seed;;
+	int32_t i;
+	uint32_t ks1[32], ks2[32];
+
+	des_set_key(key, ks1);
+	des_set_key(key+8, ks2);
+	
+	len&=~7;
+
+	for(i=0; i+7<len; i+=8) {
+		xxor(&data[i],8,&data[i],tmp);
+		tmp=&data[i];	
+		des(&data[i], ks1, 1);
+		des(&data[i], ks2, 0);
+		des(&data[i], ks1, 1);
+	}
+}
+
+static void Irdeto2Decrypt(uint8_t *data, const uint8_t *seed, const uint8_t *key, int32_t len)
+{
+	uint8_t buf[2][8];
+	int32_t i, n=0;
+	uint32_t ks1[32], ks2[32];
+	
+	des_set_key(key, ks1);
+	des_set_key(key+8, ks2);
+	
+	len&=~7;
+
+	memcpy(buf[n],seed,8);
+	for(i=0; i+7<len; i+=8,data+=8,n^=1) {
+		memcpy(buf[1-n],data,8);
+		des(data, ks1, 0);
+		des(data, ks2, 1);	
+		des(data, ks1, 0);	
+		xxor(data,8,data,buf[n]);
+	}
+}
+
+static int8_t Irdeto2CalculateHash(const uint8_t *key, const uint8_t *iv, const uint8_t *data, int32_t len)
+{
+	uint8_t cbuff[8];
+	int32_t l, y;
+	uint32_t ks1[32], ks2[32];
+	
+	des_set_key(key, ks1);
+	des_set_key(key+8, ks2);
+	
+	memset(cbuff,0,sizeof(cbuff));
+	len-=8;
+
+	for(y=0; y<len; y+=8) {
+		if(y<len-8) {
+			xxor(cbuff,8,cbuff,&data[y]);
+		}
+		else {
+			l=len-y;
+			xxor(cbuff,l,cbuff,&data[y]);
+			xxor(cbuff+l,8-l,cbuff+l,iv+8);
+		}
+		
+		des(cbuff, ks1, 1);
+		des(cbuff, ks2, 0);
+		des(cbuff, ks1, 1);
+	}
+
+	return memcmp(cbuff,&data[len],8)==0;
+}
+
+static int8_t Irdeto2ECM(uint16_t caid, uint8_t *oecm, uint8_t *dw)
+{
+	uint8_t keyNr=0, length, end, key[16], okeySeed[16], keySeed[16], keyIV[16], tmp[16];
+	uint32_t i, l, ident;
+	uint8_t key0Ref, keySeedRef, keyIVRef;
+	uint8_t ecmCopy[EMU_MAX_ECM_LEN], *ecm = oecm;
+	uint16_t ecmLen = GetEcmLen(ecm);
+
+	if(ecmLen < 12) {
+		return 1;
+	}
+
+	length = ecm[11];
+	keyNr = ecm[9];
+	ident = ecm[8] | caid << 8;
+
+	if(ecmLen < length+12) {
+		return 1;
+	}
+
+	key0Ref = 0;
+	while(GetIrdetoKey(key, ident, '0', keyNr, 1, &key0Ref)) {
+		keySeedRef = 0;
+		while(GetIrdetoKey(okeySeed, ident, 'M', 1, 1, &keySeedRef)) {
+			keyIVRef = 0;
+			while(GetIrdetoKey(keyIV, ident, 'M', 2, 1, &keyIVRef)) {
+
+				memcpy(keySeed, okeySeed, 16);
+				memcpy(ecmCopy, oecm, ecmLen);
+				ecm = ecmCopy;
+
+				memset(tmp, 0, 16);
+				Irdeto2Encrypt(keySeed, tmp, key, 16);
+				ecm+=12;
+				Irdeto2Decrypt(ecm, keyIV, keySeed, length);
+				i=(ecm[0]&7)+1;
+				end = length-8 < 0 ? 0 : length-8;
+
+				while(i<end) {
+					l = ecm[i+1] ? (ecm[i+1]&0x3F)+2 : 1;
+					switch(ecm[i]) {
+					case 0x10:
+					case 0x50:
+						if(l==0x13 && i<=length-8-l) {
+							Irdeto2Decrypt(&ecm[i+3], keyIV, key, 16);
+						}
+						break;
+					case 0x78:
+						if(l==0x14 && i<=length-8-l) {
+							Irdeto2Decrypt(&ecm[i+4], keyIV, key, 16);
+						}
+						break;
+					}
+					i+=l;
+				}
+
+				i=(ecm[0]&7)+1;
+				if(Irdeto2CalculateHash(keySeed, keyIV, ecm-6, length+6)) {
+					while(i<end) {
+						l = ecm[i+1] ? (ecm[i+1]&0x3F)+2 : 1;
+						switch(ecm[i]) {
+						case 0x78:
+							if(l==0x14 && i<=length-8-l) {
+								memcpy(dw, &ecm[i+4], 16);
+								return 0;
+							}
+						}
+						i+=l;
+					}
+				}
+			}
+			if(keyIVRef == 0) {
+				return 2;
+			}
+		}
+		if(keySeedRef == 0) {
+			return 2;
+		}
+	}
+	if(key0Ref == 0) {
+		return 2;
+	}
+
+	return 1;
+}
+
+// BISS Emu
+static int8_t BissECM(uint16_t UNUSED(caid), const uint8_t *ecm, int16_t ecmDataLen,
+					  uint8_t *dw, uint16_t srvid, uint16_t ecmpid)
+{
+	uint8_t haveKey1 = 0, haveKey2 = 0;
+	uint16_t ecmLen = 0, pid = 0;
+	uint32_t i;
+
+	//try using ecmpid if it seems to be valid
+	if(ecmpid != 0) {
+		haveKey1 = FindKey('F', (srvid<<16)|ecmpid, "00", dw, 8, 1, 0, 0, NULL);
+		haveKey2 = FindKey('F', (srvid<<16)|ecmpid, "01", &dw[8], 8, 1, 0, 0, NULL);
+
+		if(haveKey1 && haveKey2) {return 0;}
+		else if(haveKey1 && !haveKey2) {memcpy(&dw[8], dw, 8); return 0;}
+		else if(!haveKey1 && haveKey2) {memcpy(dw, &dw[8], 8); return 0;}
+	}
+
+	//try to get the pid from oscam's fake ecm ([sid] ([pid1] [pid2] ... [pidx])
+	if(ecmDataLen >= 3) {
+		ecmLen = GetEcmLen(ecm);
+
+		if(ecmLen > 7 && ecmLen <= ecmDataLen) {
+			for(i=5; i+1<ecmLen; i+=2) {
+				pid = b2i(2, ecm+i);
+				haveKey1 = FindKey('F', (srvid<<16)|pid, "00", dw, 8, 1, 0, 0, NULL);
+				haveKey2 = FindKey('F', (srvid<<16)|pid, "01", &dw[8], 8, 1, 0, 0, NULL);
+
+				if(haveKey1 && haveKey2) {return 0;}
+				else if(haveKey1 && !haveKey2) {memcpy(&dw[8], dw, 8); return 0;}
+				else if(!haveKey1 && haveKey2) {memcpy(dw, &dw[8], 8); return 0;}
+			}
+		}
+	}
+
+	//fallback to default pid
+	haveKey1 = FindKey('F', (srvid<<16)|0x1FFF, "00", dw, 8, 1, 0, 0, NULL);
+	haveKey2 = FindKey('F', (srvid<<16)|0x1FFF, "01", &dw[8], 8, 1, 0, 0, NULL);
+
+	if(haveKey1 && haveKey2) {return 0;}
+	else if(haveKey1 && !haveKey2) {memcpy(&dw[8], dw, 8); return 0;}
+	else if(!haveKey1 && haveKey2) {memcpy(dw, &dw[8], 8); return 0;}
+
+	return 2;
+}
+
+//PowerVu Emu
+static int8_t GetPowervuKey(uint8_t *buf, uint32_t ident, char keyName, uint32_t keyIndex, uint32_t keyLength, uint8_t isCriticalKey)
+{
+	char keyStr[EMU_MAX_CHAR_KEYNAME];
+	snprintf(keyStr, EMU_MAX_CHAR_KEYNAME, "%c%X", keyName, keyIndex);
+	if(FindKey('P', ident, keyStr, buf, keyLength, isCriticalKey, 0, 0, NULL)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+static int8_t GetPowervuEmmKey(uint8_t *buf, uint32_t ident, char *keyName, uint32_t keyLength, uint8_t isCriticalKey, uint32_t *getProvider)
+{
+	if(FindKey('P', ident, keyName, buf, keyLength, isCriticalKey, 0, 0, getProvider)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+static const uint8_t PowerVu_A0_S_1[16] = {0x33, 0xA4, 0x44, 0x3C, 0xCA, 0x2E, 0x75, 0x7B, 0xBC, 0xE6, 0xE5, 0x35, 0xA0, 0x55, 0xC9, 0xA2};
+static const uint8_t PowerVu_A0_S_2[16] = {0x5A, 0xB0, 0x2C, 0xBC, 0xDA, 0x32, 0xE6, 0x92, 0x40, 0x53, 0x6E, 0xF9, 0x69, 0x11, 0x1E, 0xFB};
+static const uint8_t PowerVu_A0_S_3[16] = {0x4E, 0x18, 0x9B, 0x19, 0x79, 0xFB, 0x01, 0xFA, 0xE3, 0xE1, 0x28, 0x3D, 0x32, 0xE4, 0x92, 0xEA};
+static const uint8_t PowerVu_A0_S_4[16] = {0x05, 0x6F, 0x37, 0x66, 0x35, 0xE1, 0x58, 0xD0, 0xB4, 0x6A, 0x97, 0xAE, 0xD8, 0x91, 0x27, 0x56};
+static const uint8_t PowerVu_A0_S_5[16] = {0x7B, 0x26, 0xAD, 0x34, 0x3D, 0x77, 0x39, 0x51, 0xE0, 0xE0, 0x48, 0x8C, 0x39, 0xF5, 0xE8, 0x47};
+static const uint8_t PowerVu_A0_S_6[16] = {0x74, 0xFA, 0x4D, 0x79, 0x42, 0x39, 0xD1, 0xA4, 0x99, 0xA3, 0x97, 0x07, 0xDF, 0x14, 0x3A, 0xC4};
+static const uint8_t PowerVu_A0_S_7[16] = {0xC6, 0x1E, 0x3C, 0x24, 0x11, 0x08, 0x5D, 0x6A, 0xEB, 0x97, 0xB9, 0x25, 0xA7, 0xFA, 0xE9, 0x1A};
+static const uint8_t PowerVu_A0_S_8[16] = {0x9A, 0xAD, 0x72, 0xD7, 0x7C, 0x68, 0x3B, 0x55, 0x1D, 0x4A, 0xA2, 0xB0, 0x38, 0xB9, 0x56, 0xD0};
+static const uint8_t PowerVu_A0_S_9[32] = {0x61, 0xDA, 0x5F, 0xB7, 0xEB, 0xC6, 0x3F, 0x6C, 0x09, 0xF3, 0x64, 0x38, 0x33, 0x08, 0xAA, 0x15,
+										   0xCC, 0xEF, 0x22, 0x64, 0x01, 0x2C, 0x12, 0xDE, 0xF4, 0x6E, 0x3C, 0xCD, 0x1A, 0x64, 0x63, 0x7C
+										  };
+
+static const uint8_t PowerVu_00_S_1[16] = {0x97, 0x13, 0xEB, 0x6B, 0x04, 0x5E, 0x60, 0x3A, 0xD9, 0xCC, 0x91, 0xC2, 0x5A, 0xFD, 0xBA, 0x0C};
+static const uint8_t PowerVu_00_S_2[16] = {0x61, 0x3C, 0x03, 0xB0, 0xB5, 0x6F, 0xF8, 0x01, 0xED, 0xE0, 0xE5, 0xF3, 0x78, 0x0F, 0x0A, 0x73};
+static const uint8_t PowerVu_00_S_3[16] = {0xFD, 0xDF, 0xD2, 0x97, 0x06, 0x14, 0x91, 0xB5, 0x36, 0xAD, 0xBC, 0xE1, 0xB3, 0x00, 0x66, 0x41};
+static const uint8_t PowerVu_00_S_4[16] = {0x8B, 0xD9, 0x18, 0x0A, 0xED, 0xEE, 0x61, 0x34, 0x1A, 0x79, 0x80, 0x8C, 0x1E, 0x7F, 0xC5, 0x9F};
+static const uint8_t PowerVu_00_S_5[16] = {0xB0, 0xA1, 0xF2, 0xB8, 0xEA, 0x72, 0xDD, 0xD3, 0x30, 0x65, 0x2B, 0x1E, 0xE9, 0xE1, 0x45, 0x29};
+static const uint8_t PowerVu_00_S_6[16] = {0x5D, 0xCA, 0x53, 0x75, 0xB2, 0x24, 0xCE, 0xAF, 0x21, 0x54, 0x9E, 0xBE, 0x02, 0xA9, 0x4C, 0x5D};
+static const uint8_t PowerVu_00_S_7[16] = {0x42, 0x66, 0x72, 0x83, 0x1B, 0x2D, 0x22, 0xC9, 0xF8, 0x4D, 0xBA, 0xCD, 0xBB, 0x20, 0xBD, 0x6B};
+static const uint8_t PowerVu_00_S_8[16] = {0xC4, 0x0C, 0x6B, 0xD3, 0x6D, 0x94, 0x7E, 0x53, 0xCE, 0x96, 0xAC, 0x40, 0x2C, 0x7A, 0xD3, 0xA9};
+static const uint8_t PowerVu_00_S_9[32] = {0x31, 0x82, 0x4F, 0x9B, 0xCB, 0x6F, 0x9D, 0xB7, 0xAE, 0x68, 0x0B, 0xA0, 0x93, 0x15, 0x32, 0xE2,
+										   0xED, 0xE9, 0x47, 0x29, 0xC2, 0xA8, 0x92, 0xEF, 0xBA, 0x27, 0x22, 0x57, 0x76, 0x54, 0xC0, 0x59,
+										  };
+
+static uint8_t PowervuSbox(uint8_t *input, uint8_t mode)
+{
+	uint8_t s_index, bit, last_index, last_bit;
+	uint8_t const *Sbox1, *Sbox2, *Sbox3, *Sbox4, *Sbox5, *Sbox6, *Sbox7, *Sbox8, *Sbox9;
+
+	if(mode == 0xA0)
+	{
+		Sbox1 = PowerVu_A0_S_1;
+		Sbox2 = PowerVu_A0_S_2;
+		Sbox3 = PowerVu_A0_S_3;
+		Sbox4 = PowerVu_A0_S_4;
+		Sbox5 = PowerVu_A0_S_5;
+		Sbox6 = PowerVu_A0_S_6;
+		Sbox7 = PowerVu_A0_S_7;
+		Sbox8 = PowerVu_A0_S_8;
+		Sbox9 = PowerVu_A0_S_9;
+	}
+	else
+	{
+		Sbox1 = PowerVu_00_S_1;
+		Sbox2 = PowerVu_00_S_2;
+		Sbox3 = PowerVu_00_S_3;
+		Sbox4 = PowerVu_00_S_4;
+		Sbox5 = PowerVu_00_S_5;
+		Sbox6 = PowerVu_00_S_6;
+		Sbox7 = PowerVu_00_S_7;
+		Sbox8 = PowerVu_00_S_8;
+		Sbox9 = PowerVu_00_S_9;
+	}
+
+	bit = (GetBit(input[2],0)<<2) | (GetBit(input[3],4)<<1) | (GetBit(input[5],3));
+	s_index = (GetBit(input[0],0)<<3) | (GetBit(input[2],6)<<2) | (GetBit(input[2],4)<<1) | (GetBit(input[5],7));
+	last_bit = GetBit(Sbox1[s_index],7-bit);
+
+	bit = (GetBit(input[5],0)<<2) | (GetBit(input[4],0)<<1) | (GetBit(input[6],2));
+	s_index = (GetBit(input[2],1)<<3) | (GetBit(input[2],2)<<2) | (GetBit(input[5],5)<<1) | (GetBit(input[5],1));
+	last_bit = last_bit | (GetBit(Sbox2[s_index],7-bit)<<1);
+
+	bit = (GetBit(input[6],0)<<2) | (GetBit(input[1],7)<<1) | (GetBit(input[6],7));
+	s_index = (GetBit(input[1],3)<<3) | (GetBit(input[3],7)<<2) | (GetBit(input[1],5)<<1) | (GetBit(input[5],2));
+	last_bit = last_bit | (GetBit(Sbox3[s_index], 7-bit)<<2);
+
+	bit = (GetBit(input[1],0)<<2) | (GetBit(input[2],7)<<1) | (GetBit(input[2],5));
+	s_index = (GetBit(input[6],3)<<3) | (GetBit(input[6],4)<<2) | (GetBit(input[6],6)<<1) | (GetBit(input[3],5));
+	last_index = GetBit(Sbox4[s_index], 7-bit);
+
+	bit = (GetBit(input[3],3)<<2) | (GetBit(input[4],6)<<1) | (GetBit(input[3],2));
+	s_index = (GetBit(input[3],1)<<3) | (GetBit(input[4],5)<<2) | (GetBit(input[3],0)<<1) | (GetBit(input[4],7));
+	last_index = last_index | (GetBit(Sbox5[s_index], 7-bit)<<1);
+
+	bit = (GetBit(input[5],4)<<2) | (GetBit(input[4],4)<<1) | (GetBit(input[1],2));
+	s_index = (GetBit(input[2],3)<<3) | (GetBit(input[6],5)<<2) | (GetBit(input[1],4)<<1) | (GetBit(input[4],1));
+	last_index = last_index | (GetBit(Sbox6[s_index], 7-bit)<<2);
+
+	bit = (GetBit(input[0],6)<<2) | (GetBit(input[0],7)<<1) | (GetBit(input[0],4));
+	s_index = (GetBit(input[0],5)<<3) | (GetBit(input[0],3)<<2) | (GetBit(input[0],1)<<1) | (GetBit(input[0],2));
+	last_index = last_index | (GetBit(Sbox7[s_index], 7-bit)<<3);
+
+	bit = (GetBit(input[4],2)<<2) | (GetBit(input[4],3)<<1) | (GetBit(input[1],1));
+	s_index = (GetBit(input[1],6)<<3) | (GetBit(input[6],1)<<2) | (GetBit(input[5],6)<<1) | (GetBit(input[3],6));
+	last_index = last_index | (GetBit(Sbox8[s_index], 7-bit)<<4);
+
+	return (GetBit(Sbox9[last_index&0x1f],7-last_bit)&1) ? 1: 0;
+}
+
+static void PowervuDecrypt(uint8_t *data, uint32_t length, uint8_t *key)
+{
+	uint32_t i;
+	int32_t j, k;
+	uint8_t curByte, tmpBit;
+
+	for(i=0; i<length; i++)
+	{
+		curByte = data[i];
+
+		for(j=7; j>=0; j--)
+		{
+			data[i] = SetBit(data[i], j,(GetBit(curByte,j)^PowervuSbox(key, 0))^GetBit(key[0],7));
+
+			tmpBit = GetBit(data[i],j)^(GetBit(key[6],0));
+			if (tmpBit)
+			{
+				key[3] ^= 0x10;
+			}
+
+			for (k = 6; k > 0; k--)
+			{
+				key[k] = (key[k]>>1) | (key[k-1]<<7);
+			}
+			key[0] = (key[0]>>1);
+
+			key[0] = SetBit(key[0], 7, tmpBit);
+		}
+	}
+}
+
+#define PVU_CW_VID 0	// VIDeo
+#define PVU_CW_HSD 1	// High Speed Data
+#define PVU_CW_A1 2		// Audio 1
+#define PVU_CW_A2 3		// Audio 2
+#define PVU_CW_A3 4		// Audio 3
+#define PVU_CW_A4 5		// Audio 4
+#define PVU_CW_UTL 6	// UTiLity
+#define PVU_CW_VBI 7	// Vertical Blanking Interval
+
+#define PVU_CONVCW_VID_ECM 0x80	// VIDeo
+#define PVU_CONVCW_HSD_ECM 0x40 // High Speed Data
+#define PVU_CONVCW_A1_ECM 0x20	// Audio 1
+#define PVU_CONVCW_A2_ECM 0x10	// Audio 2
+#define PVU_CONVCW_A3_ECM 0x08	// Audio 3
+#define PVU_CONVCW_A4_ECM 0x04	// Audio 4
+#define PVU_CONVCW_UTL_ECM 0x02	// UTiLity
+#define PVU_CONVCW_VBI_ECM 0x01	// Vertical Blanking Interval
+
+static uint8_t PowervuGetConvcwIndex(uint8_t ecmTag)
+{
+	switch(ecmTag)
+	{
+	case PVU_CONVCW_VID_ECM:
+		return PVU_CW_VID;
+
+	case PVU_CONVCW_HSD_ECM:
+		return PVU_CW_HSD;
+
+	case PVU_CONVCW_A1_ECM:
+		return PVU_CW_A1;
+
+	case PVU_CONVCW_A2_ECM:
+		return PVU_CW_A2;
+
+	case PVU_CONVCW_A3_ECM:
+		return PVU_CW_A3;
+
+	case PVU_CONVCW_A4_ECM:
+		return PVU_CW_A4;
+
+	case PVU_CONVCW_UTL_ECM:
+		return PVU_CW_UTL;
+
+	case PVU_CONVCW_VBI_ECM:
+		return PVU_CW_VBI;
+
+	default:
+		return PVU_CW_VBI;
+	}
+}
+
+static uint16_t PowervuGetSeedIV(uint8_t seedType, uint8_t *ecm)
+{
+	switch(seedType)
+	{
+	case PVU_CW_VID:
+		return ((ecm[0x10] & 0x1F) <<3) | 0;
+	case PVU_CW_HSD:
+		return ((ecm[0x12] & 0x1F) <<3) | 2;
+	case PVU_CW_A1:
+		return ((ecm[0x11] & 0x3F) <<3) | 1;
+	case PVU_CW_A2:
+		return ((ecm[0x13] & 0x3F) <<3) | 1;
+	case PVU_CW_A3:
+		return ((ecm[0x19] & 0x3F) <<3) | 1;
+	case PVU_CW_A4:
+		return ((ecm[0x1A] & 0x3F) <<3) | 1;;
+	case PVU_CW_UTL:
+		return ((ecm[0x14] & 0x0F) <<3) | 4;
+	case PVU_CW_VBI:
+		return (((ecm[0x15] & 0xF8)>>3)<<3) | 5;
+	default:
+		return 0;
+	}
+}
+
+static void PowervuExpandSeed(uint8_t seedType, uint8_t *seed)
+{
+	uint8_t seedLength, i;
+
+	switch(seedType)
+	{
+	case PVU_CW_VID:
+	case PVU_CW_HSD:
+		seedLength = 4;
+		break;
+	case PVU_CW_A1:
+	case PVU_CW_A2:
+	case PVU_CW_A3:
+	case PVU_CW_A4:
+		seedLength = 3;
+		break;
+	case PVU_CW_UTL:
+	case PVU_CW_VBI:
+		seedLength = 2;
+		break;
+	default:
+		return;
+	}
+
+	for(i=seedLength; i<7; i++)
+	{
+		seed[i] = seed[i%seedLength];
+	}
+}
+
+static void PowervuCalculateSeed(uint8_t seedType, uint8_t *ecm, uint8_t *seedBase, uint8_t *key, uint8_t *seed)
+{
+	uint16_t tmpSeed;
+
+	tmpSeed = PowervuGetSeedIV(seedType, ecm+23);
+	seed[0] = (tmpSeed>>2) & 0xFF;
+	seed[1] = ((tmpSeed&0x3)<<6) | (seedBase[0]>>2);
+	seed[2] = (seedBase[0]<<6) | (seedBase[1]>>2);
+	seed[3] = (seedBase[1]<<6) | (seedBase[2]>>2);
+	seed[4] = (seedBase[2]<<6) | (seedBase[3]>>2);
+	seed[5] = (seedBase[3]<<6);
+
+	PowervuDecrypt(seed, 6, key);
+
+	seed[0] = (seed[1]<<2) | (seed[2]>>6);
+	seed[1] = (seed[2]<<2) | (seed[3]>>6);
+	seed[2] = (seed[3]<<2) | (seed[4]>>6);
+	seed[3] = (seed[4]<<2) | (seed[5]>>6);
+}
+
+static void PowervuCalculateCw(uint8_t seedType, uint8_t *seed, uint8_t csaUsed,
+							   uint8_t *convolvedCw, uint8_t *cw, uint8_t *baseCw)
+{
+	int32_t k;
+
+	PowervuExpandSeed(seedType, seed);
+
+	if(csaUsed)
+	{
+		for(k=0; k<7; k++)
+		{
+			seed[k] ^= baseCw[k];
+		}
+		
+		cw[0] = seed[0] ^ convolvedCw[0];
+		cw[1] = seed[1] ^ convolvedCw[1];
+		cw[2] = seed[2] ^ convolvedCw[2];
+		cw[3] = seed[3] ^ convolvedCw[3];
+		cw[4] = seed[3] ^ convolvedCw[4];
+		cw[5] = seed[4] ^ convolvedCw[5];
+		cw[6] = seed[5] ^ convolvedCw[6];
+		cw[7] = seed[6] ^ convolvedCw[7];
+	}
+	else
+	{
+		for(k=0; k<7; k++)
+		{
+			cw[k] = seed[k] ^ baseCw[k];
+		}
+		ExpandDesKey(cw);
+	}
+}
+
+int8_t PowervuECM(uint8_t *ecm, uint8_t *dw, emu_stream_client_data *cdata, int8_t global_cdata)
+{
+	uint16_t ecmLen = GetEcmLen(ecm);
+	uint32_t ecmCrc32;
+	uint8_t nanoCmd, nanoChecksum, keyType, fixedKey, oddKey, bid, keyIndex, csaUsed;
+	uint16_t nanoLen, channelId;
+	uint32_t i, j, k;
+	uint8_t convolvedCw[8][8];
+	uint8_t ecmKey[7], tmpEcmKey[7], seedBase[4], baseCw[7], seed[8][8], cw[8][8];
+#ifdef WITH_EMU
+	emu_stream_cw_item *cw_item;
+#endif
+
+	if(ecmLen < 7)
+	{
+		return 1;
+	}
+
+	ecmCrc32 = b2i(4, ecm+ecmLen-4);
+
+	if(fletcher_crc32(ecm, ecmLen-4) != ecmCrc32)
+	{
+		return 8;
+	}
+	ecmLen -= 4;
+
+	for(i=0; i<8; i++) {
+		memset(convolvedCw[i], 0, 8);
+	}
+	
+	for(i=3; i+3<ecmLen; ) {
+		nanoLen = (((ecm[i] & 0x0f)<< 8) | ecm[i+1]);
+		i +=2;
+		if(nanoLen > 0)
+		{
+			nanoLen--;
+		}
+		nanoCmd = ecm[i++];
+		if(i+nanoLen > ecmLen) {
+			return 1;
+		}
+
+		switch (nanoCmd) {
+		case 0x27:
+			if(nanoLen < 15)
+			{
+				break;
+			}
+
+			nanoChecksum = 0;
+			for(j=4; j<15; j++)
+			{
+				nanoChecksum += ecm[i+j];
+			}
+
+			if(nanoChecksum != 0)
+			{
+				break;
+			}
+
+			keyType = PowervuGetConvcwIndex(ecm[i+4]);
+			memcpy(convolvedCw[keyType], &ecm[i+6], 8);
+			break;
+
+		default:
+			break;
+		}
+		i += nanoLen;
+	}
+
+	for(i=3; i+3<ecmLen; ) {
+		nanoLen = (((ecm[i] & 0x0f)<< 8) | ecm[i+1]);
+		i +=2;
+		if(nanoLen > 0)
+		{
+			nanoLen--;
+		}
+		nanoCmd = ecm[i++];
+		if(i+nanoLen > ecmLen) {
+			return 1;
+		}
+
+		switch (nanoCmd) {
+		case 0x20:
+			if(nanoLen < 54)
+			{
+				break;
+			}
+
+			csaUsed = GetBit(ecm[i+7], 7);
+			fixedKey = !GetBit(ecm[i+6], 5);
+			oddKey = GetBit(ecm[i+6], 4);
+			bid = (GetBit(ecm[i+7], 1)<<1) | GetBit(ecm[i+7], 0);
+
+			keyIndex = (fixedKey<<3) | (bid<<2) | oddKey;
+			channelId = b2i(2, ecm+i+23);
+			if(!GetPowervuKey(ecmKey, channelId, '0', keyIndex, 7, 1))
+			{
+				break;
+			}
+
+			PowervuDecrypt(ecm+i+8, 14, ecmKey);
+			if((ecm[i+6] != ecm[i+6+7]) || (ecm[i+6+8] != ecm[i+6+15]))
+			{
+				break;
+			}
+			memcpy(tmpEcmKey, ecmKey, 7);
+
+			PowervuDecrypt(ecm+i+27, 27, ecmKey);
+			if((ecm[i+23] != ecm[i+23+29]) || (ecm[i+23+1] != ecm[i+23+30]))
+			{
+				break;
+			}
+
+			memcpy(seedBase, ecm+i+6+2, 4);
+						
+			if(cdata != NULL || global_cdata)
+			{
+				// Calculate all seeds
+				for(j=0; j<8; j++)
+				{
+					memcpy(ecmKey, tmpEcmKey, 7);
+					PowervuCalculateSeed(j, ecm+i, seedBase, ecmKey, seed[j]);
+				}				
+			}
+			else
+			{
+				// Calculate only video and audio1 seed
+				memcpy(ecmKey, tmpEcmKey, 7);
+				PowervuCalculateSeed(PVU_CW_VID, ecm+i, seedBase, ecmKey, seed[PVU_CW_VID]);
+				memcpy(ecmKey, tmpEcmKey, 7);
+				PowervuCalculateSeed(PVU_CW_A1, ecm+i, seedBase, ecmKey, seed[PVU_CW_A1]);	
+			}
+			
+			memcpy(baseCw, ecm+i+6+8, 7);
+
+			if(cdata != NULL || global_cdata)
+			{
+				// Calculate all cws
+				for(j=0; j<8; j++)
+				{
+					PowervuCalculateCw(j,  seed[j], csaUsed, convolvedCw[j], cw[j], baseCw);
+					
+					if(csaUsed)
+					{
+						for(k = 0; k < 8; k += 4) {
+							cw[j][k + 3] = ((cw[j][k] + cw[j][k + 1] + cw[j][k + 2]) & 0xff);
+						}
+					}
+				}
+
+#ifdef WITH_EMU				
+				if(global_cdata)
+				{
+					cw_item = (emu_stream_cw_item*)malloc(sizeof(emu_stream_cw_item));
+					if(cw_item != NULL)
+					{
+						cw_item->csa_used = csaUsed;
+						cw_item->is_even = ecm[0] == 0x80 ? 1 : 0;
+						memcpy(cw_item->cw, cw, sizeof(cw));
+						ll_append(ll_emu_stream_delayed_keys, cw_item);
+					}
+				}
+				else 
+				{
+#endif
+					for(j=0; j<8; j++)
+					{
+						if(csaUsed)
+						{	
+							if(cdata->pvu_csa_ks[j] == NULL)
+								{  cdata->pvu_csa_ks[j] = get_key_struct(); }
+								
+							if(ecm[0] == 0x80)
+								{ set_even_control_word(cdata->pvu_csa_ks[j], cw[j]); }
+							else
+								{ set_odd_control_word(cdata->pvu_csa_ks[j], cw[j]); }
+							
+							cdata->pvu_csa_used = 1;
+						}
+						else
+						{					
+							if(ecm[0] == 0x80)
+								{ des_set_key(cw[j], cdata->pvu_des_ks[j][0]); }
+							else
+								{ des_set_key(cw[j], cdata->pvu_des_ks[j][1]); }
+								
+							cdata->pvu_csa_used = 0;
+						}
+					}
+#ifdef WITH_EMU
+				}
+#endif
+
+				memcpy(dw, cw[PVU_CW_VID], 8);
+				memcpy(&dw[8], cw[PVU_CW_A1], 8);			
+			}
+			else
+			{
+				// Calculate only video and audio1 cw
+				PowervuCalculateCw(PVU_CW_VID, seed[PVU_CW_VID], csaUsed, convolvedCw[PVU_CW_VID], cw[PVU_CW_VID], baseCw);
+				PowervuCalculateCw(PVU_CW_A1, seed[PVU_CW_A1], csaUsed, convolvedCw[PVU_CW_A1], cw[PVU_CW_A1], baseCw);
+
+				memcpy(dw, cw[PVU_CW_VID], 8);
+				memcpy(&dw[8], cw[PVU_CW_A1], 8);
+				
+				if(csaUsed)
+				{
+					for(k = 0; k < 16; k += 4) {
+						dw[k + 3] = ((dw[k] + dw[k + 1] + dw[k + 2]) & 0xff);
+					}
+				}
+			}
+			
+			return 0;
+
+		default:
+			break;
+		}
+		i += nanoLen;
+	}
+
+	return 1;
+}
+
+
+//Drecrypt EMU
+
+static unsigned char DESkeys[16 * 8] =
+{
+	0x4A, 0x11, 0x23, 0xB1, 0x45, 0x99, 0xCF, 0x10, // 00
+	0x21, 0x1B, 0x18, 0xCD, 0x02, 0xD4, 0xA1, 0x1F, // 01
+	0x07, 0x56, 0xAB, 0xB4, 0x45, 0x31, 0xAA, 0x23, // 02
+	0xCD, 0xF2, 0x55, 0xA1, 0x13, 0x4C, 0xF1, 0x76, // 03
+	0x57, 0xD9, 0x31, 0x75, 0x13, 0x98, 0x89, 0xC8, // 04
+	0xA3, 0x36, 0x5B, 0x18, 0xC2, 0x83, 0x45, 0xE2, // 05
+	0x19, 0xF7, 0x35, 0x08, 0xC3, 0xDA, 0xE1, 0x28, // 06
+	0xE7, 0x19, 0xB5, 0xD8, 0x8D, 0xE3, 0x23, 0xA4, // 07
+	0xA7, 0xEC, 0xD2, 0x15, 0x8B, 0x42, 0x59, 0xC5, // 08
+	0x13, 0x49, 0x83, 0x2E, 0xFB, 0xAD, 0x7C, 0xD3, // 09
+	0x37, 0x25, 0x78, 0xE3, 0x72, 0x19, 0x53, 0xD9, // 0A
+	0x7A, 0x15, 0xA4, 0xC7, 0x15, 0x49, 0x32, 0xE8, // 0B
+	0x63, 0xD5, 0x96, 0xA7, 0x27, 0xD8, 0xB2, 0x68, // 0C
+	0x42, 0x5E, 0x1A, 0x8C, 0x41, 0x69, 0x8E, 0xE8, // 0D
+	0xC2, 0xAB, 0x37, 0x29, 0xD3, 0xCF, 0x93, 0xA7, // 0E
+	0x49, 0xD3, 0x33, 0xC2, 0xEB, 0x71, 0xD3, 0x14 // 0F
+};
+
+static void DREover(const unsigned char *ECMdata, unsigned char *DW)
+{
+	uint32_t key_schedule[32];
+	if(ECMdata[2] >= (43 + 4) && ECMdata[40] == 0x3A && ECMdata[41] == 0x4B)
+	{
+		des_set_key(&DESkeys[(ECMdata[42] & 0x0F) * 8], key_schedule);
+
+		des(DW, key_schedule, 0); // even DW post-process
+		des(DW + 8, key_schedule, 0);  // odd DW post-process
+	};
+};
+
+static uint32_t DreGostDec(uint32_t inData)
+{
+	static uint8_t Sbox[128] = {
+		0x0E,0x04,0x0D,0x01,0x02,0x0F,0x0B,0x08,0x03,0x0A,0x06,0x0C,0x05,0x09,0x00,0x07,
+		0x0F,0x01,0x08,0x0E,0x06,0x0B,0x03,0x04,0x09,0x07,0x02,0x0D,0x0C,0x00,0x05,0x0A,
+		0x0A,0x00,0x09,0x0E,0x06,0x03,0x0F,0x05,0x01,0x0D,0x0C,0x07,0x0B,0x04,0x02,0x08,
+		0x07,0x0D,0x0E,0x03,0x00,0x06,0x09,0x0A,0x01,0x02,0x08,0x05,0x0B,0x0C,0x04,0x0F,
+		0x02,0x0C,0x04,0x01,0x07,0x0A,0x0B,0x06,0x08,0x05,0x03,0x0F,0x0D,0x00,0x0E,0x09,
+		0x0C,0x01,0x0A,0x0F,0x09,0x02,0x06,0x08,0x00,0x0D,0x03,0x04,0x0E,0x07,0x05,0x0B,
+		0x04,0x0B,0x02,0x0E,0x0F,0x00,0x08,0x0D,0x03,0x0C,0x09,0x07,0x05,0x0A,0x06,0x01,
+		0x0D,0x02,0x08,0x04,0x06,0x0F,0x0B,0x01,0x0A,0x09,0x03,0x0E,0x05,0x00,0x0C,0x07
+	};
+	uint8_t i, j;
+	for(i=0;i<8;i++) {
+		j= (inData  >> 28) & 0x0F;
+		inData= (inData << 4) | (Sbox[i*16 + j] & 0x0F);
+	};
+	inData= (inData << 11) | (inData >> 21);
+	return (inData);
+}
+
+static void DrecryptDecrypt(uint8_t *Data, uint8_t *Key)	// DRE GOST 28147-89 CORE
+{
+	int i, j;
+	uint32_t L_part = 0, R_part = 0, temp = 0;
+
+	for(i=0;i<4;i++) L_part = (L_part << 8) | (Data[i] & 0xFF), R_part = (R_part << 8) | (Data[i+4] & 0xFF);
+
+	for(i=0;i<4;i++) {
+		temp= ((Key[i*8+0] & 0xFF)<<24) | ((Key[i*8+1] & 0xFF)<<16) | ((Key[i*8+2] & 0xFF)<<8) | (Key[i*8+3] & 0xFF);
+		R_part^= DreGostDec(temp + L_part);
+		temp= ((Key[i*8+4] & 0xFF)<<24) | ((Key[i*8+5] & 0xFF)<<16) | ((Key[i*8+6] & 0xFF)<<8) | (Key[i*8+7] & 0xFF);
+		L_part^= DreGostDec(temp + R_part);
+	};
+
+	for(j=0;j<3;j++) {
+		for(i=3;i>=0;i--) {
+			temp= ((Key[i*8+4] & 0xFF)<<24) | ((Key[i*8+5] & 0xFF)<<16) | ((Key[i*8+6] & 0xFF)<<8) | (Key[i*8+7] & 0xFF);
+			R_part^= DreGostDec(temp + L_part);
+			temp= ((Key[i*8+0] & 0xFF)<<24) | ((Key[i*8+1] & 0xFF)<<16) | ((Key[i*8+2] & 0xFF)<<8) | (Key[i*8+3] & 0xFF);
+			L_part^= DreGostDec(temp + R_part);
+		};
+	};
+
+	for(i=0;i<4;i++) Data[i] = (R_part >> i*8) & 0xFF, Data[i+4] = (L_part >> i*8) & 0xFF;
+}
+
+static void DrecryptPostCw(uint8_t* ccw)
+{
+	uint32_t i, j;
+	uint8_t tmp[4];
+	
+	for(i = 0; i < 4; i++) {
+	
+		for(j = 0; j < 4; j++) {
+			tmp[j] = ccw[3 - j];
+		}
+     
+		for(j = 0; j < 4; j++) {
+			ccw[j] = tmp[j];
+		}
+	
+		ccw += 4;
+	}
+}
+
+static void DrecryptSwap(uint8_t* ccw)
+{
+	uint32_t tmp1, tmp2;
+
+	memcpy(&tmp1, ccw, 4);
+	memcpy(&tmp2, ccw + 4, 4);
+
+	memcpy(ccw, ccw + 8, 8);
+
+	memcpy(ccw + 8 , &tmp1, 4);
+	memcpy(ccw + 8 + 4, &tmp2, 4);
+}
+
+static int8_t Drecrypt2ECM(struct s_reader *rdr, uint16_t caid, uint32_t provId, uint8_t *ecm, uint8_t *dw)
+{
+	uint8_t keyClass = ecm[5], keyIndex = ecm[6], ccw[16], key[32], dummy[2][32];
+	uint16_t overcryptId;	
+	
+	uint16_t ecmLen = GetEcmLen(ecm);
+	if(ecmLen < 30 || caid != 0x4AE1)
+	{
+		return 1;
+	}
+	
+	switch(provId & 0xFF)
+	{
+		case 0x11:
+			memcpy(key, keyIndex == 0x3B ? rdr->ee36->key3b[keyClass] : rdr->ee36->key56[keyClass], 32);
+			break;
+		case 0x14:
+			memcpy(key, keyIndex == 0x3B ? rdr->ee56->key3b[keyClass] : rdr->ee56->key56[keyClass], 32);
+			break;
+		default:
+			return 4;
+	}
+	
+	memset(dummy[0], 0x00, 32);
+	memset(dummy[1], 0xFF, 32);
+
+	if(memcmp(dummy[0], key, 32) == 0 || memcmp(dummy[1], key, 32) == 0) return 2;
+	
+	memcpy(ccw, ecm+13, 16);
+	DrecryptPostCw(key); DrecryptPostCw(key+16);
+	DrecryptDecrypt(ccw, key); DrecryptDecrypt(ccw+8, key);
+		
+	if(ecmLen >= 46 && ecm[43] == 1 && provId == 0x11)
+	{    
+		DrecryptSwap(ccw);
+		overcryptId = b2i(2, &ecm[44]);
+		if(Drecrypt2OverCW(overcryptId, ccw) == 2) set_emu_extee(rdr);
+		
+		if(isValidDCW(ccw))
+		{
+			memcpy(dw, ccw, 16);
+			return 0;
+		}
+		return 9;
+	}
+		
+	DREover(ecm, ccw);
+	
+	if(isValidDCW(ccw))
+	{
+		DrecryptSwap(ccw);
+		memcpy(dw, ccw, 16);
+		return 0;	
+	}
+	set_emu_extee(rdr);
+		
+	return 1;
+}
+
+char* GetProcessECMErrorReason(int8_t result)
+{
+	switch(result) {
+	case 0:
+		return "No error";
+	case 1:
+		return "ECM not supported";
+	case 2:
+		return "Key not found";
+	case 3:
+		return "Nano80 problem";
+	case 4:
+		return "Corrupt data";
+	case 5:
+		return "CW not found";
+	case 6:
+		return "CW checksum error";
+	case 7:
+		return "Out of memory";
+	case 8:
+		return "ECM checksum error";
+	case 9:
+		return "ICG error";
+	default:
+		return "Unknown";
+	}
+}
+
+/* Error codes
+0  OK
+1  ECM not supported
+2  Key not found
+3  Nano80 problem
+4  Corrupt data
+5  CW not found
+6  CW checksum error
+7  Out of memory
+*/
+int8_t ProcessECM(struct s_reader *rdr, int16_t ecmDataLen, uint16_t caid, uint32_t provider, const uint8_t *ecm,
+				  uint8_t *dw, uint16_t srvid, uint16_t ecmpid)
+{
+	int8_t result = 1, i, use_gkey = 0;
+	uint8_t ecmCopy[EMU_MAX_ECM_LEN];
+	uint16_t ecmLen = 0;
+
+	if(ecmDataLen < 3) {
+		// accept requests without ecm only for biss
+		if((caid>>8) != 0x26 && caid != 0xFFFF) {
+			return 1;
+		}
+	}
+	else {
+		ecmLen = GetEcmLen(ecm);
+	}
+
+	if(ecmLen > ecmDataLen) {
+		return 1;
+	}
+
+	if(ecmLen > EMU_MAX_ECM_LEN) {
+		return 1;
+	}
+	memcpy(ecmCopy, ecm, ecmLen);
+
+	if((caid>>8)==0x0D) {
+		result = CryptoworksECM(caid,ecmCopy,dw);
+	}
+	else if((caid>>8)==0x09) {
+		result = SoftNDSECM(caid,ecmCopy,dw);
+	}
+	else if(caid==0x0500) {
+		result = ViaccessECM(ecmCopy,dw);
+	}
+	else if((caid>>8)==0x18) {
+		result = Nagra2ECM(ecmCopy,dw);
+	}
+	else if((caid>>8)==0x06) {
+		result = Irdeto2ECM(caid,ecmCopy,dw);
+	}
+	else if((caid>>8)==0x26 || caid == 0xFFFF) {
+		result = BissECM(caid,ecm,ecmDataLen,dw,srvid,ecmpid);
+	}
+	else if((caid>>8)==0x0E) {
+#ifdef WITH_EMU
+		if(!stream_server_has_ecm && srvid == emu_stream_cur_srvid)
+			{ use_gkey = 1; } 
+#endif
+		result = PowervuECM(ecmCopy,dw,NULL,use_gkey);
+	}
+	else if(caid==0x4AE1) {
+		result = Drecrypt2ECM(rdr, caid,provider,ecmCopy,dw);
+	}	
+
+	// fix dcw checksum
+	if(result == 0 && !((caid>>8)==0x0E)) {
+		for(i = 0; i < 16; i += 4) {
+			dw[i + 3] = ((dw[i] + dw[i + 1] + dw[i + 2]) & 0xff);
+		}
+	}
+
+	if(result != 0) {
+		cs_log("[Emu] ECM failed: %s", GetProcessECMErrorReason(result));
+	}
+
+	return result;
+}
+
+// Viaccess EMM EMU
+static int8_t ViaccessEMM(uint8_t *emm, uint32_t *keysAdded)
+{
+	uint8_t nanoCmd = 0, subNanoCmd = 0, *tmp, *newKeyD0, *newEcmKey;
+	uint16_t i = 0, j = 0, k = 0, emmLen = GetEcmLen(emm);
+	uint8_t ecmKeys[6][16], keyD0[2], emmKey[16], emmXorKey[16], provName[17];
+	uint8_t ecmKeyCount = 0, emmKeyIndex = 0, aesMode = 0x0D;
+	uint8_t nanoLen = 0, subNanoLen = 0, haveEmmXorKey = 0, haveNewD0 = 0;
+	uint32_t ui1, ui2, ui3, ecmKeyIndex[6], provider = 0, ecmProvider = 0;
+	char keyName[EMU_MAX_CHAR_KEYNAME], keyValue[36];
+	struct aes_keys aes;
+
+	memset(keyD0, 0, 2);
+	memset(ecmKeyIndex, 0, sizeof(uint32_t)*6);
+
+	for(i=3; i+2<emmLen; ) {
+		nanoCmd = emm[i++];
+		nanoLen = emm[i++];
+		if(i+nanoLen > emmLen) {
+			return 1;
+		}
+
+		switch(nanoCmd) {
+		case 0x90: {
+			if(nanoLen < 3) {
+				break;
+			}
+			ui1 = emm[i+2];
+			ui2 = emm[i+1];
+			ui3 = emm[i];
+			provider = (ui1 | (ui2 << 8) | (ui3 << 16));
+			if(provider == 0x00D00040) {
+				ecmProvider = 0x030B00;
+			}
+			else {
+				return 1;
+			}
+			break;
+		}
+		case 0xD2: {
+			if(nanoLen < 2) {
+				break;
+			}
+			emmKeyIndex = emm[i+1];
+			break;
+		}
+		case 0x41: {
+			if(nanoLen < 1) {
+				break;
+			}
+			if(!GetViaKey(emmKey, provider, 'M', emmKeyIndex, 16, 1)) {
+				return 2;
+			}
+			memset(provName, 0, 17);
+			memset(emmXorKey, 0, 16);
+			k = nanoLen < 16 ? nanoLen : 16;
+			memcpy(provName, &emm[i], k);
+			aes_set_key(&aes, (char*)emmKey);
+			aes_decrypt(&aes, emmXorKey, 16);
+			for(j=0; j<16; j++) {
+				provName[j] ^= emmXorKey[j];
+			}
+			provName[k] = 0;
+
+			if(strcmp((char*)provName, "TNTSAT") != 0 && strcmp((char*)provName, "TNTSATPRO") != 0
+					&&strcmp((char*)provName, "CSAT V") != 0) {
+				return 1;
+			}
+			break;
+		}
+		case 0xBA: {
+			if(nanoLen < 2) {
+				break;
+			}
+			GetViaKey(keyD0, ecmProvider, 'D', 0, 2, 0);
+			ui1 = (emm[i] << 8) | emm[i+1];
+			if( (uint32_t)((keyD0[0] << 8) | keyD0[1]) < ui1 || (keyD0[0] == 0x00 && keyD0[1] == 0x00)) {
+				keyD0[0] = emm[i];
+				keyD0[1] = emm[i+1];
+				haveNewD0 = 1;
+				break;
+			}
+			return 0;
+		}
+		case 0xBC: {
+			break;
+		}
+		case 0x43: {
+			if(nanoLen < 16) {
+				break;
+			}
+			memcpy(emmXorKey, &emm[i], 16);
+			haveEmmXorKey = 1;
+			break;
+		}
+		case 0x44: {
+			if(nanoLen < 3) {
+				break;
+			}
+			if (!haveEmmXorKey) {
+				memset(emmXorKey, 0, 16);
+			}
+			tmp = (uint8_t*)malloc(((nanoLen/16)+1)*16*sizeof(uint8_t));
+			if(tmp == NULL) {
+				return 7;
+			}
+			memcpy(tmp, &emm[i], nanoLen);
+			aes_set_key(&aes, (char*)emmKey);
+			for(j=0; j<nanoLen; j+=16) {
+				aes_decrypt(&aes, emmXorKey, 16);
+				for(k=0; k<16; k++) {
+					tmp[j+k] ^= emmXorKey[k];
+				}
+			}
+			memcpy(&emm[i-2], tmp, nanoLen);
+			free(tmp);
+			nanoLen = 0;
+			i -= 2;
+			break;
+		}
+		case 0x68: {
+			if(ecmKeyCount > 5) {
+				break;
+			}
+			for(j=i; j+2<i+nanoLen; ) {
+				subNanoCmd = emm[j++];
+				subNanoLen = emm[j++];
+				if(j+subNanoLen > i+nanoLen) {
+					break;
+				}
+				switch(subNanoCmd) {
+				case 0xD2: {
+					if(nanoLen < 2) {
+						break;
+					}
+					aesMode = emm[j];
+					emmKeyIndex = emm[j+1];
+					break;
+				}
+				case 0x01: {
+					if(nanoLen < 17) {
+						break;
+					}
+					ecmKeyIndex[ecmKeyCount] = emm[j];
+					memcpy(&ecmKeys[ecmKeyCount], &emm[j+1], 16);
+					if(!GetViaKey(emmKey, provider, 'M', emmKeyIndex, 16, 1)) {
+						break;
+					}
+
+					if(aesMode == 0x0F || aesMode == 0x11) {
+						hdSurEncPhase1_D2_0F_11(ecmKeys[ecmKeyCount]);
+						hdSurEncPhase2_D2_0F_11(ecmKeys[ecmKeyCount]);
+					}
+					else if(aesMode == 0x13 || aesMode == 0x15) {
+						hdSurEncPhase1_D2_13_15(ecmKeys[ecmKeyCount]);
+					}
+					aes_set_key(&aes, (char*)emmKey);
+					aes_decrypt(&aes, ecmKeys[ecmKeyCount], 16);
+					if(aesMode == 0x0F || aesMode == 0x11) {
+						hdSurEncPhase1_D2_0F_11(ecmKeys[ecmKeyCount]);
+					}
+					else if(aesMode == 0x13 || aesMode == 0x15) {
+						hdSurEncPhase2_D2_13_15(ecmKeys[ecmKeyCount]);
+					}
+
+					ecmKeyCount++;
+					break;
+				}
+				default:
+					break;
+				}
+				j += subNanoLen;
+			}
+			break;
+		}
+		case 0xF0: {
+			if(nanoLen != 4) {
+				break;
+			}
+			ui1 = ((emm[i+2] << 8) | (emm[i+1] << 16) | (emm[i] << 24) | emm[i+3]);
+			if(fletcher_crc32(emm + 3, emmLen - 11) != ui1) {
+				return 4;
+			}
+
+			if(haveNewD0) {
+				newKeyD0 = (uint8_t*)malloc(sizeof(uint8_t)*2);
+				if(newKeyD0 == NULL) {
+					return 7;
+				}
+				memcpy(newKeyD0, keyD0, 2);
+				if(!SetKey('V', ecmProvider, "D0", newKeyD0, 2, 1)) {
+					free(newKeyD0);
+				}
+				for(j=0; j<ecmKeyCount; j++) {
+					newEcmKey = (uint8_t*)malloc(sizeof(uint8_t)*16);
+					if(newEcmKey == NULL) {
+						return 7;
+					}
+					memcpy(newEcmKey, ecmKeys[j], 16);
+					snprintf(keyName, EMU_MAX_CHAR_KEYNAME, "E%X", ecmKeyIndex[j]);
+					if(!SetKey('V', ecmProvider, keyName, newEcmKey, 16, 1)) {
+						free(newEcmKey);
+					}
+					(*keysAdded)++;
+					cs_hexdump(0, ecmKeys[j], 16, keyValue, sizeof(keyValue));
+					cs_log("[Emu] Key found in EMM: V %06X %s %s", ecmProvider, keyName, keyValue);
+				}
+			}
+			break;
+		}
+		default:
+			break;
+		}
+		i += nanoLen;
+	}
+	return 0;
+}
+
+// Irdeto2 EMM EMU
+static int8_t Irdeto2DoEMMTypeOP(uint32_t ident, uint8_t *emm, uint8_t *keySeed, uint8_t *keyIV, uint8_t *keyPMK,
+								 uint16_t emmLen, uint8_t startOffset, uint8_t length, uint32_t *keysAdded)
+{
+	uint32_t end, i, l;
+	uint8_t tmp[16], *newOpKey;
+	char keyName[EMU_MAX_CHAR_KEYNAME], keyValue[36];
+
+	memset(tmp, 0, 16);
+	Irdeto2Encrypt(keySeed, tmp, keyPMK, 16);
+	Irdeto2Decrypt(&emm[startOffset], keyIV, keySeed, length);
+
+	i = 16;
+	end = startOffset + (length-8 < 0 ? 0 : length-8);
+
+	while(i<end) {
+		l = emm[i+1] ? (emm[i+1]&0x3F)+2 : 1;
+		switch(emm[i]) {
+		case 0x10:
+		case 0x50:
+			if(l==0x13 && i<=startOffset+length-8-l) {
+				Irdeto2Decrypt(&emm[i+3], keyIV, keyPMK, 16);
+			}
+			break;
+		case 0x78:
+			if(l==0x14 && i<=startOffset+length-8-l) {
+				Irdeto2Decrypt(&emm[i+4], keyIV, keyPMK, 16);
+			}
+			break;
+		}
+		i+=l;
+	}
+
+	memmove(emm+6, emm+7, emmLen-7);
+
+	i = 15;
+	end = startOffset + (length-9 < 0 ? 0 : length-9);
+
+	if(Irdeto2CalculateHash(keySeed, keyIV, emm+3, emmLen-4)) {
+		while(i<end) {
+			l = emm[i+1] ? (emm[i+1]&0x3F)+2 : 1;
+			switch(emm[i]) {
+			case 0x10:
+			case 0x50:
+				if(l==0x13 && i<=startOffset+length-9-l) {
+					newOpKey = (uint8_t*)malloc(sizeof(uint8_t)*16);
+					if(newOpKey == NULL) {
+						return 7;
+					}
+					memcpy(newOpKey, &emm[i+3], 16);
+					snprintf(keyName, EMU_MAX_CHAR_KEYNAME, "%02X", emm[i+2]>>2);
+					if(!SetKey('I', ident, keyName, newOpKey, 16, 1)) {
+						free(newOpKey);
+					}
+					(*keysAdded)++;
+					cs_hexdump(0, &emm[i+3], 16, keyValue, sizeof(keyValue));
+					cs_log("[Emu] Key found in EMM: I %06X %s %s", ident, keyName, keyValue);
+				}
+			}
+			i+=l;
+		}
+
+		if(*keysAdded > 0) {
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+static int8_t Irdeto2DoEMMTypePMK(uint32_t ident, uint8_t *emm, uint8_t *keySeed, uint8_t *keyIV, uint8_t *keyPMK,
+								  uint16_t emmLen, uint8_t startOffset, uint8_t length, uint32_t *keysAdded)
+{
+	uint32_t end, i, l, j;
+	uint8_t *newPmkKey;
+	char keyName[EMU_MAX_CHAR_KEYNAME], keyValue[36];
+
+	Irdeto2Decrypt(&emm[startOffset], keyIV, keySeed, length);
+
+	i = 13;
+	end = startOffset + (length-8 < 0 ? 0 : length-8);
+
+	while(i<end) {
+		l = emm[i+1] ? (emm[i+1]&0x3F)+2 : 1;
+		switch(emm[i]) {
+		case 0x10:
+		case 0x50:
+			if(l==0x13 && i<=startOffset+length-8-l) {
+				Irdeto2Decrypt(&emm[i+3], keyIV, keyPMK, 16);
+			}
+			break;
+		case 0x78:
+			if(l==0x14 && i<=startOffset+length-8-l) {
+				Irdeto2Decrypt(&emm[i+4], keyIV, keyPMK, 16);
+			}
+			break;
+		case 0x68:
+			if(l==0x26 && i<=startOffset+length-8-l) {
+				Irdeto2Decrypt(&emm[i+3], keyIV, keyPMK, 16*2);
+			}
+			break;
+		}
+		i+=l;
+	}
+
+	memmove(emm+7, emm+9, emmLen-9);
+
+	i = 11;
+	end = startOffset + (length-10 < 0 ? 0 : length-10);
+
+	if(Irdeto2CalculateHash(keySeed, keyIV, emm+3, emmLen-5)) {
+		while(i<end) {
+			l = emm[i+1] ? (emm[i+1]&0x3F)+2 : 1;
+			switch(emm[i]) {
+			case 0x68:
+				if(l==0x26 && i<=startOffset+length-10-l) {
+					for(j=0; j<2; j++) {
+						newPmkKey = (uint8_t*)malloc(sizeof(uint8_t)*16);
+						if(newPmkKey == NULL) {
+							return 7;
+						}
+						memcpy(newPmkKey, &emm[i+3+j*16], 16);
+						snprintf(keyName, EMU_MAX_CHAR_KEYNAME, "M%01X", 3+j);
+						if(!SetKey('I', ident, keyName, newPmkKey, 16, 1)) {
+							free(newPmkKey);
+						}
+						(*keysAdded)++;
+						cs_hexdump(0, &emm[i+3+j*16], 16, keyValue, sizeof(keyValue));
+						cs_log("[Emu] Key found in EMM: I %06X %s %s", ident, keyName, keyValue);
+					}
+				}
+			}
+			i+=l;
+		}
+
+		if(*keysAdded > 0) {
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+static const uint8_t fausto_xor[16] = { 0x22, 0x58, 0xBD, 0x85, 0x2E, 0x8E, 0x52, 0x80, 0xA3, 0x79, 0x98, 0x69, 0x68, 0xE2, 0xD8, 0x4D };
+
+static int8_t Irdeto2EMM(uint16_t caid, uint8_t *oemm, uint32_t *keysAdded)
+{
+	uint8_t length, okeySeed[16], keySeed[16], keyIV[16], keyPMK[16], startOffset, emmType;
+	uint32_t ident;
+	uint8_t keySeedRef, keyIVRef, keyPMK0Ref, keyPMK1Ref, keyPMK0ERef, keyPMK1ERef;
+	uint8_t emmCopy[EMU_MAX_EMM_LEN], *emm = oemm;
+	uint16_t emmLen = GetEcmLen(emm);
+
+	if(emmLen < 11) {
+		return 1;
+	}
+
+	if(emm[3] == 0xC3 || emm[3] == 0xCB) {
+		emmType = 2;
+		startOffset = 11;
+	}
+	else {
+		emmType = 1;
+		startOffset = 10;
+	}
+
+	ident = emm[startOffset-2] | caid << 8;
+	length = emm[startOffset-1];
+
+
+	if(emmLen < length+startOffset) {
+		return 1;
+	}
+
+	keySeedRef = 0;
+	while(GetIrdetoKey(okeySeed, ident, 'M', emmType == 1 ? 0 : 0xA, 1, &keySeedRef)) {
+		keyIVRef = 0;
+		while(GetIrdetoKey(keyIV, ident, 'M', 2, 1, &keyIVRef)) {
+
+			keyPMK0Ref = 0;
+			keyPMK1Ref = 0;
+			keyPMK0ERef = 0;
+			keyPMK1ERef = 0;
+
+			while(GetIrdetoKey(keyPMK, ident, 'M', emmType == 1 ? 3 : 0xB, 1, &keyPMK0Ref)) {
+				memcpy(keySeed, okeySeed, 16);
+				memcpy(emmCopy, oemm, emmLen);
+				emm = emmCopy;
+				if(emmType == 1) {
+					if(Irdeto2DoEMMTypeOP(ident, emm, keySeed, keyIV, keyPMK, emmLen, startOffset, length, keysAdded) == 0) {
+						return 0;
+					}
+				}
+				else {
+					if(Irdeto2DoEMMTypePMK(ident, emm, keySeed, keyIV, keyPMK, emmLen, startOffset, length, keysAdded) == 0) {
+						return 0;
+					}
+				}
+			}
+
+			if(emmType == 1) {
+				while(GetIrdetoKey(keyPMK, ident, 'M', 4, 1, &keyPMK1Ref)) {
+					memcpy(keySeed, okeySeed, 16);
+					memcpy(emmCopy, oemm, emmLen);
+					emm = emmCopy;
+					if(Irdeto2DoEMMTypeOP(ident, emm, keySeed, keyIV, keyPMK, emmLen, startOffset, length, keysAdded) == 0) {
+						return 0;
+					}
+				}
+
+				while(GetIrdetoKey(keyPMK, ident, 'M', 5, 1, &keyPMK0ERef)) {
+					xxor(keyPMK, 16, keyPMK, fausto_xor);
+					memcpy(keySeed, okeySeed, 16);
+					memcpy(emmCopy, oemm, emmLen);
+					emm = emmCopy;
+					if(Irdeto2DoEMMTypeOP(ident, emm, keySeed, keyIV, keyPMK, emmLen, startOffset, length, keysAdded) == 0) {
+						return 0;
+					}
+				}
+
+				while(GetIrdetoKey(keyPMK, ident, 'M', 6, 1, &keyPMK1ERef)) {
+					xxor(keyPMK, 16, keyPMK, fausto_xor);
+					memcpy(keySeed, okeySeed, 16);
+					memcpy(emmCopy, oemm, emmLen);
+					emm = emmCopy;
+					if(Irdeto2DoEMMTypeOP(ident, emm, keySeed, keyIV, keyPMK, emmLen, startOffset, length, keysAdded) == 0) {
+						return 0;
+					}
+				}
+			}
+
+			if(keyPMK0Ref == 0 && keyPMK1Ref == 0 && keyPMK0ERef == 0 && keyPMK1ERef == 0) {
+				return 2;
+			}
+		}
+		if(keyIVRef == 0) {
+			return 2;
+		}
+	}
+	if(keySeedRef == 0) {
+		return 2;
+	}
+
+	return 1;
+}
+
+int32_t GetIrdeto2Hexserial(uint16_t caid, uint8_t *hexserial)
+{
+	uint32_t i, len;
+	KeyDataContainer *KeyDB;
+	KeyData *tmpKeyData;
+
+	KeyDB = GetKeyContainer('I');
+	if(KeyDB == NULL) {
+		return 0;
+	}
+
+	for(i=0; i<KeyDB->keyCount; i++) {
+
+		if(KeyDB->EmuKeys[i].provider>>8 != caid) {
+			continue;
+		}
+		if(strcmp(KeyDB->EmuKeys[i].keyName, "MC")) {
+			continue;
+		}
+
+		tmpKeyData = &KeyDB->EmuKeys[i];
+		
+		len = tmpKeyData->keyLength;
+		if(len > 3)
+			{ len = 3; }
+		
+		memcpy(hexserial+(3-len), tmpKeyData->key, len);
+		return 1;
+	}
+
+	return 0;
+}
+
+
+// PowerVu EMM EMU
+static int8_t PowervuEMM(uint8_t *emm, uint32_t *keysAdded)
+{
+	uint8_t emmInfo, emmType, *newEcmKey;
+	uint16_t emmLen = GetEcmLen(emm);
+	uint32_t i, emmCrc32, uniqueAddress, channelId;
+	uint8_t emmKey[7], tmpEmmKey[7];
+	char keyName[EMU_MAX_CHAR_KEYNAME], keyValue[16];
+
+	if(emmLen < 50)
+	{
+		return 1;
+	}
+
+	emmCrc32 = b2i(4, emm+emmLen-4);
+
+	if(fletcher_crc32(emm, emmLen-4) != emmCrc32)
+	{
+		return 8;
+	}
+	emmLen -= 4;
+
+	uniqueAddress = b2i(4, emm+12);
+
+	snprintf(keyName, EMU_MAX_CHAR_KEYNAME, "%.8X", uniqueAddress);
+	if(!GetPowervuEmmKey(emmKey, 0, keyName, 7, 1, &channelId))
+	{
+		return 0;
+	}
+
+	for(i=19; i+27<=emmLen; i+=27) {
+		emmInfo = emm[i];
+
+		if(!GetBit(emmInfo, 7))
+		{
+			continue;
+		}
+
+		//keyNb = emm[i] & 0x0F;
+
+		memcpy(tmpEmmKey, emmKey, 7);
+		PowervuDecrypt(emm+i+1, 26, tmpEmmKey);
+
+		if((emm[13] != emm[i+24]) || (emm[14] != emm[i+25]) || (emm[15] != emm[i+26]))
+		{
+			continue;
+		}
+
+		emmType = emm[i+2] & 0x7F;
+		if(emmType > 1)
+		{
+			continue;
+		}
+
+		newEcmKey = (uint8_t*)malloc(sizeof(uint8_t)*7);
+		if(newEcmKey == NULL) {
+			return 7;
+		}
+		memcpy(newEcmKey, &emm[i+3], 7);
+		snprintf(keyName, EMU_MAX_CHAR_KEYNAME, "%.2X", emmType);
+		if(!UpdateKey('P', channelId, keyName, newEcmKey, 7)) {
+			free(newEcmKey);
+		}
+		(*keysAdded)++;
+		cs_hexdump(0, &emm[i+3], 7, keyValue, sizeof(keyValue));
+		cs_log("[Emu] Key found in EMM: P %.4X %s %s", channelId, keyName, keyValue);
+	}
+
+	return 0;
+}
+
+int32_t GetPowervuHexserials(uint16_t srvid, uint8_t hexserials[][4], int32_t length, int32_t* count)
+{
+	uint32_t i;
+	int32_t len;
+	KeyDataContainer *KeyDB;
+
+	KeyDB = GetKeyContainer('P');
+	if(KeyDB == NULL)
+		{ return 0; }
+	
+	(*count) = 0;
+
+	for(i=0; i<KeyDB->keyCount && (*count)<length ; i++) {
+
+		if(srvid != 0xFFFF && KeyDB->EmuKeys[i].provider != srvid)
+			{ continue; }
+		
+		len = strlen(KeyDB->EmuKeys[i].keyName);
+		
+		if(len < 3)
+			{ continue;}
+		
+		if(len > 8)
+			{ len = 8; }
+
+		memset(hexserials[*count], 0, 4);
+		CharToBin(hexserials[(*count)]+(4-(len/2)), KeyDB->EmuKeys[i].keyName, len);
+	
+		(*count)++;
+	}
+
+	return 1;
+}
+
+
+// Drecrypt EMM EMU
+static int8_t GetDrecryptEMMKey(uint8_t *buf, uint32_t keyIdent, uint16_t keyName, uint8_t isCriticalKey)
+{
+	char keyStr[EMU_MAX_CHAR_KEYNAME];
+	snprintf(keyStr, EMU_MAX_CHAR_KEYNAME, "MK%X", keyName);
+	return FindKey('D', keyIdent, keyStr, buf, 32, isCriticalKey, 0, 0, NULL);
+}
+
+static int8_t Drecrypt2EMM(struct s_reader *rdr, uint16_t caid, uint32_t provId, uint8_t *emm, uint32_t *keysAdded)
+{
+	uint16_t emmLen = ((emm[1] & 0xF) << 8) | emm[2];//GetEcmLen(emm);
+	uint32_t keyIdent;
+	uint16_t keyName;
+	uint8_t emmKey[32];
+	int32_t i;
+	uint8_t *curECMkey3B, *curECMkey56;
+	uint8_t keynum, keyidx, keyclass, key1offset, key2offset;
+	char newKeyName[EMU_MAX_CHAR_KEYNAME], keyValue[100];
+	
+	if(emmLen < 1 || caid != 0x4AE1) {
+		return 1;
+	}
+
+    if(emm[0] == 0x91) {
+        Drecrypt2OverEMM(emm);
+        return 0;
+    }
+	
+	if(emm[0] != 0x86) return 1;
+		
+	switch(emm[4])
+	{
+		case 0x02:
+			keynum = 0x2C;
+			keyidx = 0x30;
+			keyclass = 0x26;
+			key1offset = 0x35;
+			key2offset = 0x6D;
+			break;
+			
+		case 0x4D:
+			keynum = 0x61;
+			keyidx = 0x60;
+			keyclass = 0x05;
+			key1offset = 0x62;
+			key2offset = 0x8B;
+			break;
+			
+		default:
+			return 1;
+	}
+	
+	switch(provId & 0xFF)
+	{
+		case 0x11:
+			if (rdr->ee36 == NULL) return 7;
+			curECMkey3B = rdr->ee36->key3b[emm[keyclass]];
+			curECMkey56 = rdr->ee36->key56[emm[keyclass]];
+			break;
+		case 0x14:
+			if (rdr->ee56 == NULL) return 7;
+			curECMkey3B = rdr->ee56->key3b[emm[keyclass]];
+			curECMkey56 = rdr->ee56->key56[emm[keyclass]];
+			break;
+		default:
+			return 1;
+	}
+	
+	keyIdent = caid<<8 | provId;
+	keyName = emm[0x3]<<8 | emm[keynum];
+
+	if(!GetDrecryptEMMKey(emmKey, keyIdent, keyName, 1))
+	{
+		return 2; 
+	}
+	
+	//key #1
+	for(i=0; i<4; i++)
+	{
+		DrecryptDecrypt(&emm[key1offset+(i*8)], emmKey);
+	}
+
+	//key #2
+	for(i=0; i<4; i++)
+	{
+		DrecryptDecrypt(&emm[key2offset+(i*8)], emmKey);
+	}
+	
+	//key #1
+	keyName = emm[keyidx]<<8 | emm[keyclass];
+	snprintf(newKeyName, EMU_MAX_CHAR_KEYNAME, "%.4X", keyName);
+	if(memcmp(&emm[key1offset], emm[keyidx] == 0x3b ? curECMkey3B : curECMkey56, 32) != 0)
+	{
+		memcpy(emm[keyidx] == 0x3b ? curECMkey3B : curECMkey56, &emm[key1offset], 32);
+		(*keysAdded)++;
+		cs_hexdump(0, &emm[key1offset], 32, keyValue, sizeof(keyValue));
+		cs_log("[Emu] Key found in EMM: D %.6X %s %s", keyIdent, newKeyName, keyValue);
+	}
+	else
+	{
+		cs_log("[Emu] Key %.6X %s alredy exist", keyIdent, newKeyName);
+	}
+
+	//key #2
+	keyName = (emm[keyidx] == 0x56 ? 0x3B00 : 0x5600) | emm[keyclass];
+	snprintf(newKeyName, EMU_MAX_CHAR_KEYNAME, "%.4X", keyName);
+	if(memcmp(&emm[key2offset], emm[keyidx] == 0x3b ? curECMkey56 : curECMkey3B, 32) != 0)
+	{
+		memcpy(emm[keyidx] == 0x3b ? curECMkey56 : curECMkey3B, &emm[key2offset], 32);
+		(*keysAdded)++;
+		cs_hexdump(0, &emm[key2offset], 32, keyValue, sizeof(keyValue));
+		cs_log("[Emu] Key found in EMM: D %.6X %s %s", keyIdent, newKeyName, keyValue);
+	}
+	else
+	{
+		cs_log("[Emu] Key %.6X %s alredy exist", keyIdent, newKeyName);
+	}
+	
+	if(*keysAdded > 0) WriteEEToFile(rdr, (provId & 0xFF));
+	
+	return 1;
+}
+
+int32_t GetDrecryptHexserials(uint16_t caid, uint8_t *hexserials, int32_t length, int32_t* count)
+{
+	uint32_t i;
+	int32_t len;
+	KeyDataContainer *KeyDB;
+
+	KeyDB = GetKeyContainer('D');
+	if(KeyDB == NULL)
+		{ return 0; }
+	
+	(*count) = 0;
+
+	for(i=0; i<KeyDB->keyCount && (*count)<length ; i++) {
+
+		if(KeyDB->EmuKeys[i].provider>>8 != caid) 
+			{ continue; }
+		
+		len = strlen(KeyDB->EmuKeys[i].keyName);
+		
+		if(len < 6)
+			{ continue; }
+			
+		if(memcmp(KeyDB->EmuKeys[i].keyName, "MK", 2))
+			{ continue; }
+		
+		CharToBin(&hexserials[(*count)], KeyDB->EmuKeys[i].keyName+2, 2);
+	
+		(*count)++;
+	}
+
+	return 1;
+}
+
+char* GetProcessEMMErrorReason(int8_t result)
+{
+	switch(result) {
+	case 0:
+		return "No error";
+	case 1:
+		return "EMM not supported";
+	case 2:
+		return "Key not found";
+	case 3:
+		return "Nano80 problem";
+	case 4:
+		return "Corrupt data";
+	case 5:
+		return "Unknown";
+	case 6:
+		return "Checksum error";
+	case 7:
+		return "Out of memory";
+	case 8:
+		return "EMM checksum error";
+	default:
+		return "Unknown";
+	}
+}
+
+/* Error codes
+0  OK
+1  EMM not supported
+2  Key not found
+3  Nano80 problem
+4  Corrupt data
+5
+6  Checksum error
+7  Out of memory
+*/
+int8_t ProcessEMM(struct s_reader *rdr, uint16_t caid, uint32_t provider, const uint8_t *emm, uint32_t *keysAdded)
+{
+	int8_t result = 1;
+	uint8_t emmCopy[EMU_MAX_EMM_LEN];
+	uint16_t emmLen = GetEcmLen(emm);
+
+	if(emmLen > EMU_MAX_EMM_LEN) {
+		return 1;
+	}
+	
+	memcpy(emmCopy, emm, emmLen);
+	*keysAdded = 0;
+
+	if(caid==0x0500) {
+		result = ViaccessEMM(emmCopy, keysAdded);
+	}
+	else if((caid>>8)==0x06) {
+		result = Irdeto2EMM(caid, emmCopy, keysAdded);
+	}
+	else if((caid>>8)==0x0E) {
+		result = PowervuEMM(emmCopy, keysAdded);
+	}
+	else if(caid==0x4AE1) {
+		result = Drecrypt2EMM(rdr, caid, provider, emmCopy, keysAdded);
+	}
+
+	if(result != 0) {
+		cs_log("[Emu] EMM failed: %s", GetProcessEMMErrorReason(result));
+	}
+
+	return result;
+}
+
diff -ruN oscam-emu-2015-12-03-11142.orig/module-emulator-osemu.h oscam-emu-2015-12-03-11142/module-emulator-osemu.h
--- oscam-emu-2015-12-03-11142.orig/module-emulator-osemu.h	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/module-emulator-osemu.h	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,102 @@
+#include "module-emulator-stream.h"
+
+#ifndef EMULATOR_H_
+#define EMULATOR_H_
+
+#define EMU_MAX_CHAR_KEYNAME 12
+#define EMU_KEY_FILENAME "SoftCam.Key"
+#define EMU_KEY_FILENAME_MAX_LEN 31
+#define EMU_MAX_ECM_LEN 1024
+#define EMU_MAX_EMM_LEN 1024
+
+	typedef struct {
+		char identifier;
+		uint32_t provider;
+		char keyName[EMU_MAX_CHAR_KEYNAME];
+		uint8_t *key;
+		uint32_t keyLength;
+		void *nextKey;
+	} KeyData;
+
+	typedef struct {
+		KeyData *EmuKeys;
+		uint32_t keyCount;
+		uint32_t keyMax;
+	} KeyDataContainer;
+
+	extern KeyDataContainer CwKeys;
+	extern KeyDataContainer ViKeys;
+	extern KeyDataContainer NagraKeys;
+	extern KeyDataContainer IrdetoKeys;
+	extern KeyDataContainer NDSKeys;
+	extern KeyDataContainer BissKeys;
+	extern KeyDataContainer PowervuKeys;
+	extern KeyDataContainer DreKeys;
+	extern uint8_t viasat_const[];
+
+	uint32_t GetOSemuVersion(void);
+	void set_emu_extee(struct s_reader *reader);
+	void set_emu_keyfile_path(char *path);
+	uint8_t read_emu_keyfile(char *path);
+
+#if !defined(__APPLE__) && !defined(__ANDROID__)
+	void read_emu_keymemory(void);
+#endif
+
+	int32_t CharToBin(uint8_t *out, char *in, uint32_t inLen);
+	
+	/* Error codes
+	0  OK
+	1  ECM not supported
+	2  Key not found
+	3  Nano80 problem
+	4  Corrupt data
+	5  CW not found
+	6  CW checksum error
+	7  Out of memory
+	*/
+	int8_t ProcessECM(struct s_reader *rdr, int16_t ecmDataLen, uint16_t caid, uint32_t provider, const uint8_t *ecm,
+					  uint8_t *dw, uint16_t srvid, uint16_t ecmpid);
+
+	char* GetProcessECMErrorReason(int8_t result);
+
+	/* Error codes
+	0  OK
+	1  EMM not supported
+	2  Key not found
+	3  Nano80 problem
+	4  Corrupt data
+	5
+	6  Checksum error
+	7  Out of memory
+	*/	
+	int8_t ProcessEMM(struct s_reader *rdr, uint16_t caid, uint32_t provider, const uint8_t *emm, uint32_t *keysAdded);
+	
+	char* GetProcessEMMErrorReason(int8_t result);			  
+
+	//hexserial must be of type "uint8_t hexserial[3]"
+	//returns 0 on error, 1 on success
+	int32_t GetIrdeto2Hexserial(uint16_t caid, uint8_t* hexserial);
+	
+	//hexserials must be of type "uint8_t hexserials[length][4]"
+	//if srvid == 0xFFFF all serials are returned (no srvid filtering)
+	//returns 0 on error, 1 on success
+	int32_t GetPowervuHexserials(uint16_t srvid, uint8_t hexserials[][4], int32_t length, int32_t* count);
+	
+	//hexserials must be of type "uint8_t hexserials[length]"
+	//returns 0 on error, 1 on success
+	int32_t GetDrecryptHexserials(uint16_t caid, uint8_t* hexserials, int32_t length, int32_t* count);
+	
+
+#define PVU_CW_VID 0	// VIDeo
+#define PVU_CW_HSD 1	// High Speed Data
+#define PVU_CW_A1 2		// Audio 1
+#define PVU_CW_A2 3		// Audio 2
+#define PVU_CW_A3 4		// Audio 3
+#define PVU_CW_A4 5		// Audio 4
+#define PVU_CW_UTL 6	// UTiLity
+#define PVU_CW_VBI 7	// Vertical Blanking Interval
+		  
+	int8_t PowervuECM(uint8_t *ecm, uint8_t *dw, emu_stream_client_data *cdata, int8_t global_cdata);
+		
+#endif
diff -ruN oscam-emu-2015-12-03-11142.orig/module-emulator-st20.c oscam-emu-2015-12-03-11142/module-emulator-st20.c
--- oscam-emu-2015-12-03-11142.orig/module-emulator-st20.c	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/module-emulator-st20.c	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,360 @@
+#include "globals.h"
+#include "module-emulator-st20.h"
+
+#define IPTR 0
+#define WPTR 1
+#define AREG 2
+#define BREG 3
+#define CREG 4
+
+#define FLASHS	0x7FE00000
+#define FLASHE	0x7FFFFFFF
+#define RAMS	0x40000000
+#define RAME	0x401FFFFF
+#define IRAMS	0x80000000
+#define IRAME	0x800017FF
+
+#define ERR_ILL_OP -1
+#define ERR_CNT    -2
+
+// ----------------------------------------------------------------
+
+#define STACKMAX  16
+#define STACKMASK (STACKMAX-1)
+
+typedef struct 
+{
+  uint32_t Iptr, Wptr;
+  uint8_t *flash, *ram;
+  uint32_t flashSize, ramSize;
+  int sptr, stack[STACKMAX];
+  uint8_t iram[0x1800];
+  int invalid;
+  int verbose;
+} st20_context_t;
+
+
+static void st20_set_flash(st20_context_t *ctx, uint8_t *m, int len);
+static void st20_set_ram(st20_context_t *ctx, uint8_t *m, int len);
+static void st20_init(st20_context_t *ctx, uint32_t IPtr, uint32_t WPtr, int verbose);
+static void st20_free(st20_context_t *ctx);
+
+static void st20_set_call_frame(st20_context_t *ctx, uint32_t raddr, int p1, int p2, int p3);
+
+
+static uint32_t st20_get_reg(st20_context_t *ctx, int reg);
+static void st20_set_reg(st20_context_t *ctx, int reg, uint32_t val);
+static uint8_t st20_rbyte(st20_context_t *ctx, uint32_t off);
+static void st20_wbyte(st20_context_t *ctx, uint32_t off, uint8_t val);
+static uint32_t st20_rword(st20_context_t *ctx, uint32_t off);
+static void st20_wword(st20_context_t *ctx, uint32_t off, uint32_t val);
+
+#define INVALID_VALUE	0xCCCCCCCC
+#define ERRORVAL		0xDEADBEEF
+
+#define MININT			0x7FFFFFFF
+#define MOSTPOS			0x7FFFFFFF
+#define MOSTNEG			0x80000000
+
+
+#define POP() ctx->stack[(ctx->sptr++)&STACKMASK]
+#define PUSH(v) do { int32_t __v=(v); ctx->stack[(--ctx->sptr)&STACKMASK]=__v; } while(0)
+#define DROP(n) ctx->sptr+=n
+
+#define AAA ctx->stack[ctx->sptr&STACKMASK]
+#define BBB ctx->stack[(ctx->sptr+1)&STACKMASK]
+#define CCC ctx->stack[(ctx->sptr+2)&STACKMASK]
+
+#define GET_OP()        operand|=op1&0x0F
+#define CLEAR_OP()      operand=0
+#define JUMP(x)         ctx->Iptr+=(x)
+#define POP64()         ({ uint32_t __b=POP(); ((uint64_t)POP()<<32)|__b; })
+#define PUSHPOP(op,val) do { int32_t __a=val; AAA op##= (__a); } while(0)
+
+#define RB(off) st20_rbyte(ctx, off)
+#define RW(off) st20_rword(ctx, off)
+#define WW(off,val) st20_wword(ctx, off, val)
+
+static uint32_t st20_get_reg(st20_context_t *ctx, int32_t reg)
+{
+	switch(reg) 
+	{
+		case IPTR: return ctx->Iptr;
+		case WPTR: return ctx->Wptr;
+		case AREG: return AAA;
+		case BREG: return BBB;
+		case CREG: return CCC;
+	}
+	return 0;
+}
+
+static void st20_set_reg(st20_context_t *ctx, int32_t reg, uint32_t val)
+{
+	switch(reg)
+	{
+		case IPTR: ctx->Iptr = val; return;
+		case WPTR: ctx->Wptr = val; return;
+		case AREG: AAA=val; return;
+		case BREG: BBB=val; return;
+		case CREG: CCC=val; return;
+	}
+}
+
+static uint8_t *st20_addr(st20_context_t *ctx, uint32_t off)
+{
+	if(off >= FLASHS && off <= FLASHE)
+	{
+		return &ctx->flash[off - FLASHS];
+	}
+	else if(off >= RAMS && off <= RAME)
+	{
+		return &ctx->ram[off - RAMS];
+	}
+	else if(off >= IRAMS && off <= IRAME)
+		return &ctx->iram[off - IRAMS];
+
+	ctx->invalid = ERRORVAL;
+	return (uint8_t *) &ctx->invalid;
+}
+
+static uint32_t st20_rword(st20_context_t *ctx, uint32_t off)
+{
+	uint8_t *temp;
+	temp = st20_addr(ctx, off);
+	
+	return ((temp[3]<<24) | (temp[2]<<16) | (temp[1]<<8) | temp[0]);
+}
+
+static uint16_t st20_rshort(st20_context_t *ctx, uint32_t off)
+{
+	uint8_t *temp;
+	temp = st20_addr(ctx, off);
+	
+	return ((temp[0]<<8) | temp[1]);
+}
+
+static uint8_t st20_rbyte(st20_context_t *ctx, uint32_t off)
+{
+	return *st20_addr(ctx, off);
+}
+
+static void st20_wword(st20_context_t *ctx, uint32_t off, uint32_t val)
+{
+	uint8_t *temp;
+	temp = st20_addr(ctx, off);
+	temp[3] = (val >> 24) & 0xFF;
+	temp[2] = (val >> 16) & 0xFF;
+	temp[1] = (val >> 8) & 0xFF;
+	temp[0] = val & 0xFF;
+}
+
+static void st20_wbyte(st20_context_t *ctx, uint32_t off, uint8_t val)
+{
+	uint8_t *temp;
+	temp = st20_addr(ctx, off);
+	temp[0] = val;
+}
+
+static int32_t st20_decode(st20_context_t *ctx, int32_t count)
+{
+	int32_t operand = 0;
+	CLEAR_OP();
+	while(ctx->Iptr != 0)
+	{
+		int32_t a, op1 = RB(ctx->Iptr++);
+		GET_OP();
+		switch(op1 >> 4)
+		{
+			case 0x0: // j / jump
+				JUMP(operand);
+				CLEAR_OP();
+				break;
+			case 0x1: // ldlp
+				PUSH(ctx->Wptr + (operand * 4));
+				CLEAR_OP();
+				break;
+			case 0x2: // positive prefix
+				operand <<= 4;
+				break;
+			case 0x3: // ldnl
+				AAA=RW(AAA + (operand * 4));
+				CLEAR_OP();
+				break;
+			case 0x4: // ldc
+				PUSH(operand);
+				CLEAR_OP();
+				break;
+			case 0x5: // ldnlp
+				PUSHPOP(+, operand * 4);
+				CLEAR_OP();
+				break;
+			case 0x6: // negative prefix
+				operand = (~operand) << 4;
+				break;
+			case 0x7: // ldl
+				PUSH(RW(ctx->Wptr + (operand * 4)));
+				CLEAR_OP();
+				break;
+			case 0x8: // adc
+				PUSHPOP(+, operand);
+				CLEAR_OP();
+				break;
+			case 0x9: // call
+				ctx->Wptr -= 16;
+				WW(ctx->Wptr, ctx->Iptr); WW(ctx->Wptr + 4, POP()); WW(ctx->Wptr + 8, POP()); WW(ctx->Wptr + 12, POP());
+				PUSH(ctx->Iptr);
+				JUMP(operand);
+				CLEAR_OP();
+				break;
+			case 0xA: // cj / conditional jump
+				if(AAA) { DROP(1); } else { JUMP(operand); }
+				CLEAR_OP();
+				break;
+			case 0xB: // ajw / adjust workspace
+				ctx->Wptr += operand * 4;
+				CLEAR_OP();
+				break;
+			case 0xC: // eqc / equals constant
+				AAA = (operand == AAA ? 1 : 0);
+				CLEAR_OP();
+				break;
+			case 0xD: // stl
+				WW(ctx->Wptr + (operand * 4), POP());
+				CLEAR_OP();
+				break;
+			case 0xE: // stnl
+				a = POP(); WW(a + (operand * 4), POP());
+				CLEAR_OP();
+				break;
+			case 0xF: // opr (secondary ins)
+				switch(operand)
+				{
+					case  0x00: a = AAA; AAA = BBB; BBB = a; break;
+					case  0x01: AAA = RB(AAA); break;
+					case  0x02: PUSHPOP(+, POP()); break;
+					case  0x04: PUSHPOP(-, POP()); break;
+					case  0x05: PUSHPOP(+, POP()); break;
+					case  0x06: a = AAA; AAA = ctx->Iptr; ctx->Iptr = a; break;
+					case  0x08: PUSHPOP(*, POP()); break;
+					case  0x09: a=POP(); AAA = (AAA > a); break;
+					case  0x0A: a=POP(); AAA = a + (AAA * 4); break;
+					case  0x0C: PUSHPOP(-, POP()); break;
+					case  0x1A: { a = POP(); uint64_t ll = POP64(); PUSH(ll % (uint32_t)a); PUSH(ll / (uint32_t)a); } break;
+					case  0x1B: PUSHPOP(+, ctx->Iptr); break;
+					case  0x1D: CCC = BBB; BBB = (AAA >= 0 ? 0 : -1); break;
+					case  0x1F: PUSHPOP(%, POP()); break;
+					case  0x20: ctx->Iptr = RW(ctx->Wptr); ctx->Wptr = ctx->Wptr + 16; break;
+					case  0x2C: PUSHPOP(/, POP()); break;
+					case  0x30: break;
+					case  0x32: AAA =~ AAA; break;
+					case  0x33: PUSHPOP(^, POP()); break;
+					case  0x34: PUSHPOP(*, 4); break;
+					case  0x35: { a = POP(); uint64_t ll = POP64() >> a; PUSH((ll >> 32) & 0xFFFFFFFF); PUSH(ll & 0xFFFFFFFF); } break;
+					case  0x36: { a = POP(); uint64_t ll = POP64() << a; PUSH((ll >> 32) & 0xFFFFFFFF); PUSH(ll & 0xFFFFFFFF); } break;
+					case  0x3B: a = POP(); st20_wbyte(ctx, a, POP()); break;
+					case  0x3F: a = POP(); PUSH(a & 3); PUSH((uint32_t)a >> 2); break;
+					case  0x40: a = POP(); AAA = (uint32_t)AAA >> a; break;
+					case  0x41: a = POP(); AAA = (uint32_t)AAA << a; break;
+					case  0x42: PUSH(MOSTNEG); break;
+					case  0x46: PUSHPOP(&, POP()); break;
+					case  0x4A: { a = POP(); int32_t b = POP(); int32_t c = POP(); while(a--) st20_wbyte(ctx, b++, st20_rbyte(ctx, c++)); } break;
+					case  0x4B: PUSHPOP(|, POP()); break;
+					case  0x53: PUSHPOP(*, POP()); break;
+					case  0x5A: PUSH(AAA); break;
+					case  0x5F: a = POP(); AAA = ((uint32_t)AAA > (uint32_t)a); break;
+					case  0x78: { a = POP(); int32_t b = POP(); int32_t bb = 0; while(a--){bb <<= 1; bb |= b & 1; b >>= 1;} PUSH(bb);} break;
+					case  0xCA: AAA = st20_rshort(ctx, AAA); break;
+					default: 
+					cs_log("[icg] unknown opcode %X", operand);
+					return ERR_ILL_OP;
+				}
+				CLEAR_OP();
+				break;
+			}
+		if(--count <= 0 && operand == 0) return ERR_CNT;
+	}
+	return 0;
+}
+
+static void st20_set_flash(st20_context_t *ctx, uint8_t *m, int32_t len)
+{
+	if(ctx->flash) free(ctx->flash);
+	ctx->flash = malloc(len);
+	if(ctx->flash && m) memcpy(ctx->flash, m, len);
+	else memset(ctx->flash, 0, len);
+	ctx->flashSize = len;
+}
+
+static void st20_set_ram(st20_context_t *ctx, uint8_t *m, int32_t len)
+{
+	if(ctx->ram) free(ctx->ram);
+	ctx->ram = malloc(len);
+	if(ctx->ram && m) memcpy(ctx->ram, m, len);
+	else memset(ctx->ram, 0, len);
+	ctx->ramSize = len;
+}
+
+static void st20_init(st20_context_t *ctx, uint32_t IPtr, uint32_t WPtr, int32_t verbose)
+{
+	ctx->Wptr = WPtr; ctx->Iptr = IPtr;
+	memset(ctx->stack, INVALID_VALUE, sizeof(ctx->stack)); ctx->sptr = STACKMAX - 3;
+	memset(ctx->iram, 0, sizeof(ctx->iram));
+	ctx->verbose = verbose;
+}
+
+static void st20_free(st20_context_t *ctx)
+{
+	if(ctx->flash) free(ctx->flash);
+	if(ctx->ram) free(ctx->ram);
+	ctx->flash = NULL;
+	ctx->ram = NULL;
+}
+
+static void st20_set_call_frame(st20_context_t *ctx, uint32_t raddr, int32_t p1, int32_t p2, int32_t p3)
+{
+	ctx->Wptr -= 16;
+	st20_wword(ctx, ctx->Wptr, raddr); // RET
+	st20_wword(ctx, ctx->Wptr + 4, p1);  //Areg
+	st20_wword(ctx, ctx->Wptr + 8, p1);  //Breg
+	st20_wword(ctx, ctx->Wptr + 12, p1); //Creg
+	st20_wword(ctx, ctx->Wptr + 16, p2);
+	st20_wword(ctx, ctx->Wptr + 20, p3);
+	st20_set_reg(ctx, AREG, raddr);    // RET
+}
+
+int st20_run(uint8_t* snip, uint32_t snip_len, int addr, uint8_t *data, uint16_t overcryptId)
+{
+	int error = 0, i, n;
+	st20_context_t ctx;
+
+	cs_log("[icg] decrypt address = 0x%X, id = %04X", addr, overcryptId);
+
+	cs_log("[icg] CW: %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X "
+											,data[0], data[1], data[2] , data[3] , data[4] , data[5] , data[6] , data[7]
+											,data[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15]);
+	for(n=0;n<2;n++)
+	{
+		memset(&ctx, 0, sizeof(st20_context_t));
+		st20_set_ram(&ctx, NULL, 0x1000);
+		st20_set_flash(&ctx, snip + 0x48, (int) (snip_len - 0x48));
+		st20_init(&ctx, FLASHS + addr, RAMS + 0x100, 1);
+		st20_set_call_frame(&ctx, 0, RAMS, RAMS, RAMS);
+		for(i = 0; i < 8; i++) st20_wbyte(&ctx, RAMS + i, data[i+n*8]);
+		if ((error = st20_decode(&ctx, 800000)) < 0) break;
+		cs_log("[icg] cw%d ret = %d, AREG = %X", n+1, error, st20_get_reg(&ctx, AREG));
+		for(i = 0; i < 8; i++) data[i+n*8] = st20_rbyte(&ctx, RAMS + i);
+		st20_free(&ctx);
+	}
+	
+	if(error < 0)
+	{
+		cs_log("[icg] st20 processing failed with error %d", error);
+		return 0;
+	}
+	
+	cs_log("[icg] DW: %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X "
+											,data[0], data[1], data[2] , data[3] , data[4] , data[5] , data[6] , data[7]
+											,data[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15]);
+	return 1;
+}
+
diff -ruN oscam-emu-2015-12-03-11142.orig/module-emulator-st20.h oscam-emu-2015-12-03-11142/module-emulator-st20.h
--- oscam-emu-2015-12-03-11142.orig/module-emulator-st20.h	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/module-emulator-st20.h	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,6 @@
+#ifndef ST20_H_
+#define ST20_H_
+
+	int st20_run(uint8_t* snip, uint32_t snip_len, int addr, uint8_t *data, uint16_t overcryptId);
+
+#endif
diff -ruN oscam-emu-2015-12-03-11142.orig/module-emulator-stream.c oscam-emu-2015-12-03-11142/module-emulator-stream.c
--- oscam-emu-2015-12-03-11142.orig/module-emulator-stream.c	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/module-emulator-stream.c	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,732 @@
+#include "globals.h"
+
+#ifdef WITH_EMU
+#include "cscrypt/des.h"
+#include "oscam-string.h"
+#include "oscam-config.h"
+#include "oscam-time.h"
+#else
+#include "des.h"
+#endif
+
+#include "ffdecsa/ffdecsa.h"
+#include "module-emulator-osemu.h"
+#include "module-emulator-stream.h"
+
+extern int32_t exit_oscam;
+int8_t stream_server_thread_init = 0;
+int32_t emu_stream_source_port = 8001;
+int32_t emu_stream_relay_port = 17999;
+
+#ifdef WITH_EMU
+pthread_mutex_t emu_fixed_key_data_mutex;
+emu_stream_client_data emu_fixed_key_data;
+uint16_t emu_stream_cur_srvid = 0;
+LLIST *ll_emu_stream_delayed_keys;
+int8_t stream_server_has_ecm = 0;
+#endif
+
+static int32_t glistenfd, gconnfd;
+
+static uint32_t CheckTsPackets(uint32_t packetSize, uint8_t *buf, uint32_t bufLength, uint16_t *packetCount)
+{
+	uint32_t i;
+	(*packetCount) = 0;
+	
+	for(i=packetSize; i<bufLength; i+=packetSize) {
+		if(buf[i] == 0x47) {
+			(*packetCount)++;
+		}	
+	}
+	
+	return (*packetCount);
+}
+
+static void SearchTsPackets(uint8_t *buf, uint32_t bufLength, uint16_t *packetCount, uint16_t *packetSize, uint16_t *startOffset)
+{
+	uint32_t i;
+	
+	(*packetCount) = 0;
+	(*packetSize) = 0;
+	(*startOffset) = 0;
+
+	for(i=0; i<bufLength; i++) {	
+		if(buf[i] == 0x47) {
+			if(CheckTsPackets(188, buf+i, bufLength-i, packetCount)) {
+				(*packetSize) = 188;
+				(*startOffset) = i;
+				return;
+			}
+			else if(CheckTsPackets(204, buf+i, bufLength-i, packetCount)) {
+				(*packetSize) = 204;
+				(*startOffset) = i;
+				return;
+			}
+			else if(CheckTsPackets(208, buf+i, bufLength-i, packetCount)) {
+				(*packetSize) = 208;
+				(*startOffset) = i;
+				return;
+			}					
+		}	
+		
+	}
+	
+	(*packetCount) = 0;
+}
+
+typedef void (*ts_data_callback)(emu_stream_client_data *cdata);
+
+static void ParseTSData(uint8_t table_id, uint8_t table_mask, uint8_t min_table_length, int8_t* flag, uint8_t* data,
+							uint16_t data_length, uint16_t* data_pos, int8_t payloadStart, uint8_t* buf, int32_t len,
+							ts_data_callback func, emu_stream_client_data *cdata)
+{
+	uint16_t section_length;
+	int32_t i;
+	int8_t found_start = 0;
+	uint16_t offset = 0;
+	int32_t free_data_length;
+	int32_t copySize;
+	
+	if(len < 1)
+		{ return; }
+	
+	if(*flag == 0 && !payloadStart)
+		{ return; }
+
+	if(*flag == 0)
+	{ 
+		*data_pos = 0;
+		 offset = 1 + buf[0];
+	}
+	else if(payloadStart)
+	{ 
+		offset = 1; 
+	}
+	
+	if(len-offset < 1)
+		{ return; }
+	
+	free_data_length = data_length - *data_pos;
+	copySize = (len-offset) > free_data_length ? free_data_length : (len-offset);
+	
+	memcpy(data+(*data_pos), buf+offset, copySize);	
+	(*data_pos) += copySize;
+
+	found_start = 0;
+	for(i=0; i < *data_pos; i++)
+	{
+		if((data[i] & table_mask) == table_id)
+		{
+			if(i != 0)
+			{
+				if((*data_pos)-i > i)
+					{ memmove(data, &data[i], (*data_pos)-i); }
+				else
+					{ memcpy(data, &data[i], (*data_pos)-i); }
+			
+				*data_pos -= i;
+			}
+			found_start = 1;
+			break;
+		}	
+	}
+	if(!found_start)
+		{ *flag = 0; return; }
+
+	*flag = 2;
+
+	if(*data_pos < 3)
+		{ return; }
+
+	section_length = SCT_LEN(data);
+
+	if(section_length > data_length || section_length < min_table_length)
+		{ *flag = 0; return; }
+	
+	if((*data_pos) < section_length)
+		{ return; }
+
+	func(cdata);
+	
+	found_start = 0;
+	for(i=section_length; i < *data_pos; i++)
+	{
+		if((data[i] & table_mask) == table_id)
+		{
+			if((*data_pos)-i > i)
+				{ memmove(data, &data[i], (*data_pos)-i); }
+			else
+				{ memcpy(data, &data[i], (*data_pos)-i); }
+			
+			*data_pos -= i;
+			found_start = 1;
+			break;
+		}	
+	}	
+	if(!found_start)
+		{ *data_pos = 0; }
+	
+	*flag = 1;
+}
+
+static void ParsePATData(emu_stream_client_data *cdata)
+{
+	uint8_t* data = cdata->data;
+	uint16_t section_length = SCT_LEN(data);
+	uint16_t srvid;
+	int32_t i;
+
+	for(i=8; i+7<section_length; i+=4)
+	{
+		srvid = b2i(2, data+i);
+		
+		if(srvid == 0)
+			{ continue; }
+		
+		if(cdata->srvid == srvid)
+		{
+			cdata->pmt_pid = b2i(2, data+i+2) & 0x1FFF;
+			cs_log_dbg(D_READER, "[Emu] stream found pmt pid: %X", cdata->pmt_pid);
+			break;
+		}
+	}
+}
+
+static void ParsePMTData(emu_stream_client_data *cdata)
+{
+	uint8_t* data = cdata->data;
+	
+	uint16_t section_length = SCT_LEN(data);
+	int32_t i;
+	uint16_t program_info_length = 0, es_info_length = 0;
+	uint8_t descriptor_tag = 0, descriptor_length = 0;
+	uint8_t stream_type;
+	uint16_t stream_pid, caid;
+	
+	program_info_length = b2i(2, data+10) &0xFFF;
+	
+	if(12+program_info_length >= section_length)
+		{ return; }
+	
+	for(i=12; i+1 < 12+program_info_length; i+=descriptor_length)
+	{
+		descriptor_tag = data[i];
+		descriptor_length = data[i+1];
+		
+		if(descriptor_length < 1)
+			{ break; }
+			
+		if(i+1+descriptor_length >= 12+program_info_length)
+			{ break; }
+		
+		if(descriptor_tag == 0x09 && descriptor_length >= 4)
+		{
+			caid = b2i(2, data+i+2);
+			
+			if(caid>>8 == 0x0E)
+			{
+		    	cdata->ecm_pid = b2i(2, data+i+4) &0x1FFF;
+		    	cs_log_dbg(D_READER, "[Emu] stream found ecm_pid: %X", cdata->ecm_pid);
+		    	break;
+		    }
+		}
+	}
+		
+	for(i=12+program_info_length; i+4<section_length; i+=5+es_info_length)
+	{
+		stream_type = data[i];
+		stream_pid = b2i(2, data+i+1) &0x1FFF;
+		es_info_length = b2i(2, data+i+3) &0xFFF;
+		
+		if(stream_type == 0x01 || stream_type == 0x02 || stream_type == 0x10 || stream_type == 0x1B 
+			|| stream_type == 0x24 || stream_type == 0x42 || stream_type == 0xD1 || stream_type == 0xEA) 
+		{ 
+			cdata->video_pid = stream_pid;
+			cs_log_dbg(D_READER, "[Emu] stream found video pid: %X", stream_pid);
+		}
+		
+		if(stream_type == 0x03 || stream_type == 0x04 || stream_type == 0x06 || stream_type == 0x0F 
+			|| stream_type == 0x11 || (stream_type >= 0x80 && stream_type <= 0x87))
+		{
+			if(cdata->audio_pid_count >= 4)
+				{ continue; }
+			
+			cdata->audio_pids[cdata->audio_pid_count] = stream_pid;
+			cdata->audio_pid_count++;
+			cs_log_dbg(D_READER, "[Emu] stream found audio pid: %X", stream_pid);
+		}
+	}
+}
+
+static void ParseECMData(emu_stream_client_data *cdata)
+{
+	uint8_t* data = cdata->data;
+	uint16_t section_length = SCT_LEN(data);
+	uint8_t dcw[16];
+	
+	if(section_length < 0xb)
+		{ return; }
+
+	if(data[0xb] > cdata->ecm_nb || (cdata->ecm_nb == 255 && data[0xb] == 0)
+		|| ((cdata->ecm_nb - data[0xb]) > 5))
+	{
+		cdata->ecm_nb = data[0xb];
+		PowervuECM(data, dcw, cdata, 0);
+	}
+}
+
+static void ParseTSPackets(emu_stream_client_data *data, uint8_t *stream_buf, uint16_t packetCount, uint16_t packetSize)
+{
+	uint32_t i, j;
+	uint32_t tsHeader;
+	uint16_t pid, offset;
+	uint8_t scramblingControl, payloadStart;
+	int8_t oddKeyUsed;
+	uint32_t *deskey;
+	uint8_t *pdata;
+	uint8_t *packetCluster[3];
+	void *csakey;
+	emu_stream_client_data *keydata;
+	
+	for(i=0; i<packetCount; i++)
+	{		
+		tsHeader = b2i(4, stream_buf+(i*packetSize));
+		pid = (tsHeader & 0x1fff00) >> 8;
+		scramblingControl = tsHeader & 0xc0;
+		payloadStart = (tsHeader & 0x400000) >> 22;
+
+		if(tsHeader & 0x20)
+			{ offset = 4 + stream_buf[(i*packetSize)+4] + 1; }
+		else
+			{ offset = 4; }
+		
+		if(packetSize-offset < 1)
+			{ continue; }
+		
+		if(data->have_pat_data != 1)
+		{					
+			if(pid == 0)
+			{ 
+				ParseTSData(0x00, 0xFF, 16, &data->have_pat_data, data->data, sizeof(data->data), &data->data_pos, payloadStart, 
+								stream_buf+(i*packetSize)+offset, packetSize-offset, ParsePATData, data);
+			}
+		
+			continue;
+		}
+
+		if(!data->pmt_pid)
+		{
+			data->have_pat_data = 0;
+			continue;
+		}
+
+		if(data->have_pmt_data != 1)
+		{
+			if(pid == data->pmt_pid)
+			{
+				ParseTSData(0x02, 0xFF, 21, &data->have_pmt_data, data->data, sizeof(data->data), &data->data_pos, payloadStart, 
+								stream_buf+(i*packetSize)+offset, packetSize-offset, ParsePMTData, data);
+			}
+		
+			continue;
+		}
+
+		if(data->ecm_pid && pid == data->ecm_pid)
+		{
+#ifdef WITH_EMU
+			stream_server_has_ecm = 1;
+#endif
+			
+			ParseTSData(0x80, 0xFE, 10, &data->have_ecm_data, data->data, sizeof(data->data), &data->data_pos, payloadStart, 
+							stream_buf+(i*packetSize)+offset, packetSize-offset, ParseECMData, data);
+			continue;
+		}
+		
+		if(scramblingControl == 0)
+			{ continue; }
+		
+		if(!(stream_buf[(i*packetSize)+3] & 0x10))
+		{
+			stream_buf[(i*packetSize)+3] &= 0x3F;
+			continue;
+		}
+
+		oddKeyUsed = scramblingControl == 0xC0 ? 1 : 0;
+
+#ifdef WITH_EMU	
+		if(!stream_server_has_ecm)
+		{
+			keydata = &emu_fixed_key_data;
+			SAFE_MUTEX_LOCK(&emu_fixed_key_data_mutex); 
+		}
+		else
+		{
+#endif
+			keydata = data;
+#ifdef WITH_EMU
+		}
+#endif
+		
+		if(keydata->pvu_csa_used)
+		{
+			csakey = NULL;
+			
+			if(pid == data->video_pid)
+				{ csakey = keydata->pvu_csa_ks[PVU_CW_VID]; }
+			else
+			{
+				for(j=0; j<data->audio_pid_count; j++)
+					if(pid == data->audio_pids[j])
+						{ csakey = keydata->pvu_csa_ks[PVU_CW_A1+j]; }
+			}
+			
+			if(csakey != NULL)
+			{					
+				packetCluster[0] = stream_buf+(i*packetSize);
+				packetCluster[1] = stream_buf+((i+1)*packetSize);
+				packetCluster[2] = NULL;
+
+				decrypt_packets(csakey, packetCluster);
+			}			
+		}
+		else
+		{
+			deskey = NULL;
+			
+			if(pid == data->video_pid)
+				{ deskey = keydata->pvu_des_ks[PVU_CW_VID][oddKeyUsed]; }
+			else
+			{
+				for(j=0; j<data->audio_pid_count; j++)
+					if(pid == data->audio_pids[j])
+						{ deskey = keydata->pvu_des_ks[PVU_CW_A1+j][oddKeyUsed]; }
+			}
+			
+			if(deskey != NULL)
+			{					
+				for(j=offset; j+7<188; j+=8)
+				{
+					pdata = stream_buf+(i*packetSize)+j;
+					des(pdata, deskey, 0);
+				}
+				
+				stream_buf[(i*packetSize)+3] &= 0x3F;
+			}
+		}
+
+#ifdef WITH_EMU	
+		if(!stream_server_has_ecm)
+		{
+			SAFE_MUTEX_UNLOCK(&emu_fixed_key_data_mutex); 
+		}
+#endif
+	}
+}
+
+static int32_t connect_to_stream(char *http_buf, int32_t http_buf_len, char *stream_path)
+{
+	struct sockaddr_in cservaddr;
+		
+	int32_t streamfd = socket(AF_INET, SOCK_STREAM, 0);
+	if(streamfd == -1)
+		{ return -1; }
+	
+	bzero(&cservaddr, sizeof(cservaddr));
+	cservaddr.sin_family = AF_INET;
+	cservaddr.sin_addr.s_addr = inet_addr("127.0.0.1");
+	cservaddr.sin_port = htons(emu_stream_source_port);
+	
+	if(connect(streamfd, (struct sockaddr *)&cservaddr, sizeof(cservaddr)) == -1)
+		{ return -1; }
+			
+	snprintf(http_buf, http_buf_len, "GET %s HTTP/1.1\nHost: localhost:%u\n"
+				"User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0\n"
+				"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\n"
+				"Accept-Language: en-US\n"
+				"Connection: keep-alive\n\n", stream_path, emu_stream_source_port);
+
+	if(send(streamfd, http_buf, strlen(http_buf), 0) == -1)
+		{ return -1; }
+		
+	return streamfd;	
+}
+
+static void handle_stream_client(int32_t connfd)
+{
+#define EMU_DVB_MAX_TS_PACKETS 32
+#define EMU_DVB_BUFFER_SIZE 1+188*EMU_DVB_MAX_TS_PACKETS
+#define EMU_DVB_BUFFER_WAIT 1+188*(EMU_DVB_MAX_TS_PACKETS-3)
+
+	char *http_buf, stream_path[255], stream_path_copy[255];
+	int32_t streamfd;
+	int32_t clientStatus, streamStatus;
+	uint8_t *stream_buf;
+	uint16_t packetCount = 0, packetSize = 0, startOffset = 0;
+	uint32_t remainingDataPos, remainingDataLength;
+	int32_t bytesRead = 0;
+	emu_stream_client_data *data;
+	int8_t streamErrorCount = 0;
+	int32_t i, srvidtmp;
+	char *saveptr, *token;
+	
+	if(!cs_malloc(&http_buf, 1024))
+	{
+		close(connfd);
+		return;
+	}
+	
+	if(!cs_malloc(&stream_buf, EMU_DVB_BUFFER_SIZE))
+	{
+		close(connfd);
+		NULLFREE(http_buf);
+		return;
+	}
+	
+	if(!cs_malloc(&data, sizeof(emu_stream_client_data)))
+	{
+		close(connfd);
+		NULLFREE(http_buf);
+		NULLFREE(stream_buf);
+		return;
+	}
+	
+	clientStatus = recv(connfd, http_buf, 1024, 0);
+	if(clientStatus < 1)
+	{
+		close(connfd);
+		NULLFREE(http_buf);
+		NULLFREE(stream_buf);
+		NULLFREE(data);
+		return;		
+	}
+	
+	http_buf[1023] = '\0';
+	if(sscanf(http_buf, "GET %254s ", stream_path) < 1)
+	{
+		close(connfd);
+		NULLFREE(http_buf);
+		NULLFREE(stream_buf);
+		NULLFREE(data);
+		return;
+	}
+	
+	cs_strncpy(stream_path_copy, stream_path, sizeof(stream_path));
+	
+	token = strtok_r(stream_path_copy, ":", &saveptr);
+
+	for(i=0; token != NULL && i<3; i++)
+	{
+		token = strtok_r(NULL, ":", &saveptr);
+		if(token == NULL)
+			{ break; }
+	}
+	if(token != NULL)
+	{
+		if(sscanf(token, "%x", &srvidtmp) < 1)
+		{
+			token = NULL;	
+		}
+		else
+		{
+			data->srvid = srvidtmp & 0xFFFF;
+		}
+	}
+
+	if(token == NULL)
+	{
+		close(connfd);
+		NULLFREE(http_buf);
+		NULLFREE(stream_buf);
+		NULLFREE(data);
+		return;
+	}
+
+#ifdef WITH_EMU
+	emu_stream_cur_srvid = data->srvid;
+	stream_server_has_ecm = 0;
+#endif
+
+	cs_log("[Emu] stream client connected with request %s", stream_path);
+
+	snprintf(http_buf, 1024, "HTTP/1.0 200 OK\nConnection: Close\nContent-Type: video/mpeg\nServer: stream_enigma2\n\n");
+	clientStatus = send(connfd, http_buf, strlen(http_buf), 0);
+
+	while(!exit_oscam && clientStatus != -1 && streamErrorCount < 3)
+	{		
+		streamfd = connect_to_stream(http_buf, 1024, stream_path);
+		if(streamfd == -1)
+		{
+			cs_log("[Emu] warning: cannot connect to stream source");
+			streamErrorCount++;
+			cs_sleepms(100);
+			continue;	
+		}
+
+		streamErrorCount = 0;
+		streamStatus = 0;
+
+		while(!exit_oscam && clientStatus != -1 && streamStatus != -1)
+		{
+			streamStatus = recv(streamfd, stream_buf+bytesRead, EMU_DVB_BUFFER_SIZE-bytesRead, 0);
+			if(streamStatus == -1)
+				{ break; }
+		
+			bytesRead += streamStatus;
+			
+			if(bytesRead >= EMU_DVB_BUFFER_WAIT)
+			{	
+				SearchTsPackets(stream_buf, bytesRead, &packetCount, &packetSize, &startOffset);
+				
+				if(packetCount <= 0)
+				{
+					bytesRead = 0;
+				}
+				else
+				{
+					ParseTSPackets(data, stream_buf+startOffset, packetCount, packetSize);
+					
+					clientStatus = send(connfd, stream_buf+startOffset, packetCount*packetSize, 0);
+						 
+					remainingDataPos = startOffset+(packetCount*packetSize);
+					remainingDataLength = bytesRead-remainingDataPos;
+					
+					if(remainingDataPos < remainingDataLength)
+						{ memmove(stream_buf, stream_buf+remainingDataPos, remainingDataLength); }
+					else
+						{ memcpy(stream_buf, stream_buf+remainingDataPos, remainingDataLength); }
+					
+					bytesRead = remainingDataLength;
+				}
+			}
+		}
+		
+		close(streamfd);
+	}
+	
+	close(connfd);
+	NULLFREE(http_buf);
+	NULLFREE(stream_buf);
+	for(i=0; i<8; i++)
+	{
+		if(data->pvu_csa_ks[i])
+			{ free_key_struct(data->pvu_csa_ks[i]); }	
+	}
+	NULLFREE(data);
+}
+
+void *stream_server(void *UNUSED(a))
+{
+	struct sockaddr_in servaddr, cliaddr;
+	socklen_t clilen;
+	int32_t reuse = 1;
+	
+	glistenfd = socket(AF_INET, SOCK_STREAM, 0);
+	if(glistenfd == -1)
+	{
+		cs_log("[Emu] error: cannot create stream server socket");
+		return NULL;
+	}
+
+	bzero(&servaddr,sizeof(servaddr));
+	servaddr.sin_family = AF_INET;
+	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
+	servaddr.sin_port = htons(emu_stream_relay_port);
+	setsockopt(glistenfd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));
+	
+	if(bind(glistenfd,(struct sockaddr *)&servaddr, sizeof(servaddr)) == -1)
+	{
+		cs_log("[Emu] error: cannot bind to stream server socket");
+		close(glistenfd);
+		return NULL;
+	}
+	
+	if(listen(glistenfd, 3) == -1)
+	{
+		cs_log("[Emu] error: cannot listen to stream server socket");
+		close(glistenfd);
+		return NULL;
+	}
+
+	while(!exit_oscam)
+  	{
+		clilen = sizeof(cliaddr);
+		gconnfd = accept(glistenfd,(struct sockaddr *)&cliaddr, &clilen);
+
+		if(gconnfd == -1)
+		{
+			cs_log("[Emu] error: accept() failed");
+			break;
+		}
+		
+		handle_stream_client(gconnfd);
+		cs_log("[Emu] stream client disconnected");
+	} 
+	
+	close(glistenfd);
+	
+	return NULL;
+}
+
+#ifdef WITH_EMU
+void *stream_key_delayer(void *UNUSED(a))
+{
+	int32_t j;
+	emu_stream_client_data* cdata = &emu_fixed_key_data;
+	emu_stream_cw_item *item;
+	
+	while(!exit_oscam)
+	{
+		item = ll_remove_first(ll_emu_stream_delayed_keys);
+		
+		if(item)
+		{
+			cs_sleepms(cfg.emu_stream_ecm_delay);
+	    	
+			SAFE_MUTEX_LOCK(&emu_fixed_key_data_mutex);
+	    	
+			for(j=0; j<8; j++)
+			{
+				if(item->csa_used)
+				{	
+					if(cdata->pvu_csa_ks[j] == NULL)
+						{  cdata->pvu_csa_ks[j] = get_key_struct(); }
+						
+					if(item->is_even)
+						{ set_even_control_word(cdata->pvu_csa_ks[j], item->cw[j]); }
+					else
+						{ set_odd_control_word(cdata->pvu_csa_ks[j], item->cw[j]); }
+					
+					cdata->pvu_csa_used = 1;
+				}
+				else
+				{					
+					if(item->is_even)
+						{ des_set_key(item->cw[j], cdata->pvu_des_ks[j][0]); }
+					else
+						{ des_set_key(item->cw[j], cdata->pvu_des_ks[j][1]); }
+						
+					cdata->pvu_csa_used = 0;
+				}
+			}
+							
+			SAFE_MUTEX_UNLOCK(&emu_fixed_key_data_mutex);
+			
+			free(item);
+		}
+		else
+		{
+			cs_sleepms(50);	
+		}
+	}
+	
+	return NULL;
+}
+#endif
+
+void stop_stream_server(void)
+{
+	shutdown(gconnfd, 2);
+	shutdown(glistenfd, 2);
+	close(gconnfd);
+	close(glistenfd);	
+}
diff -ruN oscam-emu-2015-12-03-11142.orig/module-emulator-stream.h oscam-emu-2015-12-03-11142/module-emulator-stream.h
--- oscam-emu-2015-12-03-11142.orig/module-emulator-stream.h	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/module-emulator-stream.h	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,48 @@
+#ifndef EMU_STREAM_SERVER_H_
+#define EMU_STREAM_SERVER_H_
+
+	typedef struct 
+	{
+		int8_t have_pat_data;
+		int8_t have_pmt_data;
+		int8_t have_ecm_data;
+		uint8_t data[1024+208];
+		uint16_t data_pos;
+		uint16_t srvid;
+		uint16_t pmt_pid;
+		uint16_t ecm_pid;
+		uint16_t video_pid;
+		uint16_t audio_pids[4];
+		uint8_t audio_pid_count;
+		int16_t ecm_nb;
+		uint32_t pvu_des_ks[8][2][32];
+		int8_t pvu_csa_used;
+		void* pvu_csa_ks[8];
+	} emu_stream_client_data;
+
+	extern int32_t emu_stream_source_port;
+	extern int32_t emu_stream_relay_port;
+	
+	extern int8_t stream_server_thread_init;
+	
+	void *stream_server(void *a);
+	void stop_stream_server(void);
+	
+#ifdef WITH_EMU
+	typedef struct
+	{
+		int8_t csa_used;
+		int8_t is_even;
+		uint8_t cw[8][8];
+	} emu_stream_cw_item;
+	
+	extern LLIST *ll_emu_stream_delayed_keys;
+	extern pthread_mutex_t emu_fixed_key_data_mutex;
+	extern emu_stream_client_data emu_fixed_key_data;
+	extern uint16_t emu_stream_cur_srvid;
+	extern int8_t stream_server_has_ecm;
+		
+	void *stream_key_delayer(void *a);
+#endif
+
+#endif
diff -ruN oscam-emu-2015-12-03-11142.orig/module-gbox.c oscam-emu-2015-12-03-11142/module-gbox.c
--- oscam-emu-2015-12-03-11142.orig/module-gbox.c	2015-11-01 19:25:12.000000000 +0300
+++ oscam-emu-2015-12-03-11142/module-gbox.c	2015-12-04 00:43:30.000000000 +0300
@@ -1299,7 +1299,7 @@
 	if(!cli->gbox || !cli->reader->tcp_connected)
 	{
 		cs_log_dbg(D_READER, "%s server not init!", cli->reader->label);
-		write_ecm_answer(cli->reader, er, E_NOTFOUND, 0x27, NULL, NULL, 0, NULL);
+		write_ecm_answer(cli->reader, er, E_NOTFOUND, 0x27, NULL, NULL, 0 , NULL);
 		return -1;
 	}
 
diff -ruN oscam-emu-2015-12-03-11142.orig/module-monitor.c oscam-emu-2015-12-03-11142/module-monitor.c
--- oscam-emu-2015-12-03-11142.orig/module-monitor.c	2015-11-12 07:19:54.000000000 +0300
+++ oscam-emu-2015-12-03-11142/module-monitor.c	2015-12-04 00:43:30.000000000 +0300
@@ -16,6 +16,7 @@
 #include "oscam-work.h"
 
 extern char *entitlement_type[];
+extern uint8_t cs_http_use_utf8;
 
 struct monitor_data
 {
@@ -119,6 +120,7 @@
 	req_ts.tv_sec = 0;
 	req_ts.tv_nsec = 500000;
 	nanosleep(&req_ts, NULL); //avoid lost udp-pakkets
+	if(0 /* cs_http_use_utf8 */) utf8c1251(txt);
 	if(!cl->crypted)
 		{ return sendto(cl->udp_fd, txt, strlen(txt), 0, (struct sockaddr *)&cl->udp_sa, cl->udp_sa_len); }
 	l = strlen(txt);
diff -ruN oscam-emu-2015-12-03-11142.orig/module-newcamd-des.c oscam-emu-2015-12-03-11142/module-newcamd-des.c
--- oscam-emu-2015-12-03-11142.orig/module-newcamd-des.c	2015-07-07 22:06:46.000000000 +0300
+++ oscam-emu-2015-12-03-11142/module-newcamd-des.c	2015-12-04 00:43:30.000000000 +0300
@@ -5,10 +5,7 @@
 #define DES_IP              1
 #define DES_IP_1            2
 #define DES_RIGHT           4
-#define DES_HASH            8
 
-#define DES_ECM_CRYPT       0
-#define DES_ECM_HASH        DES_HASH
 #define DES_ECS2_DECRYPT    (DES_IP | DES_IP_1 | DES_RIGHT)
 #define DES_ECS2_CRYPT      (DES_IP | DES_IP_1)
 
@@ -356,7 +353,7 @@
 	swap(data - 4, data);
 }
 
-static void nc_des(unsigned char key[], unsigned char mode, unsigned char data[])
+void nc_des(unsigned char key[], unsigned char mode, unsigned char data[])
 {
 	unsigned char i;
 	unsigned char left[8];
diff -ruN oscam-emu-2015-12-03-11142.orig/module-newcamd-des.h oscam-emu-2015-12-03-11142/module-newcamd-des.h
--- oscam-emu-2015-12-03-11142.orig/module-newcamd-des.h	2015-07-07 22:06:46.000000000 +0300
+++ oscam-emu-2015-12-03-11142/module-newcamd-des.h	2015-12-04 00:43:30.000000000 +0300
@@ -1,8 +1,15 @@
 #ifndef MODULE_NEWCAMD_DES_H_
 #define MODULE_NEWCAMD_DES_H_
 
+#define DES_HASH            8
+
+#define DES_ECM_CRYPT       0
+#define DES_ECM_HASH        DES_HASH
+
 	int nc_des_encrypt(unsigned char *buffer, int len, unsigned char *deskey);
 	int nc_des_decrypt(unsigned char *buffer, int len, unsigned char *deskey);
 	unsigned char *nc_des_login_key_get(unsigned char *key1, unsigned char *key2, int len, unsigned char *des16);
 
+	void nc_des(unsigned char key[], unsigned char mode, unsigned char data[]);
+
 #endif
diff -ruN oscam-emu-2015-12-03-11142.orig/module-stat.c oscam-emu-2015-12-03-11142/module-stat.c
--- oscam-emu-2015-12-03-11142.orig/module-stat.c	2015-07-03 01:38:58.000000000 +0300
+++ oscam-emu-2015-12-03-11142/module-stat.c	2015-12-04 00:43:30.000000000 +0300
@@ -886,7 +886,7 @@
 
 uint16_t get_rdr_caid(struct s_reader *rdr)
 {
-	if(is_network_reader(rdr))
+	if(is_network_reader(rdr) || rdr->typ == R_EMU)
 	{
 		return 0; //reader caid is not real caid
 	}
@@ -1284,7 +1284,7 @@
 		for(ea = er->matching_rdr; ea; ea = ea->next)
 		{
 			rdr = ea->reader;
-			if(is_network_reader(rdr))    //reader caid is not real caid
+			if(is_network_reader(rdr) || rdr->typ == R_EMU)    //reader caid is not real caid
 			{
 				prv = ea;
 				continue; // proxy can convert or reject
diff -ruN oscam-emu-2015-12-03-11142.orig/module-webif.c oscam-emu-2015-12-03-11142/module-webif.c
--- oscam-emu-2015-12-03-11142.orig/module-webif.c	2015-11-12 07:19:54.000000000 +0300
+++ oscam-emu-2015-12-03-11142/module-webif.c	2015-12-04 00:43:30.000000000 +0300
@@ -98,6 +98,7 @@
 #define MNU_CFG_LCD			14
 #define MNU_CFG_MONITOR		15
 #define MNU_CFG_WEBIF		16
+#define MNU_CFG_STREAMRELAY 17
 
 /* constants for files.html submenuactivating */
 #define MNU_CFG_FVERSION	0
@@ -119,8 +120,8 @@
 #define MNU_CFG_FCSS		16
 #define MNU_CFG_FTWIN		17
 #define MNU_CFG_FKEYCW 18
-
-#define MNU_CFG_TOTAL_ITEMS 19 // sum of config or files submenuactivating above. Use it for "All inactive" in function calls too.
+#define MNU_CFG_KEY 19
+#define MNU_CFG_TOTAL_ITEMS 20 // sum of items above. Use it for "All inactive" in function calls too.
 
 static void set_status_info_var(struct templatevars *vars, char *varname, int no_data, char *fmt, double value) {
 	if (no_data)
@@ -942,6 +943,23 @@
 }
 #endif
 
+#ifdef WITH_EMU
+#include "module-emulator-stream.h"
+
+static char *send_oscam_config_streamrelay(struct templatevars *vars, struct uriparams *params)
+{
+	setActiveSubMenu(vars, MNU_CFG_STREAMRELAY);
+
+	webif_save_config("streamrelay", vars, params);
+
+	tpl_printf(vars, TPLADD, "STREAM_SOURCE_PORT", "%d", cfg.emu_stream_source_port);
+	tpl_printf(vars, TPLADD, "STREAM_RELAY_PORT", "%d", cfg.emu_stream_relay_port);
+	tpl_printf(vars, TPLADD, "STREAM_ECM_DELAY", "%d", cfg.emu_stream_ecm_delay);
+	
+	return tpl_getTpl(vars, "CONFIGSTREAMRELAY");
+}
+#endif
+
 #ifdef MODULE_CCCAM
 static char *send_oscam_config_cccam(struct templatevars *vars, struct uriparams *params)
 {
@@ -1277,7 +1295,7 @@
 	//extended_cw_api
 	tpl_printf(vars, TPLADD, "TMP", "EXTENDEDCWAPISELECTED%d", cfg.dvbapi_extended_cw_api);
 	tpl_addVar(vars, TPLADD, tpl_getVar(vars, "TMP"), "selected");
-
+	
 	//write_sdt_prov
 	if(cfg.dvbapi_write_sdt_prov > 0)
 		{ tpl_addVar(vars, TPLADD, "WRITESDTPROVCHECKED", "checked"); } 
@@ -1355,6 +1373,9 @@
 #ifdef MODULE_SCAM
 	else if(!strcmp(part, "scam")) { return send_oscam_config_scam(vars, params); }
 #endif
+#ifdef WITH_EMU
+	else if(!strcmp(part, "streamrelay")) { return send_oscam_config_streamrelay(vars, params); }
+#endif
 #ifdef MODULE_CCCAM
 	else if(!strcmp(part, "cccam")) { return send_oscam_config_cccam(vars, params); }
 #endif
@@ -1793,7 +1814,7 @@
 		chk_reader("services", servicelabels, rdr);
 		chk_reader("lb_whitelist_services", servicelabelslb, rdr);
 
-		if(is_network_reader(rdr))    //physical readers make trouble if re-started
+		if(is_network_reader(rdr) || rdr->typ == R_EMU)    //physical readers make trouble if re-started
 		{
 			restart_cardreader(rdr, 1);
 		}
@@ -2350,6 +2371,13 @@
 	tpl_printf(vars, TPLADD, "GBOXRESHARE",   "%d", rdr->gbox_reshare);
 #endif
 
+#ifdef WITH_EMU
+	//emu_auproviders
+	value = mk_t_ftab(&rdr->emu_auproviders);
+	tpl_addVar(vars, TPLADD, "EMUAUPROVIDERS", value);
+	free_mk_t(value);
+#endif
+
 	tpl_addVar(vars, TPLADD, "PROTOCOL", reader_get_type_desc(rdr, 0));
 
 	// Show only parameters which needed for the reader
@@ -2370,6 +2398,9 @@
 	case R_CAMD35 :
 		tpl_addVar(vars, TPLAPPEND, "READERDEPENDINGCONFIG", tpl_getTpl(vars, "READERCONFIGCAMD35BIT"));
 		break;
+	case R_EMU :
+		tpl_addVar(vars, TPLAPPEND, "READERDEPENDINGCONFIG", tpl_getTpl(vars, "READERCONFIGEMUBIT"));
+		break;
 	case R_CS378X :
 		tpl_addVar(vars, TPLAPPEND, "READERDEPENDINGCONFIG", tpl_getTpl(vars, "READERCONFIGCS378XBIT"));
 		break;
@@ -4047,9 +4078,38 @@
 
 					tpl_addVar(vars, TPLAPPEND, "LOGHISTORY", "<BR><BR>New Structure:<BR>");
 					char tbuffer[83];
+#ifdef WITH_EMU					
+					char keyBuffer[1024];
+#endif
 					int jsondelimiter = 0;
 					while((item = ll_iter_next(&itr)))
 					{
+#ifdef WITH_EMU						
+						if(item->isKey) {
+							tpl_addVar(vars, TPLADD, "ENTSTARTDATE", "");
+							tpl_addVar(vars, TPLADD, "ENTENDDATE", "");
+							cs_hexdump(0, item->key, item->keyLength, keyBuffer, sizeof(keyBuffer));
+							tpl_addVar(vars, TPLADD, "ENTEXPIERED", "e_valid");
+							tpl_printf(vars, TPLADD, "ENTCAID", "%04X", item->caid);
+							if(item->caid == 0x2600) {
+								tpl_printf(vars, TPLADD, "ENTPROVID", "%08X", item->provid);
+							}
+							else {
+								tpl_printf(vars, TPLADD, "ENTPROVID", "%06X", item->provid);
+							}
+							tpl_addVar(vars, TPLADD, "ENTID", item->name);
+							tpl_addVar(vars, TPLADD, "ENTCLASS", keyBuffer);
+							if(item->isData) { tpl_addVar(vars, TPLADD, "ENTTYPE", "data"); }
+							else { tpl_addVar(vars, TPLADD, "ENTTYPE", "key"); }
+							tpl_addVar(vars, TPLADD, "ENTRESNAME", "");
+
+							if((strcmp(getParam(params, "hideexpired"), "1") != 0) || (item->end > now))
+								{ tpl_addVar(vars, TPLAPPEND, "READERENTENTRY", tpl_getTpl(vars, "ENTITLEMENTITEMBIT")); }							
+						
+							continue;	
+						}
+#endif
+
 						localtime_r(&item->start, &start_t);
 						localtime_r(&item->end, &end_t);
 
@@ -4515,6 +4575,9 @@
 #else
 						filtered = (type == cl->typ);
 #endif
+#ifdef WITH_EMU
+                        if(type == 'e' && cl->typ == 'r' && cl->reader->typ == R_EMU) filtered = 1;
+#endif
 					}
 				}
 
@@ -5896,7 +5959,7 @@
 		{ "oscam.version",   MNU_CFG_FVERSION,  FTYPE_VERSION },	// id 0
 		{ "oscam.conf",      MNU_CFG_FCONF,     FTYPE_CONFIG },		// id 1
 		{ "oscam.user",      MNU_CFG_FUSER,     FTYPE_CONFIG },		// id 2
-		{ "oscam.server",    MNU_CFG_FSERVER,   FTYPE_CONFIG },		// id 3
+		{ "oscam.server",    MNU_CFG_FSERVER,   FTYPE_CONFIG },		// id 3	
 		{ "oscam.srvid",     MNU_CFG_FSRVID,    FTYPE_CONFIG },		// id 4
 		{ "oscam.srvid2",    MNU_CFG_FSRVID2,   FTYPE_CONFIG },		// id 5
 		{ "logfile",         MNU_CFG_FLOGFILE,  FTYPE_LOGFILE },	// id 6
@@ -5922,6 +5985,9 @@
 #ifdef MODULE_CONSTCW
 		{ "constant.cw",     MNU_CFG_FKEYCW,    FTYPE_CONFIG },     // id 18
 #endif
+#ifdef WITH_EMU
+		{ "SoftCam.Key",     MNU_CFG_KEY,       FTYPE_CONFIG },     // id 19
+#endif			
 		{ NULL, 0, 0 },
 	};
 
@@ -7392,8 +7458,8 @@
 		memcpy(*result + bufsize, buf2, n);
 		bufsize += n;
 
-		//max request size 100kb
-		if(bufsize > 102400)
+		//max request size 200kb
+		if(bufsize > 204800)
 		{
 			cs_log("error: too much data received from %s", cs_inet_ntoa(in));
 			NULLFREE(*result);
diff -ruN oscam-emu-2015-12-03-11142.orig/module-webif-tpl.c oscam-emu-2015-12-03-11142/module-webif-tpl.c
--- oscam-emu-2015-12-03-11142.orig/module-webif-tpl.c	2015-07-08 02:45:19.000000000 +0300
+++ oscam-emu-2015-12-03-11142/module-webif-tpl.c	2015-12-04 00:43:30.000000000 +0300
@@ -456,6 +456,7 @@
 											check_conf(WITH_SSL, ptr2);
 											check_conf(WITH_STAPI, ptr2);
 											check_conf(WITH_STAPI5, ptr2);
+											check_conf(WITH_EMU, ptr2);
 										} // for
 										if(ok == 0)
 										{
@@ -590,7 +591,7 @@
 		{
 			if(strncmp(tpl->tpl_name, "IC", 2) != 0)
 			{
-				fprintf(fp, "<!--OSCam;%lu;%s;%s;%s-->\n", crc32(0L, (unsigned char *)tpl->tpl_data, tpl->tpl_data_len), CS_VERSION, CS_SVN_VERSION, tpl->tpl_deps);
+				fprintf(fp, "<!--OSCam;%d;%s;%s;%s-->\n", crc32(0, (uint8_t *)tpl->tpl_data, tpl->tpl_data_len), CS_VERSION, CS_SVN_VERSION, tpl->tpl_deps);
 			}
 			fwrite(tpl->tpl_data, tpl->tpl_data_len, 1, fp);
 			fclose(fp);
diff -ruN oscam-emu-2015-12-03-11142.orig/oscam.c oscam-emu-2015-12-03-11142/oscam.c
--- oscam-emu-2015-12-03-11142.orig/oscam.c	2015-12-12 00:38:27.894433427 +0300
+++ oscam-emu-2015-12-03-11142/oscam.c	2015-12-04 00:43:30.000000000 +0300
@@ -41,6 +41,11 @@
 #include "reader-common.h"
 #include "module-gbox.h"
 
+#ifdef WITH_EMU
+	void add_emu_reader(void);
+	void stop_stream_server(void);
+#endif
+
 #ifdef WITH_SSL
 #include <openssl/crypto.h>
 #include <openssl/ssl.h>
@@ -408,6 +413,7 @@
 	write_conf(CW_CYCLE_CHECK, "CW Cycle Check support");
 	write_conf(LCDSUPPORT, "LCD support");
 	write_conf(LEDSUPPORT, "LED support");
+	write_conf(WITH_EMU, "Emulator support");
 	switch (cs_getclocktype()) {
 		case CLOCK_TYPE_UNKNOWN  : write_conf(CLOCKFIX, "Clockfix with UNKNOWN clock"); break;
 		case CLOCK_TYPE_REALTIME : write_conf(CLOCKFIX, "Clockfix with realtime clock"); break;
@@ -1584,6 +1590,9 @@
 #ifdef CARDREADER_STINGER
 	&cardreader_stinger,
 #endif
+#ifdef WITH_EMU
+	&cardreader_emu,
+#endif
 	NULL
 };
 
@@ -1755,6 +1764,9 @@
 
 	init_sidtab();
 	init_readerdb();
+#ifdef WITH_EMU
+	add_emu_reader();
+#endif	
 	cfg.account = init_userdb();
 	init_signal();
 	init_provid();
@@ -1838,6 +1850,9 @@
 	SAFE_COND_SIGNAL(&reader_check_sleep_cond); // Stop reader_check thread
 
 	// Cleanup
+#ifdef WITH_EMU
+	stop_stream_server();
+#endif
 #ifdef MODULE_GBOX	
 	stop_sms_sender();
 #endif
diff -ruN oscam-emu-2015-12-03-11142.orig/oscam-cache.c oscam-emu-2015-12-03-11142/oscam-cache.c
--- oscam-emu-2015-12-03-11142.orig/oscam-cache.c	2015-11-05 11:23:58.000000000 +0300
+++ oscam-emu-2015-12-03-11142/oscam-cache.c	2015-12-04 00:43:30.000000000 +0300
@@ -85,7 +85,7 @@
 uint32_t cache_size(void){
 	if(!cache_init_done)
 		{ return 0; }
-	
+		
 	return count_hash_table(&ht_cache);
 }
 
@@ -192,6 +192,7 @@
  */
 struct ecm_request_t *check_cache(ECM_REQUEST *er, struct s_client *cl)
 {
+	if(!er->csp_hash) return NULL;
 	if(!cache_init_done || !er->csp_hash) return NULL;
 
 	ECM_REQUEST *ecm = NULL;
@@ -418,8 +419,7 @@
 	struct timeb now;
 	int64_t gone_first, gone_upd;
 
-
-	if(!cache_init_done)
+	 if(!cache_init_done)
 		{ return; }
 
 	SAFE_RWLOCK_WRLOCK(&cache_lock);
diff -ruN oscam-emu-2015-12-03-11142.orig/oscam-chk.c oscam-emu-2015-12-03-11142/oscam-chk.c
--- oscam-emu-2015-12-03-11142.orig/oscam-chk.c	2015-08-19 22:50:43.000000000 +0300
+++ oscam-emu-2015-12-03-11142/oscam-chk.c	2015-12-04 00:43:30.000000000 +0300
@@ -51,32 +51,58 @@
 	int32_t i, j, an, cl_n, l;
 	uchar ecm_class;
 
-	if(er->caid != 0x0500) { return 1; }
+	if(er->caid != 0x0500 && er->caid != 0x4AE1) { return 1; }
 	if(!clstab->bn && !clstab->an) { return 1; }
-
+	
 	j = an = cl_n = l = 0;
-	while((j = find_nano(er->ecm, er->ecmlen, CS_NANO_CLASS, j)) > 0)
+	if(er->caid == 0x0500)
 	{
-		l = er->ecm[j];
-		if(l + j > er->ecmlen) { continue; }  // skip, this is not a valid class identifier!
-		ecm_class = er->ecm[j + l];
-		cs_log_dbg(D_CLIENT, "ecm class=%02X", ecm_class);
-		for(i = 0; i < clstab->bn; i++)    // search in blocked
-			if(ecm_class == clstab->bclass[i])
-			{
-				cs_log_dbg(D_CLIENT, "class %02X rejected by %s '%s' !%02X filter",
-							  ecm_class, type, name, ecm_class);
-				return 0;
-			}
+		for(i=0;i<16;i++) printf("%02X ",er->ecm[i]); printf("\n");
+		while((j = find_nano(er->ecm, er->ecmlen, CS_NANO_CLASS, j)) > 0)
+		{
+			l = er->ecm[j];
+			if(l + j > er->ecmlen) { continue; }  // skip, this is not a valid class identifier!
+			ecm_class = er->ecm[j + l];
+			cs_log_dbg(D_CLIENT, "ecm class=%02X", ecm_class);
+			for(i = 0; i < clstab->bn; i++)    // search in blocked
+				if(ecm_class == clstab->bclass[i])
+				{
+					cs_log_dbg(D_CLIENT, "class %02X rejected by %s '%s' !%02X filter",
+								  ecm_class, type, name, ecm_class);
+					return 0;
+				}
 
+			//cl_n++;
+			for(i = 0; i < clstab->an; i++)    // search in allowed
+				if(ecm_class == clstab->aclass[i])
+				{
+					an++;
+					break;
+				}
+			j += l;
+		}
+	}
+	else
+	{
+		if(er->prid != 0x11 || er->ecm[0] == 0) { return 1; }
 		cl_n++;
+		ecm_class = er->ecm[5];
+		//for(i=0;i<16;i++) printf("%02X ",er->ecm[i]); printf("\n");
+		cs_log_dbg(D_CLIENT, "ecm class=%02X", ecm_class);
+		for(i = 0; i < clstab->bn; i++)    // search in blocked
+				if(ecm_class == clstab->bclass[i])
+				{
+					cs_log_dbg(D_CLIENT, "class %02X rejected by %s '%s' !%02X filter",
+								  ecm_class, type, name, ecm_class);
+					return 0;
+				}
+				
 		for(i = 0; i < clstab->an; i++)    // search in allowed
-			if(ecm_class == clstab->aclass[i])
-			{
-				an++;
-				break;
-			}
-		j += l;
+				if(ecm_class == clstab->aclass[i])
+				{
+					an++;
+					break;
+				}
 	}
 
 	if(cl_n && clstab->an)
@@ -93,6 +119,43 @@
 	return 1;
 }
 
+static int32_t chk_sid(ECM_REQUEST *er, SID_LIST_TAB *sidtab, const char *type, const char *name)
+{
+	int i, an = 0;
+	
+	if(!sidtab->bn && !sidtab->an) { return 1; }
+	
+	uint16_t ecm_sid = er->srvid;
+	
+	for(i = 0; i < sidtab->bn; i++)    // search in blocked
+				if(ecm_sid == sidtab->bsid[i])
+				{
+					cs_log_dbg(D_CLIENT, "sid %02X rejected by %s '%s' !%02X filter",
+								  ecm_sid, type, name, ecm_sid);
+					return 0;
+				}
+				
+		for(i = 0; i < sidtab->an; i++)    // search in allowed
+				if(ecm_sid == sidtab->asid[i])
+				{
+					an++;
+					break;
+				}
+				
+	if(sidtab->an)
+	{
+		if(an)
+			{ cs_log_dbg(D_CLIENT, "ECM sid allowed by %s '%s' filter", type, name); }
+		else
+		{
+			cs_log_dbg(D_CLIENT, "ECM sid's don't match %s '%s' filter, rejecting", type, name);
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
 int32_t chk_srvid_match(ECM_REQUEST *er, SIDTAB *sidtab)
 {
 	int32_t i, rc = 0;
@@ -671,7 +734,6 @@
 
 int32_t matching_reader(ECM_REQUEST *er, struct s_reader *rdr)
 {
-
 	//simple checks first:
 	if(!er || !rdr)
 		{ return (0); }
@@ -706,7 +768,7 @@
 		return 0;
 	}
 
-	if(!is_network_reader(rdr) && ((rdr->caid >> 8) != ((er->caid >> 8) & 0xFF) && (rdr->caid >> 8) != ((er->ocaid >> 8) & 0xFF)))
+	if(!rdr->typ == R_EMU && !is_network_reader(rdr) && ((rdr->caid >> 8) != ((er->caid >> 8) & 0xFF) && (rdr->caid >> 8) != ((er->ocaid >> 8) & 0xFF)))
 	{
 		if (!rdr->csystem)
 			return 0;
@@ -742,7 +804,7 @@
 	}
 
 	//Checking ident:
-	if(!chk_rfilter(er, rdr))
+	if(!(rdr->typ == R_EMU && (er->caid>>8 == 0x26 || er->caid == 0xFFFF)) && !chk_rfilter(er, rdr))
 	{
 		cs_log_dbg(D_TRACE, "r-filter reader %s", rdr->label);
 		return (0);
@@ -754,7 +816,13 @@
 		cs_log_dbg(D_TRACE, "class filter reader %s", rdr->label);
 		return (0);
 	}
-
+	
+	//Check sid:
+	if(!chk_sid(er, &rdr->sidlisttab, "reader", rdr->label))
+	{
+		cs_log_dbg(D_TRACE, "sid filter reader %s", rdr->label);
+		return (0);
+	}
 
 	// CDS NL: check for right seca type
 	if(!is_network_reader(rdr) && er->caid == 0x100 && er->prid == 0x00006a &&
@@ -975,7 +1043,7 @@
 
 int32_t chk_caid_rdr(struct s_reader *rdr, uint16_t caid)
 {
-	if(is_network_reader(rdr))
+	if(is_network_reader(rdr) || rdr->typ == R_EMU)
 	{
 		return 1; //reader caid is not real caid
 	}
diff -ruN oscam-emu-2015-12-03-11142.orig/oscam-client.c oscam-emu-2015-12-03-11142/oscam-client.c
--- oscam-emu-2015-12-03-11142.orig/oscam-client.c	2015-11-05 21:17:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/oscam-client.c	2015-12-04 00:43:30.000000000 +0300
@@ -582,7 +582,7 @@
 		{
 			add_job(cl, ACTION_CLIENT_IDLE, NULL, 0);
 		}
-
+		
 		//Check umaxidle to avoid client is killed for inactivity, it has priority than cmaxidle
 		if(!cl->account->umaxidle)
 			break;
diff -ruN oscam-emu-2015-12-03-11142.orig/oscam-conf-chk.c oscam-emu-2015-12-03-11142/oscam-conf-chk.c
--- oscam-emu-2015-12-03-11142.orig/oscam-conf-chk.c	2015-09-02 01:14:37.000000000 +0300
+++ oscam-emu-2015-12-03-11142/oscam-conf-chk.c	2015-12-04 00:43:30.000000000 +0300
@@ -397,6 +397,54 @@
 	NULLFREE(oldclstab.bclass);
 }
 
+void chk_sid_list_tab(char *sdlasc, SID_LIST_TAB *sdltab)
+{
+	int32_t max_an = 0, max_bn = 0;
+	char *ptr1, *saveptr1 = NULL, *sdlasc_org;
+	SID_LIST_TAB newsdltab, oldsdltab;
+	memset(&newsdltab, 0, sizeof(newsdltab));
+	newsdltab.an = newsdltab.bn = 0;
+	
+	if(!cs_malloc(&sdlasc_org, sizeof(char)*strlen(sdlasc)+1))
+		{ return; }
+	
+	cs_strncpy(sdlasc_org, sdlasc, sizeof(char)*strlen(sdlasc)+1);
+	
+	for(ptr1 = strtok_r(sdlasc, ",", &saveptr1); ptr1; ptr1 = strtok_r(NULL, ",", &saveptr1))
+	{
+		ptr1 = trim(ptr1);
+		if(ptr1[0] == '!')
+			{ max_bn++; }
+		else
+			{ max_an++; }
+	}
+
+	if(max_an && !cs_malloc(&newsdltab.asid, sizeof(uint16_t)*max_an))
+		{ NULLFREE(sdlasc_org); return; }	
+
+	if(max_bn && !cs_malloc(&newsdltab.bsid, sizeof(uint16_t)*max_bn))
+		{ NULLFREE(newsdltab.asid); NULLFREE(sdlasc_org); return; }	
+	
+	sdlasc = sdlasc_org;
+
+	for(ptr1 = strtok_r(sdlasc, ",", &saveptr1); ptr1; ptr1 = strtok_r(NULL, ",", &saveptr1))
+	{
+		ptr1 = trim(ptr1);
+		if(ptr1[0] == '!')
+			{ newsdltab.bsid[newsdltab.bn++] = (uint16_t)a2i(ptr1 + 1, 4); }
+		else
+			{ newsdltab.asid[newsdltab.an++] = (uint16_t)a2i(ptr1, 4); }
+	}
+	
+	NULLFREE(sdlasc_org);
+	
+	memcpy(&oldsdltab, sdltab, sizeof(SID_LIST_TAB));
+	memcpy(sdltab, &newsdltab, sizeof(SID_LIST_TAB));
+	
+	NULLFREE(oldsdltab.asid);
+	NULLFREE(oldsdltab.bsid);
+}
+
 void chk_port_tab(char *portasc, PTAB *ptab)
 {
 	int32_t i, j, nfilts, ifilt, iport;
diff -ruN oscam-emu-2015-12-03-11142.orig/oscam-conf-chk.h oscam-emu-2015-12-03-11142/oscam-conf-chk.h
--- oscam-emu-2015-12-03-11142.orig/oscam-conf-chk.h	2015-02-18 01:30:32.000000000 +0300
+++ oscam-emu-2015-12-03-11142/oscam-conf-chk.h	2015-12-04 00:43:30.000000000 +0300
@@ -11,6 +11,7 @@
 void chk_services(char *labels, SIDTABS *sidtabs);
 void chk_ftab(char *value, FTAB *ftab);
 void chk_cltab(char *classasc, CLASSTAB *clstab);
+void chk_sid_list_tab(char *sdlasc, SID_LIST_TAB *sdltab);
 void chk_port_tab(char *portasc, PTAB *ptab);
 void chk_ecm_whitelist(char *value, ECM_WHITELIST *ecm_whitelist);
 void chk_ecm_hdr_whitelist(char *value, ECM_HDR_WHITELIST *ecm_hdr_whitelist);
diff -ruN oscam-emu-2015-12-03-11142.orig/oscam-config-account.c oscam-emu-2015-12-03-11142/oscam-config-account.c
--- oscam-emu-2015-12-03-11142.orig/oscam-config-account.c	2015-09-01 14:12:52.000000000 +0300
+++ oscam-emu-2015-12-03-11142/oscam-config-account.c	2015-12-04 00:43:30.000000000 +0300
@@ -313,6 +313,23 @@
 	}
 }
 
+void sidlisttab_fn(const char *token, char *value, void *setting, FILE *f)
+{
+	SID_LIST_TAB *sidlisttab = setting;
+	if(value)
+	{
+		strtolower(value);
+		chk_sid_list_tab(value, sidlisttab);
+		return;
+	}
+	value = mk_t_sdltab(sidlisttab);
+	if(strlen(value) > 0 || cfg.http_full_cfg)
+	{
+		fprintf_conf(f, token, "%s\n", value);
+		free_mk_t(value);
+	}
+}
+
 #ifdef CS_ANTICASC
 static void account_fixups_fn(void *var)
 {
diff -ruN oscam-emu-2015-12-03-11142.orig/oscam-config-global.c oscam-emu-2015-12-03-11142/oscam-config-global.c
--- oscam-emu-2015-12-03-11142.orig/oscam-config-global.c	2015-11-12 07:19:54.000000000 +0300
+++ oscam-emu-2015-12-03-11142/oscam-config-global.c	2015-12-04 00:43:30.000000000 +0300
@@ -803,6 +803,27 @@
 #else
 static const struct config_list scam_opts[] = { DEF_LAST_OPT };
 #endif
+
+#ifdef WITH_EMU
+static bool streamrelay_should_save_fn(void *UNUSED(var))
+{
+	return cfg.emu_stream_source_port != 8001 || 
+			cfg.emu_stream_relay_port != 17999 ||
+			cfg.emu_stream_ecm_delay != 700;
+}
+static const struct config_list streamrelay_opts[] =
+{
+	DEF_OPT_SAVE_FUNC(streamrelay_should_save_fn),
+	DEF_OPT_INT32("stream_source_port"    , OFS(emu_stream_source_port),    8001),
+	DEF_OPT_INT32("stream_relay_port"    , OFS(emu_stream_relay_port),    17999),
+	DEF_OPT_UINT32("stream_ecm_delay"    , OFS(emu_stream_ecm_delay),    700),
+	DEF_LAST_OPT
+};
+#else
+static const struct config_list streamrelay_opts[] = { DEF_LAST_OPT };
+#endif
+
+
 #ifdef MODULE_RADEGAST
 static bool radegast_should_save_fn(void *UNUSED(var))
 {
@@ -1008,7 +1029,7 @@
 	DEF_OPT_STR("user"		, OFS(dvbapi_usr),		NULL),
 	DEF_OPT_INT8("read_sdt"		, OFS(dvbapi_read_sdt),	0),
 	DEF_OPT_INT8("write_sdt_prov", OFS(dvbapi_write_sdt_prov),	0),
-	DEF_OPT_INT8("extended_cw_api", OFS(dvbapi_extended_cw_api),	0),
+	DEF_OPT_INT8("extended_cw_api", OFS(dvbapi_extended_cw_api),    0),
 	DEF_OPT_FUNC("boxtype"		, OFS(dvbapi_boxtype),		dvbapi_boxtype_fn),
 	DEF_OPT_FUNC("services"		, OFS(dvbapi_sidtabs.ok),	dvbapi_services_fn),
 	// OBSOLETE OPTIONS
@@ -1062,6 +1083,7 @@
 	{ "cccam",	cccam_opts },
 	{ "pandora",	pandora_opts },
 	{ "scam",	scam_opts },
+	{ "streamrelay",	streamrelay_opts },
 	{ "dvbapi",	dvbapi_opts },
 	{ "monitor",	monitor_opts },
 	{ "webif",	webif_opts },
diff -ruN oscam-emu-2015-12-03-11142.orig/oscam-config.h oscam-emu-2015-12-03-11142/oscam-config.h
--- oscam-emu-2015-12-03-11142.orig/oscam-config.h	2015-08-31 23:05:08.000000000 +0300
+++ oscam-emu-2015-12-03-11142/oscam-config.h	2015-12-04 00:43:30.000000000 +0300
@@ -22,6 +22,7 @@
 int32_t free_readerdb(void);
 int32_t write_server(void);
 void    reload_readerdb(void);
+void reader_fixups_fn(void *var);
 
 void    chk_sidtab(char *token, char *value, struct s_sidtab *sidtab);
 int32_t init_sidtab(void);
@@ -50,6 +51,7 @@
 void cacheex_valuetab_fn(const char *token, char *value, void *setting, FILE *f);
 void cacheex_hitvaluetab_fn(const char *token, char *value, void *setting, FILE *f);
 void class_fn(const char *token, char *value, void *setting, FILE *f);
+void sidlisttab_fn(const char *token, char *value, void *setting, FILE *f);
 void group_fn(const char *token, char *value, void *setting, FILE *f);
 void services_fn(const char *token, char *value, void *setting, FILE *f);
 
@@ -60,7 +62,8 @@
 	FTAB_PROVID  = 0x04,
 	FTAB_CHID    = 0x08,
 	FTAB_FBPCAID = 0x10,
-	FTAB_LOCALCARDS = 0x20
+	FTAB_LOCALCARDS = 0x20,
+	FTAB_EMUAU  = 0x40	
 };
 
 void ftab_fn(const char *token, char *value, void *setting, long ftab_type, FILE *f);
diff -ruN oscam-emu-2015-12-03-11142.orig/oscam-config-reader.c oscam-emu-2015-12-03-11142/oscam-config-reader.c
--- oscam-emu-2015-12-03-11142.orig/oscam-config-reader.c	2015-09-01 14:12:52.000000000 +0300
+++ oscam-emu-2015-12-03-11142/oscam-config-reader.c	2015-12-04 00:43:30.000000000 +0300
@@ -107,6 +107,7 @@
 			{ "newcamd",    R_NEWCAMD },
 			{ "newcamd525", R_NEWCAMD },
 			{ "newcamd524", R_NEWCAMD },
+			{ "emu",        R_EMU },
 			{ NULL        , 0 }
 		}, *p;
 		int i;
@@ -445,6 +446,7 @@
 		if(ftab_type & FTAB_CHID)       { rdr = container_of(setting, struct s_reader, fchid); }
 		if(ftab_type & FTAB_FBPCAID)    { rdr = container_of(setting, struct s_reader, fallback_percaid); }
 		if(ftab_type & FTAB_LOCALCARDS) { rdr = container_of(setting, struct s_reader, localcards); }
+		if(ftab_type & FTAB_EMUAU)      { rdr = container_of(setting, struct s_reader, emu_auproviders); }		
 		if(rdr)
 			{ rdr->changes_since_shareupdate = 1; }
 	}
@@ -752,7 +754,7 @@
 }
 
 
-static void reader_fixups_fn(void *var)
+void reader_fixups_fn(void *var)
 {
 	struct s_reader *rdr = var;
 #ifdef WITH_LB
@@ -850,6 +852,7 @@
 	DEF_OPT_FUNC_X("ident"              , OFS(ftab),                    ftab_fn, FTAB_READER | FTAB_PROVID),
 	DEF_OPT_FUNC_X("chid"               , OFS(fchid),                   ftab_fn, FTAB_READER | FTAB_CHID),
 	DEF_OPT_FUNC("class"                , OFS(cltab),                   class_fn),
+	DEF_OPT_FUNC("sid"                  , OFS(sidlisttab),              sidlisttab_fn), // megavolt
 	DEF_OPT_FUNC("aeskeys"              , 0,                            aeskeys_fn),
 	DEF_OPT_FUNC("group"                , OFS(grp),                     group_fn),
 	DEF_OPT_FUNC("emmcache"             , 0,                            emmcache_fn),
@@ -887,6 +890,11 @@
 #ifdef MODULE_GHTTP
 	DEF_OPT_UINT8("use_ssl"             , OFS(ghttp_use_ssl),           0),
 #endif
+#ifdef WITH_EMU
+	DEF_OPT_FUNC_X("emu_auproviders"    , OFS(emu_auproviders),         ftab_fn, FTAB_READER | FTAB_EMUAU),
+	DEF_OPT_STR("extee36"           , OFS(extee36),             NULL),
+	DEF_OPT_STR("extee56"           , OFS(extee56),             NULL),
+#endif
 	DEF_OPT_INT8("deprecated"           , OFS(deprecated),              0),
 	DEF_OPT_INT8("audisabled"           , OFS(audisabled),              0),
 	DEF_OPT_FUNC("auprovid"             , 0,                            auprovid_fn),
diff -ruN oscam-emu-2015-12-03-11142.orig/oscam-conf-mk.c oscam-emu-2015-12-03-11142/oscam-conf-mk.c
--- oscam-emu-2015-12-03-11142.orig/oscam-conf-mk.c	2015-09-01 21:20:50.000000000 +0300
+++ oscam-emu-2015-12-03-11142/oscam-conf-mk.c	2015-12-04 00:43:30.000000000 +0300
@@ -602,6 +602,35 @@
 /*
  * Creates a string ready to write as a token into config or WebIf. You must free the returned value through free_mk_t().
  */
+
+char *mk_t_sdltab(SID_LIST_TAB *sdltab)
+{
+	char *value, *dot = "";
+	int32_t i, needed = 1, pos = 0;
+	for(i = 0; i < sdltab->an; ++i) { needed += 3; }
+	for(i = 0; i < sdltab->bn; ++i) { needed += 4; }
+
+	char tmp[needed];
+
+	for(i = 0; i < sdltab->an; ++i)
+	{
+		pos += snprintf(tmp + pos, needed - pos, "%s%02x", dot, (int32_t)sdltab->asid[i]);
+		dot = ",";
+	}
+	for(i = 0; i < sdltab->bn; ++i)
+	{
+		pos += snprintf(tmp + pos, needed - pos, "%s!%02x", dot, (int32_t)sdltab->bsid[i]);
+		dot = ",";
+	}
+
+	if(pos == 0 || !cs_malloc(&value, pos + 1)) { return ""; }
+	memcpy(value, tmp, pos + 1);
+	return value;
+}
+
+/*
+ * Creates a string ready to write as a token into config or WebIf. You must free the returned value through free_mk_t().
+ */
 char *mk_t_caidvaluetab(CAIDVALUETAB *caidvaluetab)
 {
 	if (!caidvaluetab || !caidvaluetab->cvnum) return "";
diff -ruN oscam-emu-2015-12-03-11142.orig/oscam-conf-mk.h oscam-emu-2015-12-03-11142/oscam-conf-mk.h
--- oscam-emu-2015-12-03-11142.orig/oscam-conf-mk.h	2015-02-11 14:39:25.000000000 +0300
+++ oscam-emu-2015-12-03-11142/oscam-conf-mk.h	2015-12-04 00:43:30.000000000 +0300
@@ -22,6 +22,7 @@
 extern char *mk_t_ecm_whitelist(struct s_ecm_whitelist *ecm_whitelist);
 extern char *mk_t_ecm_hdr_whitelist(struct s_ecm_hdr_whitelist *ecm_hdr_whitelist);
 extern char *mk_t_cltab(CLASSTAB *clstab);
+extern char *mk_t_sdltab(SID_LIST_TAB *sdltab);
 extern char *mk_t_emmbylen(struct s_reader *rdr);
 extern char *mk_t_allowedprotocols(struct s_auth *account);
 extern void free_mk_t(char *value);
diff -ruN oscam-emu-2015-12-03-11142.orig/oscam-ecm.c oscam-emu-2015-12-03-11142/oscam-ecm.c
--- oscam-emu-2015-12-03-11142.orig/oscam-ecm.c	2015-11-01 19:25:12.000000000 +0300
+++ oscam-emu-2015-12-03-11142/oscam-ecm.c	2015-12-04 00:43:30.000000000 +0300
@@ -24,6 +24,10 @@
 #include "oscam-work.h"
 #include "reader-common.h"
 
+#ifdef HAVE_DVBAPI
+#include "module-dvbapi.h"
+#endif
+
 extern CS_MUTEX_LOCK ecmcache_lock;
 extern struct ecm_request_t *ecmcwcache;
 extern uint16_t len4caid[256];
@@ -674,7 +678,7 @@
 								};
 	static const char *stxtEx[16] = {"", "group", "caid", "ident", "class", "chid", "queue", "peer", "sid", "", "", "", "", "", "", ""};
 	static const char *stxtWh[16] = {"", "user ", "reader ", "server ", "lserver ", "", "", "", "", "", "", "", "" , "" , "", ""};
-	char sby[100] = "", sreason[32] = "", scwcinfo[32] = "", schaninfo[32] = "", srealecmtime[50]="";
+	char sby[100] = "", sreason[32] = "", scwcinfo[32] = "", schaninfo[CS_SERVICENAME_SIZE] = "", srealecmtime[50]="";
 	char erEx[32] = "";
 	char usrname[38] = "";
 	char channame[CS_SERVICENAME_SIZE];
@@ -1653,7 +1657,7 @@
 	{
 		ea->cw_ex = *cw_ex;
 	}
-	
+ 	
 	cs_writeunlock(__func__, &ea->ecmanswer_lock);
 
 	struct timeb tpe;
@@ -1802,8 +1806,9 @@
 		id = b2i(2, er->ecm + 11);
 		break; // videoguard
 	case 0x4A: // DRE-Crypt, Bulcrypt, Tongfang and others?
-		if(!caid_is_bulcrypt(er->caid))
+		if(!caid_is_bulcrypt(er->caid) || !caid_is_dre(er->caid))
 			{ id = b2i(2, er->ecm + 6); }
+		//if(caid_is_dre(er->caid)) id = b2i(2, er->ecm + 7);
 		break;
 	}
 	return id;
@@ -2393,6 +2398,9 @@
 		cs_log_dbg(D_LB, "{client %s, caid %04X, prid %06X, srvid %04X} [get_cw] NO Readers and NO wait_time... not_found! ", (check_client(er->client) ? er->client->account->usr : "-"), er->caid, er->prid, er->srvid);
 		send_dcw(client, er);
 		free_ecm(er);
+#ifdef HAVE_DVBAPI
+		dvbapi_stop_all_descrambling();
+#endif
 		return;
 	}
 
diff -ruN oscam-emu-2015-12-03-11142.orig/oscam-emm.c oscam-emu-2015-12-03-11142/oscam-emm.c
--- oscam-emu-2015-12-03-11142.orig/oscam-emm.c	2015-10-31 19:53:42.000000000 +0300
+++ oscam-emu-2015-12-03-11142/oscam-emm.c	2015-12-04 00:43:30.000000000 +0300
@@ -50,7 +50,14 @@
 	unsigned int j, filter_count = 0;
 
 	// Call cardsystems emm filter
-	csystem->get_emm_filter(rdr, &dmx_filter, &filter_count);
+	if(rdr->typ == R_EMU)
+	{
+		csystem->get_emm_filter_adv(rdr, &dmx_filter, &filter_count, b2i(2, ep->caid), b2i(4, ep->provid));
+	}
+	else
+	{
+		csystem->get_emm_filter(rdr, &dmx_filter, &filter_count);
+	}
 
 	// Only check matching emmtypes:
 	uint8_t org_emmtype;
@@ -117,7 +124,7 @@
 		if(!tps)
 			{ tps = &tpe; }
 
-		rdr_log(reader, "%s emmtype=%s, len=%d (hex: 0x%02X), cnt=%d: %s (%"PRId64" ms)",
+		rdr_log(reader, "%s emmtype=%s, len=%d (hex: 0x%03X), cnt=%d: %s (%"PRId64" ms)",
 				username(ep->client), typedesc[ep->type], SCT_LEN(ep->emm)-3, SCT_LEN(ep->emm)-3, count, rtxt[rc], comp_timeb(&tpe, tps));
 	}
 
@@ -205,6 +212,24 @@
 		rdr_log_dbg(reader, D_EMM, "reader auprovid = %06X fixup to %06X (ignoring last digit)", reader->auprovid, prid); 
 	}
 	
+#ifdef WITH_EMU
+	if(reader->typ == R_EMU)
+	{
+		FILTER* emu_provids = get_emu_prids_for_caid(reader, caid);
+		if(emu_provids != NULL)
+		{
+			for(i = 0; i < emu_provids->nprids; i++)
+			{
+				if(provid == emu_provids->prids[i])
+				{
+					return 1;
+				}
+			}		
+		}		
+		return 0;
+	}
+#endif
+	
 	if(prid == provid)
 	{
 		rdr_log_dbg(reader, D_EMM, "reader auprovid = %06X matching with emm provid = %06X -> SEND!", prid, provid);
@@ -326,19 +351,13 @@
 		return;
 	}
 
-	if(ep->emmlen > MAX_EMM_SIZE)
-	{
-		cs_log("EMM size %d > Max EMM size %d, ignored! client %s", ep->emmlen, MAX_EMM_SIZE, username(client));
-		return;
-	}
-		
 	sct_len = SCT_LEN(ep->emm);
-	if(sct_len > ep->emmlen)
-	{
+ 	if(sct_len > ep->emmlen)
+ 	{
 		cs_log("Real EMM size %d > EMM size %d, ignored! client %s", sct_len, ep->emmlen, username(client));
-		return;	
+		return;
 	}
-	ep->emmlen = sct_len;
+ 	ep->emmlen = sct_len;
 	
 	cs_log_dump_dbg(D_EMM, ep->emm, ep->emmlen, "emm:");
 
@@ -497,7 +516,7 @@
 		}
 		
 		// if not already blocked we check for block by len
-		if(!is_blocked) { is_blocked = cs_emmlen_is_blocked(aureader, SCT_LEN(ep->emm)-3) ; }
+		if(!is_blocked) { is_blocked = cs_emmlen_is_blocked(aureader, SCT_LEN(ep->emm)-3); }
 
 		if(is_blocked != 0)
 		{
diff -ruN oscam-emu-2015-12-03-11142.orig/oscam-log.c oscam-emu-2015-12-03-11142/oscam-log.c
--- oscam-emu-2015-12-03-11142.orig/oscam-log.c	2015-11-12 07:19:54.000000000 +0300
+++ oscam-emu-2015-12-03-11142/oscam-log.c	2015-12-04 00:43:30.000000000 +0300
@@ -29,7 +29,7 @@
 static pthread_mutex_t log_thread_sleep_cond_mutex;
 static int32_t syslog_socket = -1;
 static struct sockaddr_in syslog_addr;
-
+extern uint8_t cs_http_use_utf8;
 
 struct s_log
 {
@@ -367,6 +367,7 @@
 			}			
 			
 			snprintf(tmp, sizeof(tmp), "%s %s oscam[%u]: %s", timebuf, hostname, getpid(), txt + log->header_info_offset);
+			if(0 /* cs_http_use_utf8 */) utf8c1251(tmp);
 			sendto(syslog_socket, tmp, strlen(tmp), 0, (struct sockaddr*) &syslog_addr, sizeof(syslog_addr));
 		}
 	}
diff -ruN oscam-emu-2015-12-03-11142.orig/oscam-reader.c oscam-emu-2015-12-03-11142/oscam-reader.c
--- oscam-emu-2015-12-03-11142.orig/oscam-reader.c	2015-11-05 21:17:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/oscam-reader.c	2015-12-04 00:43:30.000000000 +0300
@@ -1136,7 +1136,7 @@
 		if(time_diff > reader->tcp_ito)
 		{
 			struct s_client *cl = reader->client;
-			if(check_client(cl) && reader->tcp_connected && reader->ph.type == MOD_CONN_TCP)
+			if(check_client(cl) && reader->tcp_connected && reader->ph.type == MOD_CONN_TCP) //&& !reader->keepalive) // JMF FIX : reader keepalive to no close
 			{
 				rdr_log_dbg(reader, D_READER, "inactive_timeout, close connection (fd=%d)", cl->pfd);
 				network_tcp_connection_close(reader, "inactivity");
diff -ruN oscam-emu-2015-12-03-11142.orig/oscam-string.c oscam-emu-2015-12-03-11142/oscam-string.c
--- oscam-emu-2015-12-03-11142.orig/oscam-string.c	2015-07-30 03:14:56.000000000 +0300
+++ oscam-emu-2015-12-03-11142/oscam-string.c	2015-12-04 00:43:30.000000000 +0300
@@ -407,7 +407,7 @@
 	}
 }
 
-static unsigned long crc_table[256] =
+static uint32_t crc_table[256] =
 {
 	0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
 	0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
@@ -473,7 +473,7 @@
 #define DO4(buf) DO2(buf); DO2(buf);
 #define DO8(buf) DO4(buf); DO4(buf);
 
-unsigned long crc32(unsigned long crc, const unsigned char *buf, unsigned int len)
+uint32_t crc32(uint32_t crc, const uint8_t *buf, uint32_t len)
 {
 	if(!buf)
 		{ return 0L; }
@@ -494,6 +494,62 @@
 	return crc ^ 0xffffffffL;
 }
 
+static uint32_t fletcher_crc_table[256] = {
+	0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
+	0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
+	0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd, 0x4c11db70, 0x48d0c6c7,
+	0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
+	0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3,
+	0x709f7b7a, 0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
+	0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58, 0xbaea46ef,
+	0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
+	0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb,
+	0xceb42022, 0xca753d95, 0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
+	0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
+	0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
+	0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4,
+	0x0808d07d, 0x0cc9cdca, 0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
+	0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08,
+	0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
+	0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc,
+	0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
+	0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a, 0xe0b41de7, 0xe4750050,
+	0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
+	0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
+	0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
+	0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb, 0x4f040d56, 0x4bc510e1,
+	0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
+	0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5,
+	0x3f9b762c, 0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
+	0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e, 0xf5ee4bb9,
+	0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
+	0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd,
+	0xcda1f604, 0xc960ebb3, 0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
+	0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
+	0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
+	0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2,
+	0x470cdd2b, 0x43cdc09c, 0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
+	0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e,
+	0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
+	0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a,
+	0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
+	0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c, 0xe3a1cbc1, 0xe760d676,
+	0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
+	0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
+	0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
+	0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4};
+
+uint32_t fletcher_crc32(uint8_t *data, uint32_t len)
+{
+	uint32_t i;
+	uint32_t crc = 0xffffffff;
+
+	for (i=0; i<len; i++)
+		crc = (crc << 8) ^ fletcher_crc_table[((crc >> 24) ^ *data++) & 0xff];
+
+	return crc;
+}
+
 static uint16_t ccitt_crc_table [256] =
 {
 	0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5,
@@ -705,6 +761,42 @@
 	return j;
 }
 
+void utf8c1251(char *source)
+{
+	uint32_t j,x;
+	for (j=0 ,x=0; j < strlen(source); j++ ,x++)
+	{
+		if((uint8_t) source[j] <= 127)
+		{
+			source[x] = source[j];
+			continue;
+		}
+		
+		switch((uint8_t) source[j])
+		{
+			case 0xD0:
+				
+				if((uint8_t) source[j+1] == 0x81) source[x] = source[j+1] + 0x27;
+				else source[x] = source[j+1] + 0x30;
+				j++;
+				continue;
+				break;
+				
+			case 0xD1:
+				
+				if((uint8_t) source[j+1] == 0x91) source[x] = source[j+1] + 0x27;
+				else source[x] = source[j+1] + 0x70;
+				j++;
+				continue;
+				break;
+			
+			default:
+				return;
+		}
+	}
+
+	source[x] = '\0';
+}
 
 #ifdef READ_SDT_CHARSETS
 
diff -ruN oscam-emu-2015-12-03-11142.orig/oscam-string.h oscam-emu-2015-12-03-11142/oscam-string.h
--- oscam-emu-2015-12-03-11142.orig/oscam-string.h	2015-07-30 03:14:56.000000000 +0300
+++ oscam-emu-2015-12-03-11142/oscam-string.h	2015-12-04 00:43:30.000000000 +0300
@@ -35,7 +35,8 @@
 void get_random_bytes_init(void);
 void get_random_bytes(uint8_t *dst, uint32_t dst_len);
 
-unsigned long crc32(unsigned long crc, const unsigned char *buf, unsigned int len);
+uint32_t fletcher_crc32(uint8_t *data, uint32_t len);
+uint32_t crc32(uint32_t crc, const uint8_t *buf, uint32_t len);
 uint16_t ccitt_crc(uint8_t *data, size_t length, uint16_t seed, uint16_t final);
 uint32_t jhash(const char *key, size_t len);
 
@@ -49,6 +50,8 @@
 void b64prepare(void);
 int32_t b64decode(unsigned char *result);
 
+void utf8c1251(char *source);
+
 #ifdef READ_SDT_CHARSETS
 size_t ISO6937toUTF8( const unsigned char **inbuf, size_t *inbytesleft,
                              unsigned char **outbuf, size_t *outbytesleft );
diff -ruN oscam-emu-2015-12-03-11142.orig/reader-common.c oscam-emu-2015-12-03-11142/reader-common.c
--- oscam-emu-2015-12-03-11142.orig/reader-common.c	2015-11-01 19:25:12.000000000 +0300
+++ oscam-emu-2015-12-03-11142/reader-common.c	2015-12-04 00:43:30.000000000 +0300
@@ -14,6 +14,7 @@
 #include "reader-common.h"
 //#include "csctapi/atr.h"
 #include "csctapi/icc_async.h"
+#include "readers.h"
 
 extern const struct s_cardsystem *cardsystems[];
 extern char *RDR_CD_TXT[];
@@ -141,6 +142,19 @@
 static int32_t reader_get_cardsystem(struct s_reader *reader, ATR *atr)
 {
 	int32_t i;
+	
+#ifdef WITH_EMU
+	if(reader->typ == R_EMU)
+	{
+		NULLFREE(reader->csystem_data);
+		rdr_log(reader, "found card system %s", reader_emu.desc);
+		reader->csystem = &reader_emu;
+		reader->csystem_active = true;
+		led_status_found_cardsystem();
+		return (reader->csystem_active);
+	}
+#endif
+	
 	for(i = 0; cardsystems[i]; i++)
 	{
 		NULLFREE(reader->csystem_data);
diff -ruN oscam-emu-2015-12-03-11142.orig/reader-dre.c oscam-emu-2015-12-03-11142/reader-dre.c
--- oscam-emu-2015-12-03-11142.orig/reader-dre.c	2015-07-06 02:00:47.000000000 +0300
+++ oscam-emu-2015-12-03-11142/reader-dre.c	2015-12-04 00:43:30.000000000 +0300
@@ -2,6 +2,7 @@
 #ifdef READER_DRE
 #include "cscrypt/des.h"
 #include "reader-common.h"
+#include "module-emulator-dre2overcrypt.h"
 
 struct dre_data
 {
@@ -20,6 +21,23 @@
 	return checksum;
 }
 
+static int8_t isValidDCW(uint8_t *dw)
+{
+	if (((dw[0]+dw[1]+dw[2]) & 0xFF) != dw[3]) {
+		return 0;
+	}
+	if (((dw[4]+dw[5]+dw[6]) & 0xFF) != dw[7]) {
+		return 0;
+	}
+	if (((dw[8]+dw[9]+dw[10]) & 0xFF) != dw[11]) {
+		return 0;
+	}
+	if (((dw[12]+dw[13]+dw[14]) & 0xFF) != dw[15]) {
+		return 0;
+	}
+	return 1;
+}
+
 static int32_t dre_command(struct s_reader *reader, const uchar *cmd, int32_t cmdlen, unsigned char *cta_res, uint16_t *p_cta_lr)       //attention: inputcommand will be changed!!!! answer will be in cta_res, length cta_lr ; returning 1 = no error, return ERROR = err
 {
 	uchar startcmd[] = { 0x80, 0xFF, 0x10, 0x01, 0x05 };  //any command starts with this,
@@ -146,7 +164,7 @@
 					int32_t endday = temp.tm_mday;
 					rdr_log(reader, "active package %i valid from %04i/%02i/%02i to %04i/%02i/%02i", i, startyear, startmonth, startday,
 							endyear, endmonth, endday);
-					cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), 0, 0, start, end, 1, 1);
+					cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), 0, i, start, end, 5, 1);
 				}
 	}
 	return OK;
@@ -203,6 +221,7 @@
 	}
 
 	memset(reader->prid, 0x00, 8);
+	reader->prid[0][3] = atr[6];
 
 	static const uchar cmd30[] =
 	{
@@ -269,9 +288,19 @@
 					  reader->sa[0][3], cs_hexdump(0, reader->hexserial + 2, 4, tmp, sizeof(tmp)));
 
 	reader->nprov = 1;
-
+	
+	if(csystem_data->provider == 0x11)
+	{
+		memset(reader->prid[1], 0x00, 8);
+		//reader->sa[1][0]=0xED;
+		//reader->sa[1][3]=0x2;
+		reader->prid[1][3] = 0xFE;
+		reader->nprov = 2;
+	}
+	
 	if(!dre_set_provider_info(reader))
 		{ return ERROR; }           //fatal error
+		
 
 	rdr_log(reader, "ready for requests");
 	return OK;
@@ -312,6 +341,8 @@
 static int32_t dre_do_ecm(struct s_reader *reader, const ECM_REQUEST *er, struct s_ecm_answer *ea)
 {
 	def_resp;
+	uint16_t overcryptId;
+	uint8_t tmp[16];
 	char tmp_dbg[256];
 	struct dre_data *csystem_data = reader->csystem_data;
 	if(reader->caid == 0x4ae0)
@@ -338,7 +369,7 @@
 			return OK;
 		}
 	}
-	else
+	else if(reader->caid == 0x4ae1 && csystem_data->provider != 0x2)
 	{
 
 		uchar ecmcmd51[] = { 0x51, 0x02, 0x56, 0x05, 0x00, 0x4A, 0xE3,  //fixed header?
@@ -352,14 +383,35 @@
 		rdr_log_dbg(reader, D_READER, "unused ECM info front:%s", cs_hexdump(0, er->ecm, 5, tmp_dbg, sizeof(tmp_dbg)));
 		rdr_log_dbg(reader, D_READER, "unused ECM info back:%s", cs_hexdump(0, er->ecm + 37, 4, tmp_dbg, sizeof(tmp_dbg)));
 		ecmcmd51[33] = csystem_data->provider;  //no part of sig
+		
 		if((dre_cmd(ecmcmd51)))     //ecm request
 		{
 			if((cta_res[cta_lr - 2] != 0x90) || (cta_res[cta_lr - 1] != 0x00))
 				{ return ERROR; }       //exit if response is not 90 00
+					
+			if(er->ecm[2] >= 46 && er->ecm[43] == 1 && csystem_data->provider == 0x11)
+			{   
+				memcpy(tmp, cta_res + 11, 8);
+				memcpy(tmp + 8, cta_res + 3, 8);
+				overcryptId = b2i(2, &er->ecm[44]);
+				rdr_log_dbg(reader, D_READER, "ICG ID: %04X", overcryptId);
+				Drecrypt2OverCW(overcryptId,tmp);
+				if(isValidDCW(tmp))
+				{
+					memcpy(ea->cw, tmp, 16);
+					return OK;
+				}
+				return ERROR;
+			}
+			
 			DREover(er->ecm, cta_res + 3);
-			memcpy(ea->cw, cta_res + 11, 8);
-			memcpy(ea->cw + 8, cta_res + 3, 8);
-			return OK;
+			
+			if(isValidDCW(cta_res + 3))
+			{
+				memcpy(ea->cw, cta_res + 11, 8);
+				memcpy(ea->cw + 8, cta_res + 3, 8);
+				return OK;
+			}
 		}
 	}
 	return ERROR;
@@ -367,37 +419,44 @@
 
 static int32_t dre_get_emm_type(EMM_PACKET *ep, struct s_reader *rdr)
 {
+	struct dre_data *csystem_data = rdr->csystem_data;
+	
 	switch(ep->emm[0])
 	{
-	case 0x87:
-		ep->type = UNIQUE;
-		return 1; //FIXME: no filling of ep->hexserial
-
-	case 0x83:
-	case 0x89:
-		ep->type = SHARED;
-		// FIXME: Seems to be that SA is only used with caid 0x4ae1
-		if(rdr->caid == 0x4ae1)
-		{
-			memset(ep->hexserial, 0, 8);
-			memcpy(ep->hexserial, ep->emm + 3, 4);
-			return (!memcmp(&rdr->sa[0][0], ep->emm + 3, 4));
-		}
-		else
-			{ return 1; }
+		case 0x87:
+			ep->type = UNIQUE;
+			return 1; //FIXME: no filling of ep->hexserial
+
+		case 0x83:
+		case 0x89:
+			ep->type = SHARED;
+			// FIXME: Seems to be that SA is only used with caid 0x4ae1
+			if(rdr->caid == 0x4ae1)
+			{
+				memset(ep->hexserial, 0, 8);
+				memcpy(ep->hexserial, ep->emm + 3, 4);
+				return (!memcmp(&rdr->sa[0][0], ep->emm + 3, 4));
+			}
+			else
+				{ return 1; }
 
-	case 0x80:
-	case 0x82:
-	case 0x86:
-	case 0x8c:
-		ep->type = SHARED;
-		memset(ep->hexserial, 0, 8);
-		ep->hexserial[0] = ep->emm[3];
-		return ep->hexserial[0] == rdr->sa[0][0];
+		case 0x80:
+		case 0x82:
+		case 0x86:
+		case 0x8c:
+			ep->type = SHARED;
+			memset(ep->hexserial, 0, 8);
+			ep->hexserial[0] = ep->emm[3];
+			return ep->hexserial[0] == rdr->sa[0][0];
+		
+		case 0x91:
+			if(csystem_data->provider != 0x11) ep->type = UNKNOWN;
+			else ep->type = GLOBAL;
+			return 1;
 
-	default:
-		ep->type = UNKNOWN;
-		return 1;
+		default:
+			ep->type = UNKNOWN;
+			return 1;
 	}
 }
 
@@ -405,7 +464,7 @@
 {
 	if(*emm_filters == NULL)
 	{
-		const unsigned int max_filter_count = 7;
+		const unsigned int max_filter_count = 8;
 		if(!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
 			{ return ERROR; }
 
@@ -477,6 +536,12 @@
 		filters[idx].mask[0]   = 0xFF;
 		//FIXME: No filter for hexserial
 		idx++;
+		
+		filters[idx].type = EMM_GLOBAL;
+		filters[idx].enabled   = 1;
+		filters[idx].filter[0] = 0x91;
+		filters[idx].mask[0]   = 0xFF;
+		idx++;
 
 		*filter_count = idx;
 	}
@@ -488,9 +553,11 @@
 {
 	def_resp;
 	struct dre_data *csystem_data = reader->csystem_data;
-
+	
 	if(reader->caid == 0x4ae1)
 	{
+		if(reader->caid != b2i(2, ep->caid)) return ERROR;
+		
 		if(ep->type == UNIQUE && ep->emm[39] == 0x3d)
 		{
 			/* For new package activation. */
@@ -502,7 +569,7 @@
 				if((cta_res[cta_lr - 2] != 0x90) || (cta_res[cta_lr - 1] != 0x00))
 					{ return ERROR; }
 		}
-		else
+		else if(ep->emm[0] == 0x86 && ep->emm[4] == 0x02 /*&& csystem_data->provider != 0x11*/)
 		{
 			uchar emmcmd52[0x3a];
 			emmcmd52[0] = 0x52;
@@ -519,6 +586,44 @@
 						{ return ERROR; } //exit if response is not 90 00
 			}
 		}
+		else if(ep->emm[0] == 0x86 && ep->emm[4] == 0x4D && csystem_data->provider == 0x11)
+		{
+			uchar emmcmd52[0x3a];
+			emmcmd52[0] = 0x52;
+			emmcmd52[1] = 0x01;
+			emmcmd52[2] = ep->emm[5];
+			emmcmd52[3] = 0x01;
+			emmcmd52[4] = ep->emm[3];
+			emmcmd52[5] = 0;
+			emmcmd52[6] = 0;
+			emmcmd52[7] = 0;
+			emmcmd52[9] = 0x01;
+			emmcmd52[10] = 0x01;
+			emmcmd52[11] = 0;
+			memcpy(emmcmd52 + 13, ep->emm + 0x5C, 4);
+			int32_t i;
+			for(i = 0; i < 2; i++)
+			{
+				emmcmd52[8] = ep->emm[0x61+i*0x29];
+				if(i == 0) emmcmd52[12] = ep->emm[0x60] == 0x56 ? 0x56:0x3B;
+				else emmcmd52[12] = ep->emm[0x60] == 0x56 ? 0x3B:0x56;
+				memcpy(emmcmd52 + 0x11, ep->emm + 0x62 + i * 0x29, 40);
+				
+				// check for shared address
+				if(ep->emm[3] != reader->sa[0][0])
+					{ return OK; } // ignore, wrong address
+				emmcmd52[0x39] = csystem_data->provider;
+				if((dre_cmd(emmcmd52)))
+					if((cta_res[cta_lr - 2] != 0x90) || (cta_res[cta_lr - 1] != 0x00))
+						{ return ERROR; } //exit if response is not 90 00
+			}
+		}
+		else if(ep->type == GLOBAL && ep->emm[0] == 0x91)
+		{
+			Drecrypt2OverEMM(ep->emm);
+			return OK;
+		}
+		else return ERROR;
 	}
 	else
 	{
diff -ruN oscam-emu-2015-12-03-11142.orig/readers.h oscam-emu-2015-12-03-11142/readers.h
--- oscam-emu-2015-12-03-11142.orig/readers.h	2015-02-22 21:43:15.000000000 +0300
+++ oscam-emu-2015-12-03-11142/readers.h	2015-12-04 00:43:30.000000000 +0300
@@ -15,5 +15,6 @@
 extern const struct s_cardsystem reader_bulcrypt;
 extern const struct s_cardsystem reader_griffin;
 extern const struct s_cardsystem reader_dgcrypt;
+extern const struct s_cardsystem reader_emu;
 
 #endif
diff -ruN oscam-emu-2015-12-03-11142.orig/reader-viaccess.c oscam-emu-2015-12-03-11142/reader-viaccess.c
--- oscam-emu-2015-12-03-11142.orig/reader-viaccess.c	2015-11-03 01:18:59.000000000 +0300
+++ oscam-emu-2015-12-03-11142/reader-viaccess.c	2015-12-04 00:43:30.000000000 +0300
@@ -159,7 +159,7 @@
 static int8_t add_find_class(struct s_reader *reader, uint32_t provid, const uchar *b, int32_t l, int8_t add)
 {
 	int32_t i, j, freshdate = 0;
-
+ 	
 	// b -> via date (4 uint8_ts)
 	b += 4;
 	l -= 4;
@@ -174,7 +174,7 @@
 				if(cs_add_entitlement(reader, reader->caid, provid, cls, cls, 0, 0, 5, 0) == NULL && !add)
 				{
 					rdr_log(reader, "provid %06X class %02X not found -> SKIP!", provid, cls);
-					return -1;
+					return -1; // class not found!
 				}
 				else
 				{
@@ -211,7 +211,7 @@
 					}
 				}
 			}
-	if(freshdate == 0) return -2;
+			if(freshdate == 0) return -2;
 	return 1; // all classes found and emmdate is fresh!
 }
 
@@ -1751,13 +1751,13 @@
 				
 				if(match == -1)
 				{
-					rdr_log(reader, "shared emm provid %06X one or more classes of this emm do not match with your card -> skipped!", emm_provid);
+					rdr_log(reader, "shared emm provid %06X class mismatch -> skipped!", emm_provid);
 					return SKIPPED;
 				}
 				
 				if(match == -2)
 				{
-					rdr_log(reader, "shared emm provid %06X all classes have entitlementdate already same or newer -> skipped!", emm_provid);
+					rdr_log(reader, "shared emm provid %06X class entitlementdate already same or newer -> skipped!", emm_provid);
 					return SKIPPED;
 				}
 				nanoA9Data = emmParsed;
diff -ruN oscam-emu-2015-12-03-11142.orig/snippet.h oscam-emu-2015-12-03-11142/snippet.h
--- oscam-emu-2015-12-03-11142.orig/snippet.h	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/snippet.h	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,235 @@
+uint8_t initial_snippet[3694] =
+{
+	0x6F, 0xF0, 0x0E, 0x0D, 0x00, 0x00, 0x18, 0x75, 0xFF, 0x75, 0x63, 0x72, 0x2E, 0x2C, 0x17, 0x00, 
+	0x00, 0x3F, 0x3D, 0x15, 0x00, 0x00, 0x9C, 0x00, 0xFB, 0xF7, 0xFA, 0xF5, 0x85, 0x4C, 0xFB, 0xF0, 
+	0x04, 0xFB, 0xF8, 0xFB, 0xF1, 0xF7, 0xF0, 0x24, 0x0E, 0x42, 0xFF, 0x22, 0xF0, 0x41, 0x22, 0xF0, 
+	0x60, 0xBF, 0x73, 0xFF, 0x24, 0x4B, 0x72, 0x9D, 0xD0, 0x70, 0x42, 0xF4, 0xBF, 0xA4, 0x70, 0xB1, 
+	0x22, 0xF0, 0x40, 0x49, 0x00, 0x64, 0xFF, 0xB0, 0x25, 0x73, 0xD0, 0x24, 0x4C, 0x25, 0x72, 0xFF, 
+	0x25, 0xFF, 0x21, 0x22, 0x29, 0xA2, 0x25, 0x72, 0xFF, 0x42, 0x21, 0xFB, 0xFA, 0xF6, 0x22, 0x26, 
+	0x03, 0xFF, 0x80, 0x26, 0x2A, 0x0E, 0x80, 0x22, 0x2B, 0x07, 0xFF, 0x80, 0x22, 0x28, 0x05, 0x80, 
+	0x26, 0x2C, 0x07, 0xFF, 0x80, 0x2C, 0x24, 0x05, 0x80, 0x27, 0x20, 0x09, 0xBF, 0x80, 0x26, 0x2E, 
+	0x00, 0x80, 0x23, 0x73, 0x00, 0x22, 0xFF, 0x2C, 0x09, 0x80, 0x25, 0x22, 0x0B, 0x80, 0x25, 0xFF, 
+	0x2C, 0x04, 0x80, 0x21, 0x21, 0x2F, 0x03, 0x2A, 0xFF, 0x24, 0x08, 0x80, 0x2A, 0x27, 0x0F, 0x80, 
+	0x23, 0x7D, 0x2F, 0x8C, 0x00, 0x2D, 0x05, 0x80, 0x23, 0x2C, 0x84, 0x01, 0xFA, 0x90, 0x00, 0x2F, 
+	0x78, 0x00, 0x26, 0x08, 0x80, 0x2E, 0x0A, 0xFF, 0x80, 0x80, 0x27, 0x24, 0x09, 0x80, 0x27, 0x2C, 
+	0xCF, 0x06, 0x80, 0x27, 0x29, 0x78, 0x00, 0x6F, 0x00, 0x2A, 0x2F, 0xFF, 0x0D, 0x80, 0x28, 0x23, 
+	0x05, 0x80, 0x2B, 0x28, 0xF7, 0x08, 0x80, 0x28, 0xB7, 0x00, 0x26, 0x2F, 0x0E, 0x80, 0xFF, 0x27, 
+	0x25, 0x00, 0x80, 0x2B, 0x21, 0x06, 0x80, 0xFF, 0x2A, 0x25, 0x01, 0x80, 0x21, 0x28, 0x00, 0x80, 
+	0xCB, 0x22, 0x2E, 0xB0, 0x01, 0x0D, 0x6D, 0x00, 0x88, 0x00, 0x28, 0x03, 0xFE, 0x91, 0x00, 0x0C, 
+	0x80, 0x2C, 0x2D, 0x0E, 0x80, 0x2A, 0xB5, 0x04, 0xBC, 0x00, 0x2A, 0xD4, 0x00, 0x27, 0x0C, 0xE5, 
+	0x00, 0x07, 0xFF, 0x80, 0x23, 0x2D, 0x0D, 0x80, 0x25, 0x21, 0x00, 0xFF, 0x80, 0x24, 0x24, 0x0D, 
+	0x80, 0x24, 0x2B, 0x08, 0xFF, 0x80, 0x24, 0x2D, 0x0C, 0x80, 0x2D, 0x21, 0x0A, 0xFE, 0x0D, 0x10, 
+	0x0C, 0x80, 0x28, 0x28, 0x02, 0x80, 0x26, 0xDF, 0x27, 0x0A, 0x80, 0x2A, 0x21, 0x24, 0x10, 0x20, 
+	0x08, 0xEA, 0x85, 0x00, 0x03, 0x21, 0x10, 0x0A, 0x19, 0x10, 0x07, 0x80, 0x2F, 0xFE, 0xCF, 0x01, 
+	0x2D, 0x0B, 0x80, 0x2A, 0x24, 0x00, 0x80, 0xFF, 0x29, 0x20, 0x0E, 0x80, 0x26, 0x22, 0x0A, 0x80, 
+	0xFF, 0x21, 0x20, 0x25, 0x01, 0x2A, 0x21, 0x01, 0x80, 0xD3, 0x2A, 0x03, 0xBC, 0x00, 0x6F, 0x10, 
+	0x24, 0x6F, 0x10, 0x21, 0x22, 0xEF, 0x03, 0x80, 0x2C, 0x02, 0x78, 0x10, 0x20, 0x29, 0x0E, 0xFF, 
+	0x28, 0x27, 0x00, 0x80, 0x27, 0x2F, 0x03, 0x80, 0xFB, 0x29, 0x21, 0x8C, 0x00, 0x73, 0x45, 0x25, 
+	0x71, 0x61, 0xFB, 0x2B, 0x96, 0x43, 0x01, 0x2D, 0x20, 0xAE, 0x70, 0x25, 0xFF, 0xB0, 0x22, 0xF0, 
+	0x70, 0xF1, 0x41, 0x24, 0xF6, 0xF5, 0xC0, 0xA2, 0x12, 0x81, 0xA7, 0x17, 0x21, 0x1D, 0x42, 0x24, 
+	0x7F, 0xFA, 0x21, 0x7D, 0x4C, 0x27, 0xF8, 0xD1, 0xC1, 0x10, 0xEF, 0x24, 0xF0, 0x21, 0xDD, 0xC7, 
+	0x11, 0xF1, 0x21, 0xDD, 0xDF, 0x71, 0x21, 0x7D, 0x23, 0xF3, 0xCC, 0x10, 0x1D, 0x70, 0x6A, 0xBE, 
+	0x10, 0x42, 0xB7, 0x13, 0x1F, 0xBE, 0x11, 0x7F, 0x43, 0xC4, 0x11, 0xEB, 0x7F, 0x43, 0xCA, 0x10, 
+	0xDF, 0xF3, 0x11, 0xF1, 0x21, 0xDF, 0x77, 0x71, 0x21, 0x7F, 0xD8, 0x10, 0xDF, 0x21, 0x1F, 0xDE, 
+	0x18, 0x3B, 0x1E, 0x44, 0xBF, 0x10, 0x7E, 0x21, 0x45, 0xC4, 0x11, 0x1A, 0x20, 0xFA, 0xCA, 0x10, 
+	0xDE, 0x20, 0x22, 0xF1, 0x21, 0xDE, 0x71, 0x21, 0x3D, 0x7E, 0xD8, 0x10, 0xDE, 0x21, 0x1E, 0x70, 
+	0x16, 0x20, 0xE2, 0x13, 0x7B, 0x22, 0x14, 0x16, 0x20, 0x22, 0x74, 0x21, 0x47, 0xC4, 0x10, 0xDE, 
+	0x48, 0x21, 0x24, 0xF0, 0x22, 0xD4, 0x4F, 0x22, 0xF1, 0x22, 0xBF, 0xD4, 0x71, 0x22, 0x74, 0x23, 
+	0xF3, 0x55, 0x20, 0x14, 0x3A, 0x39, 0x28, 0x18, 0x45, 0x21, 0x78, 0x21, 0x4E, 0x4C, 0x21, 0x78, 
+	0x20, 0xFA, 0x53, 0x20, 0xD8, 0x7E, 0x22, 0xF1, 0x22, 0xD8, 0x71, 0x22, 0x5D, 0x78, 0x62, 0x20, 
+	0xD8, 0x22, 0x18, 0x39, 0x28, 0x1A, 0x45, 0x21, 0x5B, 0x7A, 0x49, 0x4C, 0x21, 0x7A, 0x49, 0x53, 
+	0x20, 0xDA, 0xAC, 0x21, 0xBF, 0xF1, 0x22, 0xDA, 0x71, 0x22, 0x7A, 0x62, 0x20, 0xDA, 0x7B, 0x22, 
+	0x1A, 0x39, 0x27, 0x81, 0x21, 0x1A, 0x43, 0xBF, 0x10, 0xD1, 0x7A, 0x4B, 0x21, 0xD3, 0x20, 0xCA, 
+	0x10, 0xDA, 0xD9, 0x21, 0xF1, 0x21, 0xE7, 0xDA, 0x71, 0x21, 0xBC, 0x20, 0xDE, 0x20, 0x1A, 0x70, 
+	0x81, 0xAC, 0xD0, 0x20, 0xC7, 0x24, 0x22, 0x19, 0x45, 0x21, 0x79, 0x7A, 0x22, 0x79, 0xFA, 0x81, 
+	0x21, 0xD9, 0x07, 0x31, 0xF1, 0x22, 0xD9, 0x71, 0x22, 0x7D, 0x79, 0x62, 0x20, 0xD9, 0x22, 0x19, 
+	0x70, 0x81, 0xC4, 0x27, 0xAB, 0x22, 0x1B, 0x45, 0x21, 0x7B, 0x4B, 0x22, 0x7B, 0x52, 0x21, 0xDB, 
+	0x7E, 0x35, 0x31, 0xF1, 0x22, 0xDB, 0x71, 0x22, 0x7B, 0x62, 0x20, 0x57, 0xDB, 0x22, 0x1B, 0x1E, 
+	0x3A, 0x17, 0x45, 0x21, 0x77, 0xA8, 0x22, 0xF5, 0x77, 0xAE, 0x21, 0xD7, 0x63, 0x31, 0xF1, 0x22, 
+	0xD7, 0x71, 0xBB, 0x22, 0x77, 0x62, 0x20, 0xD7, 0x22, 0x17, 0x1E, 0x38, 0x82, 0x1B, 0x22, 0x13, 
+	0xD0, 0x20, 0x22, 0x73, 0xEF, 0x11, 0x8B, 0x30, 0x53, 0x20, 0xFD, 0xD3, 0x91, 0x31, 0xF1, 0x22, 
+	0xD3, 0x71, 0x22, 0x73, 0xBE, 0x62, 0x20, 0xD3, 0x22, 0x13, 0x70, 0x82, 0xF2, 0x26, 0x82, 0xDB, 
+	0x22, 0x12, 0x88, 0x31, 0x72, 0x44, 0x4C, 0x21, 0x72, 0x44, 0xFA, 0x53, 0x20, 0xD2, 0xBF, 0x31, 
+	0xF1, 0x22, 0xD2, 0x71, 0x22, 0x5D, 0x72, 0x62, 0x20, 0xD2, 0x22, 0x12, 0xA8, 0x3A, 0x15, 0x88, 
+	0x31, 0x5B, 0x75, 0x46, 0x4C, 0x21, 0x75, 0x46, 0x53, 0x20, 0xD5, 0xED, 0x31, 0xBF, 0xF1, 0x22, 
+	0xD5, 0x71, 0x22, 0x75, 0x62, 0x20, 0xD5, 0x6B, 0x22, 0x15, 0xA8, 0x3A, 0x11, 0x45, 0x21, 0x71, 
+	0x4F, 0x4C, 0x21, 0xF3, 0x71, 0x4F, 0x53, 0x20, 0x1A, 0x42, 0xF1, 0x22, 0xD1, 0x71, 0xFB, 0x22, 
+	0x71, 0x62, 0x20, 0xD1, 0x22, 0x11, 0x70, 0x82, 0x16, 0x7C, 0x37, 0x21, 0x1C, 0x16, 0x21, 0x7C, 
+	0x1B, 0x23, 0x44, 0x40, 0xCA, 0x10, 0xFD, 0xDC, 0x4A, 0x42, 0xF1, 0x21, 0xDC, 0x71, 0x21, 0x7C, 
+	0x6E, 0xD8, 0x10, 0xDC, 0x21, 0x1C, 0x32, 0x49, 0x22, 0x10, 0x45, 0x21, 0x47, 0x70, 0x21, 0x4A, 
+	0x4C, 0x21, 0x75, 0x40, 0x53, 0x20, 0xD0, 0x7B, 0x42, 0xBF, 0xF1, 0x22, 0xD0, 0x71, 0x22, 0x70, 
+	0x62, 0x20, 0xD0, 0xB3, 0x22, 0x10, 0x32, 0x4A, 0x2B, 0x31, 0x21, 0x7B, 0xEF, 0x12, 0x7B, 0xFA, 
+	0xF5, 0x11, 0xDB, 0xAB, 0x41, 0xF1, 0x21, 0xDB, 0x71, 0x21, 0x74, 0x45, 0x30, 0xB0, 0x40, 0x1B, 
+	0x32, 0x48, 0x51, 0x21, 0x11, 0xBE, 0x11, 0xE5, 0x71, 0xC3, 0x12, 0x71, 0xC9, 0x11, 0xD8, 0x42, 
+	0xF1, 0x21, 0xD1, 0x73, 0x71, 0x21, 0x2B, 0x40, 0xDE, 0x40, 0x11, 0x70, 0x51, 0xDF, 0x16, 0x57, 
+	0x51, 0x21, 0x10, 0xBE, 0x11, 0x70, 0xD5, 0x22, 0x70, 0xDB, 0x21, 0x7D, 0xD0, 0x07, 0x51, 0xF1, 
+	0x21, 0xD0, 0x71, 0x21, 0x8D, 0x40, 0xAA, 0x0C, 0x50, 0x10, 0xF0, 0x49, 0x1E, 0xBE, 0x10, 0x7E, 
+	0xA8, 0x21, 0x7E, 0xBA, 0xAE, 0x20, 0xDE, 0x33, 0x50, 0xF1, 0xDE, 0x71, 0x32, 0x20, 0xDE, 0xD9, 
+	0x1E, 0xF0, 0x49, 0xE3, 0x31, 0x75, 0x4D, 0xC4, 0x10, 0x75, 0x4D, 0x77, 0x24, 0xF0, 0xD5, 0x58, 
+	0x50, 0xF1, 0xD5, 0x71, 0xFD, 0x30, 0xAF, 0xD5, 0x15, 0x70, 0x51, 0xF2, 0x26, 0x51, 0xB5, 0x31, 
+	0x72, 0xEA, 0xE9, 0x31, 0x72, 0xEF, 0x30, 0xD2, 0x7D, 0x50, 0xF1, 0xD2, 0x71, 0xA6, 0xCF, 0x30, 
+	0xD2, 0x12, 0x68, 0x59, 0x87, 0x31, 0x73, 0xA8, 0x21, 0x73, 0xBA, 0xAE, 0x20, 0xD3, 0xA2, 0x50, 
+	0xF1, 0xD3, 0x71, 0xA1, 0x30, 0xD3, 0xD9, 0x13, 0x68, 0x59, 0x44, 0x21, 0x74, 0x4B, 0xC4, 0x10, 
+	0x74, 0x4B, 0x77, 0x24, 0xF0, 0xD4, 0xC7, 0x50, 0xF1, 0xD4, 0x71, 0x61, 0x20, 0xCF, 0xD4, 0x14, 
+	0x70, 0x51, 0xC4, 0x47, 0x11, 0x41, 0x71, 0x21, 0x9A, 0xA8, 0x20, 0xD2, 0xE7, 0x50, 0x24, 0xF0, 
+	0xE6, 0x40, 0xB5, 0x20, 0xD1, 0xA5, 0x72, 0x2B, 0x40, 0xD1, 0xEF, 0x40, 0xC4, 0x47, 0x16, 0x16, 
+	0x20, 0x76, 0xB9, 0x21, 0xC3, 0x51, 0x0F, 0x60, 0x24, 0xF0, 0xD6, 0x15, 0x61, 0xF1, 0x7F, 0xD6, 
+	0x71, 0x76, 0x23, 0xF3, 0xD6, 0x16, 0xD7, 0x59, 0x72, 0x59, 0x31, 0x77, 0x79, 0x22, 0x37, 0x60, 
+	0x24, 0xF0, 0xD7, 0x3D, 0x61, 0xB7, 0xF1, 0xD7, 0x71, 0x73, 0x30, 0xD7, 0x17, 0xD7, 0x58, 0x85, 
+	0x55, 0x1F, 0xD0, 0x20, 0x7F, 0xBB, 0x31, 0x7F, 0xC1, 0x30, 0xDF, 0x64, 0x60, 0xF7, 0xF1, 0xDF, 
+	0x71, 0x03, 0x20, 0xDF, 0x1F, 0x70, 0x85, 0x6E, 0xF2, 0x26, 0x86, 0x22, 0x16, 0xBE, 0x10, 0x22, 
+	0x76, 0x77, 0x42, 0xF5, 0x76, 0x7E, 0x41, 0xD6, 0x8B, 0x61, 0xF1, 0x22, 0xD6, 0x71, 0xB9, 0x22, 
+	0x22, 0x60, 0x90, 0x60, 0x16, 0x70, 0x86, 0xDF, 0x16, 0x86, 0x55, 0x19, 0xBE, 0x10, 0x79, 0xEF, 
+	0x11, 0x79, 0xF5, 0x10, 0xD9, 0xB7, 0x60, 0xB7, 0xF1, 0xD9, 0x71, 0x17, 0x30, 0xD9, 0x19, 0xA2, 
+	0x69, 0x1A, 0xF6, 0xBE, 0x10, 0x7A, 0x48, 0xC4, 0x10, 0x7A, 0x48, 0x24, 0xF0, 0xDD, 0xDA, 0xDC, 
+	0x60, 0xF1, 0xDA, 0x71, 0xBC, 0x20, 0xDA, 0x1A, 0xAA, 0xA2, 0x69, 0x18, 0xBE, 0x10, 0x78, 0xA8, 
+	0x21, 0x78, 0xAE, 0x20, 0xD8, 0x6E, 0x01, 0x70, 0xF1, 0xD8, 0x71, 0x90, 0x20, 0xD8, 0x18, 0xA2, 
+	0x68, 0x9F, 0x87, 0x1B, 0x41, 0x24, 0xFA, 0xA6, 0x42, 0xAC, 0x41, 0xDB, 0xF6, 0xB3, 0x41, 0xDB, 
+	0x71, 0x45, 0x30, 0xDB, 0x1B, 0x70, 0x87, 0x54, 0x1E, 0x70, 0x16, 0x74, 0x1C, 0x1E, 0x70, 0x7C, 
+	0xBB, 0x31, 0x7C, 0xC1, 0x30, 0xDD, 0xDC, 0x4B, 0x70, 0xF1, 0xDC, 0x71, 0x5C, 0x40, 0xDC, 0x1C, 
+	0xAA, 0x36, 0x79, 0x1D, 0x1E, 0x70, 0x7D, 0x1C, 0x21, 0x7D, 0x23, 0x20, 0xDD, 0x6E, 0x70, 0x70, 
+	0xF1, 0xDD, 0x71, 0xD7, 0x10, 0xDD, 0x1D, 0x36, 0x77, 0xFE, 0xE2, 0x12, 0x40, 0xD1, 0x70, 0x71, 
+	0xF2, 0xF1, 0xD2, 0xBF, 0x70, 0x41, 0x71, 0xFC, 0xF2, 0xF1, 0x91, 0x70, 0x23, 0xEB, 0xFB, 0x72, 
+	0x97, 0x70, 0x70, 0x9E, 0x70, 0x71, 0x81, 0xD1, 0xBF, 0x41, 0x71, 0xF9, 0xA2, 0x62, 0x0F, 0x8A, 
+	0x7A, 0x42, 0x50, 0x98, 0x77, 0xBF, 0x70, 0xA5, 0x7F, 0x8F, 0x71, 0x85, 0x93, 0x71, 0x47, 0x98, 
+	0x73, 0xF1, 0x85, 0x9E, 0x71, 0xE8, 0x70, 0xCD, 0x77, 0xA3, 0x80, 0x62, 0x0C, 0x4A, 0x8A, 0x76, 
+	0x86, 0xE4, 0x78, 0x86, 0xF0, 0x7F, 0x02, 0x89, 0x81, 0x93, 0x71, 0x45, 0x44, 0x98, 0x73, 0x81, 
+	0x9E, 0x71, 0x3E, 0x80, 0xCD, 0x74, 0x42, 0xFF, 0x7C, 0x05, 0x83, 0xE4, 0x78, 0x83, 0x1B, 0x8B, 
+	0x54, 0x8D, 0x39, 0x82, 0xE8, 0x74, 0x45, 0x82, 0x2A, 0x1F, 0x87, 0x43, 0xFF, 0x7C, 0x82, 0xE4, 
+	0x78, 0x82, 0x9C, 0x8F, 0x02, 0x89, 0xD4, 0xE4, 0x78, 0x1B, 0x8B, 0x44, 0xFF, 0x72, 0x0E, 0xE2, 
+	0x12, 0x2A, 0x23, 0xFF, 0x4F, 0x21, 0xFB, 0x23, 0x1C, 0x21, 0x40, 0x24, 0xFF, 0xFA, 0x40, 0xD1, 
+	0x23, 0x1C, 0x71, 0x70, 0xF2, 0xE9, 0xF1, 0xC1, 0x30, 0x1B, 0x91, 0xF1, 0x19, 0x91, 0x4F, 0x24, 
+	0xF6, 0x3F, 0x23, 0x1C, 0xF2, 0xF1, 0x24, 0xFB, 0x19, 0x90, 0xCF, 0x72, 0xB5, 0x48, 0xAD, 0x71, 
+	0x07, 0x05, 0x93, 0x21, 0x44, 0x0D, 0x90, 0x18, 0x3A, 0x11, 0x94, 0x18, 0x19, 0x9F, 0xF6, 0x23, 
+	0x18, 0x2E, 0x9F, 0xE2, 0x12, 0x7F, 0x29, 0x2E, 0x49, 0x21, 0xFB, 0x24, 0x10, 0x11, 0x93, 0x3B, 
+	0x24, 0x10, 0x54, 0x9F, 0xF6, 0x24, 0x10, 0x69, 0x9F, 0x7B, 0x93, 0x33, 0x2B, 0x4E, 0x0D, 0x90, 
+	0x86, 0x94, 0x23, 0x10, 0x62, 0x82, 0x1D, 0x95, 0xA0, 0x62, 0x82, 0x29, 0x91, 0xA3, 0x92, 0x6E, 
+	0x83, 0xD1, 0x70, 0x45, 0xAD, 0x71, 0x04, 0x56, 0x7B, 0x93, 0x29, 0x40, 0x0D, 0x90, 0x14, 0x11, 
+	0x94, 0x14, 0x8F, 0x9F, 0x67, 0xF6, 0x23, 0x14, 0xA4, 0x9F, 0x7B, 0x93, 0x26, 0x45, 0x83, 0x90, 
+	0xC2, 0x4B, 0x94, 0x24, 0x53, 0x9F, 0xA0, 0x90, 0x68, 0x9F, 0x7A, 0x94, 0x23, 0x4A, 0xD7, 0x21, 
+	0xFB, 0x22, 0x10, 0x94, 0x22, 0x18, 0x9F, 0x24, 0xF6, 0xA9, 0x22, 0x2D, 0x9F, 0x7A, 0x94, 0x20, 
+	0x0C, 0x90, 0x24, 0xFF, 0x94, 0x24, 0xB0, 0x07, 0xAF, 0xA0, 0x90, 0x1C, 0xAF, 0x3F, 0x93, 0x28, 
+	0x2E, 0x47, 0x90, 0x24, 0x82, 0x10, 0x94, 0x24, 0x7D, 0xAF, 0xA0, 0x90, 0x92, 0xAA, 0xAC, 0x72, 
+	0x3F, 0x93, 0x4C, 0xDF, 0x21, 0xD4, 0x4D, 0x21, 0xD5, 0x52, 0x00, 0x42, 0x21, 0xFF, 0x14, 0x25, 
+	0x71, 0x28, 0x2B, 0x95, 0xD0, 0x70, 0xF9, 0xA5, 0xA1, 0x12, 0xE2, 0x12, 0x21, 0x4E, 0x21, 0xD8, 
+	0x22, 0x57, 0x40, 0x21, 0xD9, 0x26, 0xB2, 0x18, 0x2C, 0xB0, 0x29, 0x30, 0xBB, 0xFF, 0x23, 0x44, 
+	0x21, 0xD6, 0x23, 0x45, 0x21, 0xD7, 0xEA, 0x26, 0xB2, 0x16, 0x2C, 0xB0, 0x27, 0x30, 0xBB, 0x46, 
+	0x21, 0xD2, 0xAF, 0x24, 0x40, 0x21, 0xD3, 0x26, 0xB2, 0x12, 0x2C, 0xB0, 0x25, 0xDC, 0x99, 0x10, 
+	0x33, 0xB8, 0x25, 0x73, 0x21, 0x94, 0x10, 0x6B, 0x2A, 0xBF, 0x9A, 0xD0, 0x70, 0x41, 0xF4, 0xA7, 
+	0x32, 0xB4, 0x70, 0x5F, 0xC1, 0xC0, 0xA2, 0x21, 0x01, 0x9D, 0xB0, 0x47, 0xA1, 0xB0, 0x7B, 0x28, 
+	0x9F, 0x90, 0xBF, 0x71, 0x6B, 0x27, 0x99, 0xA6, 0xBF, 0xDA, 0x9D, 0xB0, 0x49, 0xA1, 0xB0, 0x25, 
+	0x9E, 0xC1, 0xBF, 0x71, 0x6B, 0x53, 0x24, 0x98, 0xD7, 0xBF, 0x9D, 0xB0, 0x4F, 0xA1, 0xB0, 0x22, 
+	0x42, 0x00, 0xF6, 0xF4, 0xBF, 0x21, 0x97, 0x08, 0xCF, 0x25, 0x73, 0x22, 0x4B, 0xDF, 0x25, 0x71, 
+	0x6C, 0x2F, 0x9C, 0x23, 0xCF, 0x71, 0x6C, 0x79, 0x2E, 0x99, 0x10, 0x3B, 0xCC, 0x00, 0x25, 0x73, 
+	0x46, 0x4F, 0xC0, 0x95, 0x2C, 0x53, 0xCD, 0x22, 0xEC, 0xB0, 0x6C, 0x98, 0x11, 0x3B, 0xCF, 0x22, 
+	0xAD, 0x4A, 0x4F, 0xC0, 0x29, 0x9B, 0x54, 0xCC, 0x40, 0x4F, 0xC0, 0x28, 0xDC, 0x99, 0x12, 0x33, 
+	0xB3, 0x25, 0x73, 0x41, 0x4F, 0xC0, 0x27, 0x94, 0x5A, 0xCA, 0xC9, 0x42, 0x4F, 0xC0, 0x26, 0x92, 
+	0xCA, 0xC9, 0x43, 0x4F, 0xC0, 0x2B, 0x25, 0x90, 0xCA, 0xC9, 0x44, 0x4F, 0xC0, 0x23, 0xF1, 0xB0, 
+	0xCC, 0xC5, 0x4C, 0x98, 0xB4, 0x1D, 0xC0, 0x6C, 0x22, 0x38, 0xC0, 0xCC, 0xC7, 0x21, 0xC4, 0xC1, 
+	0x35, 0x21, 0xDB, 0xCA, 0x21, 0xD6, 0xC1, 0x20, 0x91, 0x29, 0xDA, 0xE8, 0xC0, 0x63, 0x6D, 0x2E, 
+	0x11, 0xD8, 0x9D, 0xB0, 0xFA, 0xC0, 0x6D, 0x2D, 0xB4, 0xC0, 0x3A, 0x14, 0xDC, 0x21, 0x7E, 0xC0, 
+	0x6D, 0x2C, 0x93, 0x29, 0xDA, 0xBB, 0xB0, 0x53, 0x6D, 0x2B, 0xFF, 0xCA, 0x87, 0xD1, 0x29, 0x61, 
+	0xDB, 0x48, 0x5D, 0xD0, 0x49, 0x28, 0x74, 0xD8, 0x97, 0xD4, 0x27, 0x07, 0xC0, 0x14, 0xDC, 0x22, 
+	0x6F, 0xD1, 0x35, 0x26, 0xFF, 0xCA, 0x22, 0x0C, 0xD0, 0x6D, 0x24, 0x42, 0x02, 0xF4, 0xD6, 0x86, 
+	0x94, 0x10, 0x6D, 0x23, 0xA5, 0xB0, 0xF2, 0xD8, 0x87, 0xD1, 0x27, 0xDB, 0x22, 0x78, 0x9A, 0xD1, 
+	0x3A, 0xD9, 0x8C, 0xC5, 0x4D, 0x25, 0x71, 0x6E, 0x52, 0xC1, 0x8A, 0xF2, 0xD8, 0x4E, 0x4F, 0xE0, 
+	0x2E, 0xD6, 0xB0, 0xF2, 0xD8, 0x1D, 0xC0, 0x6E, 0x55, 0x2D, 0xC9, 0xCA, 0x23, 0xC4, 0xC0, 0x6E, 
+	0x8B, 0xDB, 0x23, 0xD6, 0xC0, 0x31, 0x6E, 0x9E, 0xD9, 0x98, 0xB4, 0x7E, 0xC0, 0x6E, 0x29, 0x66, 
+	0xEA, 0x61, 0xE1, 0x09, 0x28, 0x28, 0xDB, 0x0C, 0xD0, 0x6E, 0xDA, 0xCB, 0xB1, 0xE1, 0xEC, 0xCB, 
+	0xB1, 0xE1, 0x60, 0xFE, 0xCB, 0xB1, 0xE1, 0x10, 0xD9, 0x9D, 0xB0, 0xAF, 0xC0, 0x6E, 0x22, 0xC4, 
+	0xDB, 0xA6, 0x4E, 0xC0, 0x6E, 0x21, 0xD7, 0xD8, 0xAF, 0xE3, 0x20, 0xC9, 0xCA, 0x21, 0x9F, 0x4C, 
+	0x25, 0x71, 0x6F, 0x2F, 0x8C, 0xDB, 0x4E, 0xE0, 0x6F, 0x99, 0x2E, 0xEF, 0xDB, 0xD6, 0xC0, 0x6F, 
+	0x2C, 0x02, 0xEB, 0xE8, 0xC0, 0x6F, 0x99, 0x2B, 0x15, 0xEB, 0xBF, 0xD0, 0x6F, 0x2A, 0x28, 0xDA, 
+	0x7E, 0xC0, 0x6F, 0x68, 0x4F, 0xB1, 0xF2, 0xD8, 0x57, 0xF1, 0x28, 0xED, 0xED, 0x6F, 0x27, 0xFF, 
+	0xCA, 0xD5, 0x23, 0x90, 0xF1, 0x25, 0x02, 0xEA, 0x23, 0xFA, 0xC0, 0x6F, 0x24, 0x4A, 0x15, 0xEA, 
+	0x23, 0xB5, 0xF1, 0x23, 0x28, 0xDA, 0xFF, 0xF2, 0x22, 0xDB, 0xCA, 0xEA, 0xFF, 0xF2, 0x21, 0x4E, 
+	0xDA, 0x23, 0x4E, 0xC0, 0x61, 0x2F, 0x2F, 0xAC, 0xF2, 0xFB, 0x57, 0xF0, 0x61, 0x2F, 0x65, 0xEB, 
+	0x23, 0x4E, 0xE0, 0x61, 0x73, 0x2F, 0x2D, 0xBA, 0xFA, 0xFF, 0xF1, 0x61, 0x2F, 0x2C, 0x3E, 0x0B, 
+	0x6E, 0x61, 0xE0, 0x61, 0x2F, 0x2A, 0xF2, 0xFE, 0x61, 0x2F, 0xB5, 0xEB, 0x5D, 0x24, 0xD6, 0xC0, 
+	0x61, 0x2F, 0x28, 0xBA, 0xFA, 0x24, 0xBB, 0xB0, 0xD7, 0x61, 0x2F, 0x27, 0x4E, 0xDA, 0x24, 0xBF, 
+	0xD0, 0x61, 0x2F, 0x9C, 0xF1, 0xFB, 0x56, 0xF1, 0x61, 0x2F, 0x24, 0x66, 0xEB, 0xE8, 0xC0, 0x61, 
+	0x73, 0x2F, 0x23, 0xCA, 0x0B, 0xEC, 0xB0, 0x61, 0x2F, 0x22, 0xDE, 0x0B, 0x4E, 0xAF, 0xC0, 0x61, 
+	0x2F, 0x20, 0x02, 0xE8, 0x98, 0xB4, 0x23, 0xD8, 0x01, 0xB3, 0x2E, 0x2F, 0xDB, 0xCA, 0x73, 0xE1, 
+	0x61, 0x2E, 0x6E, 0xFB, 0x23, 0x62, 0xEC, 0x01, 0x2E, 0x82, 0xC1, 0x7C, 0xE8, 0x28, 0x11, 0x2E, 
+	0x2B, 0x37, 0xFA, 0x2D, 0x23, 0x3C, 0x11, 0x2E, 0x2A, 0x3B, 0xEF, 0x23, 0x69, 0x12, 0xC3, 0xDB, 
+	0x92, 0xBD, 0x13, 0x27, 0x18, 0x0B, 0x69, 0x12, 0x26, 0x8C, 0xEB, 0x69, 0x12, 0x24, 0xD4, 0xC0, 
+	0xB0, 0xC7, 0x1D, 0x23, 0x74, 0xDF, 0x24, 0x14, 0x11, 0x2E, 0x22, 0x5A, 0xED, 0xCA, 0x24, 0x88, 
+	0x01, 0x2E, 0x20, 0x61, 0xDA, 0x24, 0x0C, 0xD0, 0xD7, 0x61, 0x2D, 0x2F, 0x15, 0xEA, 0x24, 0xA0, 
+	0xB0, 0x61, 0x2D, 0x38, 0x68, 0xC1, 0xB9, 0x08, 0x7E, 0xC0, 0x61, 0x2D, 0x2D, 0xED, 0xC8, 0x98, 
+	0xB4, 0x92, 0xD8, 0x01, 0x2D, 0x94, 0xFB, 0xEC, 0x01, 0x2D, 0xA7, 0xFB, 0x28, 0x11, 0x2D, 0x99, 
+	0x29, 0xDB, 0xCA, 0x3C, 0x11, 0x2D, 0x28, 0x4E, 0xDA, 0x4C, 0x01, 0x2D, 0xF5, 0x26, 0x11, 0xDD, 
+	0x43, 0x24, 0x31, 0x60, 0xBD, 0x40, 0xD0, 0xFF, 0x75, 0x21, 0xA0, 0x41, 0x60, 0x8F, 0xD2, 0x75, 
+	0xFF, 0x74, 0x61, 0x2D, 0x23, 0x95, 0xD1, 0x71, 0xA9, 0x7F, 0x71, 0xD0, 0x06, 0x21, 0x20, 0x46, 
+	0xB3, 0xDF, 0x81, 0xFF, 0x72, 0xC0, 0xA2, 0x41, 0xD1, 0x71, 0xC0, 0xA4, 0xDF, 0x21, 0x20, 0x41, 
+	0xD0, 0x70, 0x10, 0x30, 0x41, 0x71, 0xFF, 0xE0, 0x71, 0x30, 0x60, 0x8F, 0x71, 0xE0, 0x40, 0xFE, 
+	0xF4, 0x20, 0xBF, 0x40, 0xD0, 0x72, 0x30, 0xC0, 0xA7, 0xDF, 0x72, 0x30, 0x81, 0x72, 0xE0, 0x1F, 
+	0x30, 0xA4, 0x40, 0xED, 0xB1, 0x3C, 0xB0, 0x20, 0x41, 0x43, 0x30, 0x20, 0x20, 0x00, 0xFF, 0x0D, 
+	0x0B, 0x0A, 0x08, 0x02, 0x09, 0x01, 0x05, 0xFF, 0x0C, 0x0E, 0x03, 0x07, 0x04, 0x0F, 0x06, 0x0B, 
+	0xFF, 0x0C, 0x08, 0x09, 0x0F, 0x04, 0x03, 0x00, 0x0D, 0x7F, 0x01, 0x0A, 0x0E, 0x06, 0x02, 0x07, 
+	0x05, 0x62, 0x30, 0xFF, 0x0B, 0x06, 0x09, 0x00, 0x01, 0x0A, 0x05, 0x0E, 0xFF, 0x0D, 0x0C, 0x02, 
+	0x08, 0x07, 0x0F, 0x05, 0x03, 0xFF, 0x0B, 0x04, 0x0A, 0x09, 0x01, 0x0C, 0x06, 0x0E, 0xFF, 0x08, 
+	0x00, 0x07, 0x02, 0x0D, 0x02, 0x04, 0x0A, 0xFF, 0x0F, 0x0C, 0x01, 0x0E, 0x0B, 0x00, 0x09, 0x03, 
+	0xFF, 0x08, 0x0D, 0x07, 0x06, 0x05, 0x04, 0x03, 0x05, 0xFB, 0x0A, 0x06, 0x95, 0x30, 0x0E, 0x02, 
+	0x0C, 0x0F, 0x0D, 0xFF, 0x07, 0x08, 0x01, 0x05, 0x0A, 0x03, 0x02, 0x07, 0xFF, 0x04, 0x0D, 0x0E, 
+	0x01, 0x08, 0x00, 0x0F, 0x0C, 0xFF, 0x09, 0x06, 0x0B, 0x05, 0x0C, 0x09, 0x03, 0x01, 0xFF, 0x0D, 
+	0x07, 0x04, 0x06, 0x08, 0x0B, 0x02, 0x0A, 0xFF, 0x00, 0x0F, 0x0E, 0x05, 0x0D, 0x09, 0x01, 0x08, 
+	0xFF, 0x06, 0x04, 0x03, 0x0A, 0x07, 0x02, 0x0E, 0x00, 0xFF, 0x0B, 0x0C, 0x0F, 0x71, 0x51, 0x25, 
+	0xFA, 0x31, 0x5F, 0xD1, 0x32, 0xF6, 0x71, 0x54, 0xE0, 0x34, 0x57, 0xE0, 0x34, 0xF5, 0x5A, 0xE0, 
+	0x34, 0x5D, 0xE0, 0x33, 0x70, 0x72, 0x69, 0x6E, 0xFF, 0x74, 0x66, 0x00, 0x69, 0x63, 0x67, 0x5F, 
+	0x72, 0xFF, 0x75, 0x6E, 0x5F, 0x69, 0x6E, 0x5F, 0x74, 0x68, 0xFF, 0x72, 0x65, 0x61, 0x64, 0x73, 
+	0x00, 0x6D, 0x61, 0xFF, 0x6C, 0x6C, 0x6F, 0x63, 0x00, 0x66, 0x72, 0x65, 0xFF, 0x65, 0x00, 0x65, 
+	0x78, 0x69, 0x74, 0x00, 0x73, 0xFF, 0x6E, 0x69, 0x70, 0x70, 0x65, 0x74, 0x5F, 0x64, 0xFF, 0x65, 
+	0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0xC7, 0x69, 0x7A, 0x65, 0x30, 0x46, 0x3B, 0x4F, 0x17, 
+	0x44, 0x5F, 0x63, 0x57, 0x6F, 0x75, 0x6E, 0x37, 0x41, 0x63, 0x45, 0x47, 0x64, 0x6D, 0x4A, 0xFF, 
+	0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x5F, 0xBF, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x30, 
+	0x48, 0x63, 0x7F, 0x72, 0x79, 0x70, 0x74, 0x00, 0x20, 0x20, 0x82, 0x90, 0xFF, 0x71, 0x21, 0x29, 
+	0x9D, 0x20, 0x21, 0x28, 0x09, 0xFF, 0x20, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x20, 0xB7, 0x66, 
+	0x75, 0x6E, 0x92, 0x42, 0x20, 0x63, 0x21, 0x40, 0x20, 0xFF, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x0A, 
+	0x00, 0x60, 0xFF, 0xBB, 0x40, 0xD4, 0x77, 0x30, 0x40, 0xF9, 0x24, 0xEF, 0xA6, 0x40, 0xD0, 0x78, 
+	0xD7, 0x40, 0x23, 0xA4, 0x74, 0xFF, 0x43, 0xF8, 0xD3, 0x70, 0x43, 0xF8, 0x78, 0x31, 0xFF, 0xFA, 
+	0xD1, 0x73, 0x77, 0x31, 0xFA, 0xD2, 0x71, 0xFF, 0x30, 0x72, 0x30, 0x76, 0x2E, 0x9B, 0xC0, 0x21, 
+	0x5F, 0xA0, 0x71, 0x32, 0x72, 0xE2, 0xE8, 0x43, 0x31, 0xEF, 0x41, 0xD7, 0xE1, 0x70, 0x81, 0xDD, 
+	0x40, 0x70, 0xAE, 0x70, 0x00, 0x74, 0xFD, 0x81, 0xD5, 0x40, 0x74, 0xF9, 0xA2, 0x64, 0x0A, 0xB5, 
+	0xEE, 0xF4, 0x20, 0xBB, 0x40, 0xD3, 0xD6, 0x42, 0xA1, 0x68, 0x47, 0xF7, 0x21, 0xFB, 0xD4, 0xDC, 
+	0x43, 0x22, 0xAA, 0x73, 0x43, 0xD7, 0xF8, 0xD2, 0x72, 0xF0, 0x40, 0xD1, 0xE8, 0x43, 0x30, 0x71, 
+	0xFF, 0x30, 0x76, 0x29, 0x95, 0xC0, 0xA9, 0x74, 0x71, 0x73, 0xE2, 0x76, 0x40, 0x51, 0x0D, 0x57, 
+	0x0A, 0x73, 0x81, 0x28, 0x50, 0xDF, 0x73, 0xF9, 0xA2, 0x63, 0x04, 0x22, 0x50, 0x71, 0x21, 0xFF, 
+	0x30, 0x72, 0xE0, 0x71, 0x21, 0x31, 0x72, 0xE1, 0xFF, 0x71, 0x22, 0x34, 0x73, 0xE0, 0x71, 0x22, 
+	0x35, 0x5B, 0x73, 0xE1, 0x71, 0x50, 0x22, 0x54, 0x71, 0x51, 0x50, 0xF4, 0x20, 0xD5, 0xBC, 0xF8, 
+	0x20, 0x22, 0xE7, 0x30, 0xD1, 0xD7, 0x40, 0x21, 0xA2, 0xD5, 0x75, 0xE8, 0x40, 0x71, 0x0B, 0x53, 
+	0x71, 0x12, 0x51, 0x61, 0x0E, 0xDE, 0xF8, 0x21, 0x50, 0x25, 0xFA, 0xD2, 0x37, 0x51, 0xA2, 0x61, 
+	0x7E, 0xE6, 0xA1, 0xD3, 0x40, 0xD1, 0x75, 0x71, 0x72, 0x0B, 0x50, 0xF5, 0x73, 0xCA, 0x51, 0xE2, 
+	0xAA, 0x51, 0x43, 0xF2, 0xD1, 0x72, 0xF6, 0xAE, 0x52, 0x06, 0xB4, 0xF4, 0x21, 0x75, 0x76, 0x24, 
+	0xFB, 0x7F, 0x43, 0x24, 0xF6, 0xC0, 0x22, 0xAE, 0x24, 0xE7, 0xA0, 0xFD, 0x30, 0x9A, 0x50, 0x47, 
+	0x24, 0xF1, 0xD2, 0x06, 0x75, 0xBF, 0x51, 0xD5, 0x76, 0x51, 0xD6, 0x75, 0xF6, 0x50, 0xD0, 0xF7, 
+	0x76, 0x30, 0xF4, 0xFB, 0x40, 0x70, 0x71, 0xF4, 0x70, 0x9F, 0x23, 0xF2, 0x24, 0xF6, 0x72, 0xED, 
+	0x50, 0x01, 0x80, 0x0F, 0xFB, 0x75, 0xF1, 0x07, 0x61, 0xF1, 0xF4, 0x25, 0xFA, 0xC0, 0xFF, 0xAA, 
+	0x70, 0xA9, 0x75, 0x81, 0xD5, 0x76, 0x81, 0xAF, 0xD6, 0x61, 0x0A, 0xF0, 0x10, 0x30, 0x01, 0x3A, 
+	0x60, 0x71, 0xFF, 0x28, 0x9D, 0xA6, 0x21, 0x23, 0x29, 0xFA, 0x22, 0xFB, 0xF0, 0x00, 0x4A, 0x31, 
+	0x20, 0x60, 0xB0, 0x4A, 0xD6, 0xFF, 0x21, 0x72, 0x21, 0x71, 0x28, 0x9A, 0x41, 0xF2, 0xFF, 0xD7, 
+	0x21, 0x72, 0xD8, 0x10, 0x21, 0x71, 0x23, 0xFF, 0x93, 0x7B, 0x22, 0xC2, 0xC0, 0x21, 0xAB, 0x7B, 
+	0xFF, 0x60, 0xCE, 0xC0, 0x21, 0xAA, 0x7B, 0x60, 0xCD, 0xFE, 0x6C, 0x60, 0x21, 0x71, 0x2E, 0x91, 
+	0x23, 0x2E, 0x4D, 0x9F, 0xF0, 0xE0, 0x60, 0x4F, 0x21, 0x8C, 0x71, 0x80, 0x61, 0x60, 0xF5, 0x4E, 
+	0x85, 0x62, 0x4D, 0x80, 0x61, 0x20, 0x71, 0x21, 0x9D, 0xDF, 0xAE, 0x24, 0xF2, 0x21, 0x32, 0xF6, 
+	0x51, 0xAB, 0x72, 0xDB, 0x42, 0x9E, 0x8D, 0x61, 0x72, 0xEB, 0xA6, 0x65, 0x75, 0xF6, 0xFB, 0x42, 
+	0xD2, 0x9A, 0x65, 0xA4, 0x40, 0x45, 0x95, 0xD2, 0xF3, 0x72, 0xC1, 0xB2, 0x61, 0x4B, 0x61, 0xBF, 
+	0x68, 0xFC, 0xD0, 0xF1, 0x70, 0x30, 0x50, 0x0B, 0x60, 0x49, 0x31, 0x11, 0x00, 0x20, 0x05, 0xBF, 
+	0x60, 0xBF, 0x73, 0x81, 0xD2, 0x73, 0xEC, 0x50, 0x21, 0xFF, 0xA4, 0x73, 0x25, 0xFA, 0x81, 0xD3, 
+	0xF1, 0xA7, 0x7E, 0xE7, 0x61, 0xA8, 0x60, 0x02, 0x73, 0x72, 0xFC, 0x43, 0x30, 0xFD, 0x24, 0x82, 
+	0x90, 0xD4, 0x03, 0x73, 0x51, 0xD3, 0x73, 0xB6, 0x06, 0x61, 0x74, 0x30, 0x12, 0x63, 0x74, 0x31, 
+	0x19, 0x62, 0x61, 0xF7, 0x07, 0x70, 0x2F, 0x29, 0x90, 0x21, 0xAE, 0x70, 0x2F, 0xF7, 0x2F, 0x20, 
+	0x40, 0xE9, 0x60, 0xA0, 0x70, 0x74, 0x32, 0xEF, 0x24, 0xF6, 0xA5, 0x80, 0x07, 0x70, 0x0D, 0x73, 
+	0x83, 0xFF, 0xD3, 0x09, 0x80, 0x73, 0x82, 0xD3, 0x04, 0x80, 0xE8, 0x66, 0x50, 0xFB, 0x63, 0x3A, 
+	0x61, 0x80, 0x52, 0x70, 0x00, 0x00, 0xFF, 0xAF, 0x00, 0x71, 0x22, 0x56, 0x49, 0x62, 0x00, 0x62, 
+	0x70, 0xD0, 0xA9, 0x13, 0x62, 0x71, 0x68, 0x73, 0xD7, 0x67, 0x78, 0xEA, 0x67, 0x78, 0xF1, 0xAA, 
+	0x67, 0x78, 0xF6, 0x67, 0x78, 0x05, 0x62, 0x70, 0x04, 0x62, 0x70, 0xFB, 0x7E, 0x67, 0x74, 0xFB, 
+	0x12, 0x00, 0x00, 0x10, 0x14, 0x68, 0x73, 0xA5, 0xEF, 0xB3, 0x70, 0x23, 0xB7, 0x74, 0x62, 0x71, 
+	0x3C, 0xB7, 0x74, 0x03, 0xAA, 0x62, 0x70, 0x4B, 0xB7, 0x74, 0x1A, 0x62, 0x70, 0x62, 0xB7, 0x74, 
+	0xC0, 0xAA, 0xB3, 0x70, 0x06, 0x62, 0x70, 0x48, 0x9B, 0x78, 0x11, 0x62, 0x70, 0x1D, 0xAA, 0x62, 
+	0x70, 0x29, 0x62, 0x70, 0x35, 0x62, 0x70, 0x44, 0x62, 0x70, 0x49, 0xAA, 0x62, 0x70, 0x51, 0x62, 
+	0x70, 0x55, 0x62, 0x70, 0x5D, 0x62, 0x70, 0x61, 0xAA, 0x62, 0x70, 0x69, 0x62, 0x70, 0x6D, 0x62, 
+	0x70, 0x75, 0x62, 0x70, 0x79, 0xAA, 0x62, 0x70, 0x81, 0x62, 0x70, 0x85, 0x62, 0x70, 0x8D, 0x62, 
+	0x70, 0x94, 0xFE, 0x1F, 0x81, 0x15, 0x00, 0x00, 0x2E, 0x2E, 0x2F, 0x67, 0xFF, 0x65, 0x6E, 0x65, 
+	0x72, 0x61, 0x74, 0x6F, 0x72, 0x7D, 0x2F, 0x6E, 0x40, 0x2E, 0x64, 0x62, 0x67, 0x00
+};
+
diff -ruN oscam-emu-2015-12-03-11142.orig/webif/config/dvbapi.html oscam-emu-2015-12-03-11142/webif/config/dvbapi.html
--- oscam-emu-2015-12-03-11142.orig/webif/config/dvbapi.html	2015-11-01 19:25:12.000000000 +0300
+++ oscam-emu-2015-12-03-11142/webif/config/dvbapi.html	2015-12-04 00:43:30.000000000 +0300
@@ -53,12 +53,4 @@
 			</TD>
 		</TR>
 		<TR><TD><A>Write detected prov name to srvid:</A></TD><TD><input name="write_sdt_prov" type="checkbox" value="1" ##WRITESDTPROVCHECKED##><label></label>
-		<!-- <TR><TD><A>API for extended CWs</A></TD>
-			<TD>
-				<select name="extended_cw_api">
-					<option value="0" ##EXTENDEDCWAPISELECTED0##>0 - none (disabled)</option>
-					<option value="1" ##EXTENDEDCWAPISELECTED1##>1 - OE2.2</option>
-					<option value="2" ##EXTENDEDCWAPISELECTED2##>2 - OE2.0</option>
-				</select>
-			</TD>
-		</TR> -->			
\      
+			
\      
diff -ruN oscam-emu-2015-12-03-11142.orig/webif/config/menu.html oscam-emu-2015-12-03-11142/webif/config/menu.html
--- oscam-emu-2015-12-03-11142.orig/webif/config/menu.html	2015-08-13 22:46:37.000000000 +0300
+++ oscam-emu-2015-12-03-11142/webif/config/menu.html	2015-12-04 00:43:30.000000000 +0300
@@ -16,6 +16,7 @@
 ##TPLCONFIGMENUDVBAPI##		<!-- CMENUACTIVE13 -->
 ##TPLCONFIGMENULCD##		<!-- CMENUACTIVE14 -->
 ##TPLCONFIGMENUMONITOR##	<!-- CMENUACTIVE15 -->
+##TPLCONFIGMENUSTREAMRELAY##
 			<LI CLASS="##CMENUACTIVE16##"><A HREF="config.html?part=webif">WebIf</A></LI>
 	</UL>
-</DIV>
\      
+</DIV>
diff -ruN oscam-emu-2015-12-03-11142.orig/webif/config/menu_streamrelay.html oscam-emu-2015-12-03-11142/webif/config/menu_streamrelay.html
--- oscam-emu-2015-12-03-11142.orig/webif/config/menu_streamrelay.html	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/webif/config/menu_streamrelay.html	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1 @@
+			<LI CLASS="##CMENUACTIVE16##"><A HREF="config.html?part=streamrelay">Stream Relay</A></LI>
diff -ruN oscam-emu-2015-12-03-11142.orig/webif/config/streamrelay.html oscam-emu-2015-12-03-11142/webif/config/streamrelay.html
--- oscam-emu-2015-12-03-11142.orig/webif/config/streamrelay.html	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/webif/config/streamrelay.html	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1,7 @@
+		<input name="part" type="hidden" value="streamrelay">
+		<TABLE CLASS="config">
+			<TR><TH COLSPAN="2">Edit Stream Relay Config</TH></TR>
+			<TR><TD><A>Source Stream Port:</A></TD><TD><input name="strean_source_port" class="short" type="text" maxlength="5" value="##STREAM_SOURCE_PORT##"></TD></TR>
+			<TR><TD><A>Relay Port:</A></TD><TD><input name="stream_relay_port" class="short" type="text" maxlength="5" value="##STREAM_RELAY_PORT##"></TD></TR>
+			<TR><TD><A>ECM fix delay:</A></TD><TD><input name="stream_ecm_delay" class="short" type="text" maxlength="5" value="##STREAM_ECM_DELAY##"></TD></TR>
+			
\      
diff -ruN oscam-emu-2015-12-03-11142.orig/webif/files/menu.html oscam-emu-2015-12-03-11142/webif/files/menu.html
--- oscam-emu-2015-12-03-11142.orig/webif/files/menu.html	2015-09-30 01:44:32.000000000 +0300
+++ oscam-emu-2015-12-03-11142/webif/files/menu.html	2015-12-04 00:43:30.000000000 +0300
@@ -9,7 +9,7 @@
 ##TPLFILEMENUANTICASC##	<!-- CMENUACTIVE6 -->
 		<LI CLASS="##CMENUACTIVE7##"><A HREF="files.html?file=logfile">logfile</A></LI>
 		<LI CLASS="##CMENUACTIVE8##"><A HREF="files.html?file=userfile">userfile</A></LI>
-		<LI CLASS="##CMENUACTIVE9## ##CMENUACTIVE10## ##CMENUACTIVE11## ##CMENUACTIVE12## ##CMENUACTIVE13## ##CMENUACTIVE14## ##CMENUACTIVE15## ##CMENUACTIVE16## ##CMENUACTIVE17## ##CMENUACTIVE18##"><A HREF="#"  class="drop">other file<b class="subcaret"></b></A>
+		<LI CLASS="##CMENUACTIVE9## ##CMENUACTIVE10## ##CMENUACTIVE11## ##CMENUACTIVE12## ##CMENUACTIVE13## ##CMENUACTIVE14## ##CMENUACTIVE15## ##CMENUACTIVE16## ##CMENUACTIVE17## ##CMENUACTIVE18## ##CMENUACTIVE19##"><A HREF="#"  class="drop">other file<b class="subcaret"></b></A>
 			<UL CLASS="dropdown_nav">
 				<LI CLASS="##CMENUACTIVE9##"><A HREF="files.html?file=oscam.services">oscam.services</A></LI>
 				<LI CLASS="##CMENUACTIVE10##"><A HREF="files.html?file=oscam.provid">oscam.provid</A></LI>
@@ -21,6 +21,7 @@
 ##VIEW_FILEMENUCSS##	<!-- CMENUACTIVE16 -->
 ##TPLFILEMENUTWIN##	    <!-- CMENUACTIVE17 -->
 ##TPLFILEMENUCONSTCW##  <!-- CMENUACTIVE18 -->
+##TPLFILEMENUKEY##
 			</UL>
 		</LI>
 	</UL>
diff -ruN oscam-emu-2015-12-03-11142.orig/webif/files/menu_key.html oscam-emu-2015-12-03-11142/webif/files/menu_key.html
--- oscam-emu-2015-12-03-11142.orig/webif/files/menu_key.html	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/webif/files/menu_key.html	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1 @@
+			<LI CLASS="##CMENUACTIVE29##"><A HREF="files.html?file=SoftCam.Key">SoftCam.Key</A></LI>
diff -ruN oscam-emu-2015-12-03-11142.orig/webif/pages_index.txt oscam-emu-2015-12-03-11142/webif/pages_index.txt
--- oscam-emu-2015-12-03-11142.orig/webif/pages_index.txt	2015-09-30 01:44:32.000000000 +0300
+++ oscam-emu-2015-12-03-11142/webif/pages_index.txt	2015-12-04 00:43:30.000000000 +0300
@@ -80,11 +80,13 @@
 CONFIGMENUNEWCAMD             config/menu_newcamd.html                                    MODULE_NEWCAMD
 CONFIGMENURADEGAST            config/menu_radegast.html                                   MODULE_RADEGAST
 CONFIGMENUSCAM                config/menu_scam.html                                       MODULE_SCAM
+CONFIGMENUSTREAMRELAY         config/menu_streamrelay.html                                WITH_EMU
 CONFIGMENUSERIAL              config/menu_serial.html                                     MODULE_SERIAL
 CONFIGMONITOR                 config/monitor.html                                         MODULE_MONITOR
 CONFIGNEWCAMD                 config/newcamd.html                                         MODULE_NEWCAMD
 CONFIGRADEGAST                config/radegast.html                                        MODULE_RADEGAST
 CONFIGSCAM                    config/scam.html                                            MODULE_SCAM
+CONFIGSTREAMRELAY             config/streamrelay.html                                     WITH_EMU
 CONFIGSERIAL                  config/serial.html                                          MODULE_SERIAL
 CONFIGSERIALDEVICEBIT         config/serial_devices.html                                  MODULE_SERIAL
 CONFIGWEBIF                   config/webif.html
@@ -117,6 +119,7 @@
 FILEMENUDVBAPI                files/menu_dvbapi.html                                      HAVE_DVBAPI
 FILEMENUFAKECWS               files/menu_fakecws.html                                     CS_CACHEEX
 FILEMENUTWIN                  files/menu_twin.html                                        MODULE_SERIAL
+FILEMENUKEY                   files/menu_key.html                                         WITH_EMU
 
 AUTOCONF                      ghttp/autoconf.html                                         MODULE_GHTTP
 PREAUTOCONF                   ghttp/pre_autoconf.html                                     MODULE_GHTTP
@@ -180,6 +183,7 @@
 READEREDITCACHEEXBIT          readerconfig/readerconfig_cacheexbit.html                   CS_CACHEEX
 READERCONFIGCAMD35BIT         readerconfig/readerconfig_camd35bit.html                    MODULE_CAMD35
 READERCONFIGCCCAMBIT          readerconfig/readerconfig_cccambit.html                     MODULE_CCCAM
+READERCONFIGEMUBIT            readerconfig/readerconfig_emubit.html                       WITH_EMU
 READERCONFIGCS378XBIT         readerconfig/readerconfig_cs378xbit.html                    MODULE_CAMD35_TCP
 READERCONFIGGBOXBIT           readerconfig/readerconfig_gboxbit.html                      MODULE_GBOX
 READERCONFIGGHTTPBIT          readerconfig/readerconfig_ghttpbit.html                     MODULE_GHTTP
diff -ruN oscam-emu-2015-12-03-11142.orig/webif/readerconfig/readerconfig_emubit.html oscam-emu-2015-12-03-11142/webif/readerconfig/readerconfig_emubit.html
--- oscam-emu-2015-12-03-11142.orig/webif/readerconfig/readerconfig_emubit.html	1970-01-01 03:00:00.000000000 +0300
+++ oscam-emu-2015-12-03-11142/webif/readerconfig/readerconfig_emubit.html	2015-12-04 00:43:30.000000000 +0300
@@ -0,0 +1 @@
+			<TR><TD><A>AU providers:</A></TD><TD><textarea name="emu_auproviders" rows="3" class="bt">##EMUAUPROVIDERS##</textarea></TD></TR>
